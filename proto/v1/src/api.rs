// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `proto/v1/api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  Contained by an import or export element within a wasm binary.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.Function)
pub struct Function {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.Function.args)
    pub args: ::std::vec::Vec<::protobuf::EnumOrUnknown<ValType>>,
    // @@protoc_insertion_point(field:modsurfer.v1.Function.returns)
    pub returns: ::std::vec::Vec<::protobuf::EnumOrUnknown<ValType>>,
    // @@protoc_insertion_point(field:modsurfer.v1.Function.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.Function.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Function {
    fn default() -> &'a Function {
        <Function as ::protobuf::Message>::default_instance()
    }
}

impl Function {
    pub fn new() -> Function {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &Function| { &m.args },
            |m: &mut Function| { &mut m.args },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "returns",
            |m: &Function| { &m.returns },
            |m: &mut Function| { &mut m.returns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Function| { &m.name },
            |m: &mut Function| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Function>(
            "Function",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Function {
    const NAME: &'static str = "Function";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.args.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.args)?
                },
                16 => {
                    self.returns.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.returns)?
                },
                26 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.args {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        for value in &self.returns {
            my_size += ::protobuf::rt::int32_size(2, value.value());
        };
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.args {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.returns {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Function {
        Function::new()
    }

    fn clear(&mut self) {
        self.args.clear();
        self.returns.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Function {
        static instance: Function = Function {
            args: ::std::vec::Vec::new(),
            returns: ::std::vec::Vec::new(),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Function {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Function").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Function {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Function {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A function and module namespace that is defined outside of the current
///  module, and referenced & called by the current module.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.Import)
pub struct Import {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.Import.module_name)
    pub module_name: ::std::string::String,
    // @@protoc_insertion_point(field:modsurfer.v1.Import.func)
    pub func: ::protobuf::MessageField<Function>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.Import.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Import {
    fn default() -> &'a Import {
        <Import as ::protobuf::Message>::default_instance()
    }
}

impl Import {
    pub fn new() -> Import {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_name",
            |m: &Import| { &m.module_name },
            |m: &mut Import| { &mut m.module_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Function>(
            "func",
            |m: &Import| { &m.func },
            |m: &mut Import| { &mut m.func },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Import>(
            "Import",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Import {
    const NAME: &'static str = "Import";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.module_name = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.func)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.module_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.module_name);
        }
        if let Some(v) = self.func.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.module_name.is_empty() {
            os.write_string(1, &self.module_name)?;
        }
        if let Some(v) = self.func.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Import {
        Import::new()
    }

    fn clear(&mut self) {
        self.module_name.clear();
        self.func.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Import {
        static instance: Import = Import {
            module_name: ::std::string::String::new(),
            func: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Import {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Import").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Import {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Import {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A function that is defined inside the current module, made available to
///  outside modules / environments.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.Export)
pub struct Export {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.Export.func)
    pub func: ::protobuf::MessageField<Function>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.Export.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Export {
    fn default() -> &'a Export {
        <Export as ::protobuf::Message>::default_instance()
    }
}

impl Export {
    pub fn new() -> Export {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Function>(
            "func",
            |m: &Export| { &m.func },
            |m: &mut Export| { &mut m.func },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Export>(
            "Export",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Export {
    const NAME: &'static str = "Export";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.func)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.func.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.func.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Export {
        Export::new()
    }

    fn clear(&mut self) {
        self.func.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Export {
        static instance: Export = Export {
            func: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Export {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Export").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Export {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Export {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Details about a wasm module, either extracted directly from the binary, or
///  inferred somehow.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.Module)
pub struct Module {
    // message fields
    ///  ID for this module, generated by the database.
    // @@protoc_insertion_point(field:modsurfer.v1.Module.id)
    pub id: i64,
    ///  sha256 hash of the modules raw bytes
    // @@protoc_insertion_point(field:modsurfer.v1.Module.hash)
    pub hash: ::std::string::String,
    ///  function imports called by the module (see:
    ///  <https://github.com/WebAssembly/design/blob/main/Modules.md#imports)>
    // @@protoc_insertion_point(field:modsurfer.v1.Module.imports)
    pub imports: ::std::vec::Vec<Import>,
    ///  function exports provided by the module (see:
    ///  <https://github.com/WebAssembly/design/blob/main/Modules.md#exports)>
    // @@protoc_insertion_point(field:modsurfer.v1.Module.exports)
    pub exports: ::std::vec::Vec<Export>,
    ///  size in bytes of the module
    // @@protoc_insertion_point(field:modsurfer.v1.Module.size)
    pub size: u64,
    ///  path or locator to the module
    // @@protoc_insertion_point(field:modsurfer.v1.Module.location)
    pub location: ::std::string::String,
    ///  programming language used to produce this module
    // @@protoc_insertion_point(field:modsurfer.v1.Module.source_language)
    pub source_language: ::protobuf::EnumOrUnknown<SourceLanguage>,
    ///  arbitrary metadata provided by the operator of this module
    // @@protoc_insertion_point(field:modsurfer.v1.Module.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  timestamp when this module was loaded and stored
    // @@protoc_insertion_point(field:modsurfer.v1.Module.inserted_at)
    pub inserted_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  the interned strings stored in the wasm binary (panic/abort messages, etc.)
    // @@protoc_insertion_point(field:modsurfer.v1.Module.strings)
    pub strings: ::std::vec::Vec<::std::string::String>,
    ///  the cyclomatic complexity
    ///  (<https://en.wikipedia.org/wiki/Cyclomatic_complexity>) of the instructions
    // @@protoc_insertion_point(field:modsurfer.v1.Module.complexity)
    pub complexity: ::std::option::Option<u32>,
    ///  the grah in Dot format
    // @@protoc_insertion_point(field:modsurfer.v1.Module.graph)
    pub graph: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.Module.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Module {
    fn default() -> &'a Module {
        <Module as ::protobuf::Message>::default_instance()
    }
}

impl Module {
    pub fn new() -> Module {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Module| { &m.id },
            |m: &mut Module| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &Module| { &m.hash },
            |m: &mut Module| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "imports",
            |m: &Module| { &m.imports },
            |m: &mut Module| { &mut m.imports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exports",
            |m: &Module| { &m.exports },
            |m: &mut Module| { &mut m.exports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "size",
            |m: &Module| { &m.size },
            |m: &mut Module| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "location",
            |m: &Module| { &m.location },
            |m: &mut Module| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_language",
            |m: &Module| { &m.source_language },
            |m: &mut Module| { &mut m.source_language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metadata",
            |m: &Module| { &m.metadata },
            |m: &mut Module| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "inserted_at",
            |m: &Module| { &m.inserted_at },
            |m: &mut Module| { &mut m.inserted_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "strings",
            |m: &Module| { &m.strings },
            |m: &mut Module| { &mut m.strings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "complexity",
            |m: &Module| { &m.complexity },
            |m: &mut Module| { &mut m.complexity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "graph",
            |m: &Module| { &m.graph },
            |m: &mut Module| { &mut m.graph },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Module>(
            "Module",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Module {
    const NAME: &'static str = "Module";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int64()?;
                },
                26 => {
                    self.hash = is.read_string()?;
                },
                34 => {
                    self.imports.push(is.read_message()?);
                },
                42 => {
                    self.exports.push(is.read_message()?);
                },
                48 => {
                    self.size = is.read_uint64()?;
                },
                58 => {
                    self.location = is.read_string()?;
                },
                64 => {
                    self.source_language = is.read_enum_or_unknown()?;
                },
                74 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inserted_at)?;
                },
                90 => {
                    self.strings.push(is.read_string()?);
                },
                104 => {
                    self.complexity = ::std::option::Option::Some(is.read_uint32()?);
                },
                114 => {
                    self.graph = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.id);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.hash);
        }
        for value in &self.imports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.exports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.size != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.size);
        }
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.location);
        }
        if self.source_language != ::protobuf::EnumOrUnknown::new(SourceLanguage::Unknown) {
            my_size += ::protobuf::rt::int32_size(8, self.source_language.value());
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.inserted_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.strings {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(v) = self.complexity {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.graph.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if !self.hash.is_empty() {
            os.write_string(3, &self.hash)?;
        }
        for v in &self.imports {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.exports {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.size != 0 {
            os.write_uint64(6, self.size)?;
        }
        if !self.location.is_empty() {
            os.write_string(7, &self.location)?;
        }
        if self.source_language != ::protobuf::EnumOrUnknown::new(SourceLanguage::Unknown) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.source_language))?;
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(74)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.inserted_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        for v in &self.strings {
            os.write_string(11, &v)?;
        };
        if let Some(v) = self.complexity {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.graph.as_ref() {
            os.write_string(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Module {
        Module::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.hash.clear();
        self.imports.clear();
        self.exports.clear();
        self.size = 0;
        self.location.clear();
        self.source_language = ::protobuf::EnumOrUnknown::new(SourceLanguage::Unknown);
        self.metadata.clear();
        self.inserted_at.clear();
        self.strings.clear();
        self.complexity = ::std::option::Option::None;
        self.graph = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Module {
        static instance: ::protobuf::rt::Lazy<Module> = ::protobuf::rt::Lazy::new();
        instance.get(Module::new)
    }
}

impl ::protobuf::MessageFull for Module {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Module").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Module {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Module {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  An error message indicating a problem in the API.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.Error)
pub struct Error {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.Error.code)
    pub code: i32,
    // @@protoc_insertion_point(field:modsurfer.v1.Error.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.Error.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Error {
    fn default() -> &'a Error {
        <Error as ::protobuf::Message>::default_instance()
    }
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &Error| { &m.code },
            |m: &mut Error| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &Error| { &m.message },
            |m: &mut Error| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Error>(
            "Error",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Error {
    const NAME: &'static str = "Error";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_int32()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Error {
        Error::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Error {
        static instance: Error = Error {
            code: 0,
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Error {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Error").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Error {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Control/limit the way results are paginated when working with large
///  responses.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.Pagination)
pub struct Pagination {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.Pagination.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:modsurfer.v1.Pagination.offset)
    pub offset: u32,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.Pagination.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pagination {
    fn default() -> &'a Pagination {
        <Pagination as ::protobuf::Message>::default_instance()
    }
}

impl Pagination {
    pub fn new() -> Pagination {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &Pagination| { &m.limit },
            |m: &mut Pagination| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offset",
            |m: &Pagination| { &m.offset },
            |m: &mut Pagination| { &mut m.offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pagination>(
            "Pagination",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pagination {
    const NAME: &'static str = "Pagination";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.limit = is.read_uint32()?;
                },
                16 => {
                    self.offset = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.limit);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.offset);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.limit != 0 {
            os.write_uint32(1, self.limit)?;
        }
        if self.offset != 0 {
            os.write_uint32(2, self.offset)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pagination {
        Pagination::new()
    }

    fn clear(&mut self) {
        self.limit = 0;
        self.offset = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pagination {
        static instance: Pagination = Pagination {
            limit: 0,
            offset: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pagination {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pagination").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pagination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pagination {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Determine how to sort results from the API
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.Sort)
pub struct Sort {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.Sort.direction)
    pub direction: ::protobuf::EnumOrUnknown<Direction>,
    // @@protoc_insertion_point(field:modsurfer.v1.Sort.field)
    pub field: ::protobuf::EnumOrUnknown<Field>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.Sort.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Sort {
    fn default() -> &'a Sort {
        <Sort as ::protobuf::Message>::default_instance()
    }
}

impl Sort {
    pub fn new() -> Sort {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &Sort| { &m.direction },
            |m: &mut Sort| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "field",
            |m: &Sort| { &m.field },
            |m: &mut Sort| { &mut m.field },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sort>(
            "Sort",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Sort {
    const NAME: &'static str = "Sort";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.direction = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.field = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.direction != ::protobuf::EnumOrUnknown::new(Direction::Desc) {
            my_size += ::protobuf::rt::int32_size(1, self.direction.value());
        }
        if self.field != ::protobuf::EnumOrUnknown::new(Field::CreatedAt) {
            my_size += ::protobuf::rt::int32_size(2, self.field.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.direction != ::protobuf::EnumOrUnknown::new(Direction::Desc) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.direction))?;
        }
        if self.field != ::protobuf::EnumOrUnknown::new(Field::CreatedAt) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.field))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Sort {
        Sort::new()
    }

    fn clear(&mut self) {
        self.direction = ::protobuf::EnumOrUnknown::new(Direction::Desc);
        self.field = ::protobuf::EnumOrUnknown::new(Field::CreatedAt);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Sort {
        static instance: Sort = Sort {
            direction: ::protobuf::EnumOrUnknown::from_i32(0),
            field: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Sort {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Sort").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Sort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sort {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `PUT /api/v1/module:`
///  Insert a module, extract data from binary. Return the module ID & hash.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.CreateModuleRequest)
pub struct CreateModuleRequest {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.CreateModuleRequest.wasm)
    pub wasm: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:modsurfer.v1.CreateModuleRequest.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  a valid URL with a scheme prefix e.g. `s3://`, `file://`, `https://`
    // @@protoc_insertion_point(field:modsurfer.v1.CreateModuleRequest.location)
    pub location: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.CreateModuleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateModuleRequest {
    fn default() -> &'a CreateModuleRequest {
        <CreateModuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateModuleRequest {
    pub fn new() -> CreateModuleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wasm",
            |m: &CreateModuleRequest| { &m.wasm },
            |m: &mut CreateModuleRequest| { &mut m.wasm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metadata",
            |m: &CreateModuleRequest| { &m.metadata },
            |m: &mut CreateModuleRequest| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location",
            |m: &CreateModuleRequest| { &m.location },
            |m: &mut CreateModuleRequest| { &mut m.location },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateModuleRequest>(
            "CreateModuleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateModuleRequest {
    const NAME: &'static str = "CreateModuleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.wasm = is.read_bytes()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                26 => {
                    self.location = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.wasm.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.wasm);
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.wasm.is_empty() {
            os.write_bytes(1, &self.wasm)?;
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.location.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateModuleRequest {
        CreateModuleRequest::new()
    }

    fn clear(&mut self) {
        self.wasm.clear();
        self.metadata.clear();
        self.location = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateModuleRequest {
        static instance: ::protobuf::rt::Lazy<CreateModuleRequest> = ::protobuf::rt::Lazy::new();
        instance.get(CreateModuleRequest::new)
    }
}

impl ::protobuf::MessageFull for CreateModuleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateModuleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateModuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateModuleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `CreateModuleRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.CreateModuleResponse)
pub struct CreateModuleResponse {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.CreateModuleResponse.module_id)
    pub module_id: i64,
    // @@protoc_insertion_point(field:modsurfer.v1.CreateModuleResponse.hash)
    pub hash: ::std::string::String,
    // @@protoc_insertion_point(field:modsurfer.v1.CreateModuleResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.CreateModuleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateModuleResponse {
    fn default() -> &'a CreateModuleResponse {
        <CreateModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateModuleResponse {
    pub fn new() -> CreateModuleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &CreateModuleResponse| { &m.module_id },
            |m: &mut CreateModuleResponse| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &CreateModuleResponse| { &m.hash },
            |m: &mut CreateModuleResponse| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &CreateModuleResponse| { &m.error },
            |m: &mut CreateModuleResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateModuleResponse>(
            "CreateModuleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateModuleResponse {
    const NAME: &'static str = "CreateModuleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.module_id = is.read_int64()?;
                },
                18 => {
                    self.hash = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.module_id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.module_id);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hash);
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.module_id != 0 {
            os.write_int64(1, self.module_id)?;
        }
        if !self.hash.is_empty() {
            os.write_string(2, &self.hash)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateModuleResponse {
        CreateModuleResponse::new()
    }

    fn clear(&mut self) {
        self.module_id = 0;
        self.hash.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateModuleResponse {
        static instance: CreateModuleResponse = CreateModuleResponse {
            module_id: 0,
            hash: ::std::string::String::new(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateModuleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateModuleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateModuleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/module:`
///  Return a single module.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.GetModuleRequest)
pub struct GetModuleRequest {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.GetModuleRequest.module_id)
    pub module_id: i64,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.GetModuleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleRequest {
    fn default() -> &'a GetModuleRequest {
        <GetModuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleRequest {
    pub fn new() -> GetModuleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &GetModuleRequest| { &m.module_id },
            |m: &mut GetModuleRequest| { &mut m.module_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleRequest>(
            "GetModuleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleRequest {
    const NAME: &'static str = "GetModuleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.module_id = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.module_id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.module_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.module_id != 0 {
            os.write_int64(1, self.module_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleRequest {
        GetModuleRequest::new()
    }

    fn clear(&mut self) {
        self.module_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleRequest {
        static instance: GetModuleRequest = GetModuleRequest {
            module_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `GetModuleRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.GetModuleResponse)
pub struct GetModuleResponse {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.GetModuleResponse.module)
    pub module: ::protobuf::MessageField<Module>,
    // @@protoc_insertion_point(field:modsurfer.v1.GetModuleResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.GetModuleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleResponse {
    fn default() -> &'a GetModuleResponse {
        <GetModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleResponse {
    pub fn new() -> GetModuleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Module>(
            "module",
            |m: &GetModuleResponse| { &m.module },
            |m: &mut GetModuleResponse| { &mut m.module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &GetModuleResponse| { &m.error },
            |m: &mut GetModuleResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleResponse>(
            "GetModuleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleResponse {
    const NAME: &'static str = "GetModuleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.module.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleResponse {
        GetModuleResponse::new()
    }

    fn clear(&mut self) {
        self.module.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleResponse {
        static instance: GetModuleResponse = GetModuleResponse {
            module: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/modules:`
///  Return paginated list of all modules.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.ListModulesRequest)
pub struct ListModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.ListModulesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // @@protoc_insertion_point(field:modsurfer.v1.ListModulesRequest.sort)
    pub sort: ::protobuf::MessageField<Sort>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.ListModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModulesRequest {
    fn default() -> &'a ListModulesRequest {
        <ListModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModulesRequest {
    pub fn new() -> ListModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &ListModulesRequest| { &m.pagination },
            |m: &mut ListModulesRequest| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Sort>(
            "sort",
            |m: &ListModulesRequest| { &m.sort },
            |m: &mut ListModulesRequest| { &mut m.sort },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModulesRequest>(
            "ListModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModulesRequest {
    const NAME: &'static str = "ListModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sort)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.sort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModulesRequest {
        ListModulesRequest::new()
    }

    fn clear(&mut self) {
        self.pagination.clear();
        self.sort.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModulesRequest {
        static instance: ListModulesRequest = ListModulesRequest {
            pagination: ::protobuf::MessageField::none(),
            sort: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `ListModulesRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.ListModulesResponse)
pub struct ListModulesResponse {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.ListModulesResponse.modules)
    pub modules: ::std::vec::Vec<Module>,
    // @@protoc_insertion_point(field:modsurfer.v1.ListModulesResponse.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    ///  the full count of results in the database (not the count of this message's
    ///  `modules`).
    // @@protoc_insertion_point(field:modsurfer.v1.ListModulesResponse.total)
    pub total: u64,
    // @@protoc_insertion_point(field:modsurfer.v1.ListModulesResponse.sort)
    pub sort: ::protobuf::MessageField<Sort>,
    // @@protoc_insertion_point(field:modsurfer.v1.ListModulesResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.ListModulesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModulesResponse {
    fn default() -> &'a ListModulesResponse {
        <ListModulesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListModulesResponse {
    pub fn new() -> ListModulesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &ListModulesResponse| { &m.modules },
            |m: &mut ListModulesResponse| { &mut m.modules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &ListModulesResponse| { &m.pagination },
            |m: &mut ListModulesResponse| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &ListModulesResponse| { &m.total },
            |m: &mut ListModulesResponse| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Sort>(
            "sort",
            |m: &ListModulesResponse| { &m.sort },
            |m: &mut ListModulesResponse| { &mut m.sort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &ListModulesResponse| { &m.error },
            |m: &mut ListModulesResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModulesResponse>(
            "ListModulesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModulesResponse {
    const NAME: &'static str = "ListModulesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.modules.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                24 => {
                    self.total = is.read_uint64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sort)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.total);
        }
        if let Some(v) = self.sort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.total != 0 {
            os.write_uint64(3, self.total)?;
        }
        if let Some(v) = self.sort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModulesResponse {
        ListModulesResponse::new()
    }

    fn clear(&mut self) {
        self.modules.clear();
        self.pagination.clear();
        self.total = 0;
        self.sort.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModulesResponse {
        static instance: ListModulesResponse = ListModulesResponse {
            modules: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            total: 0,
            sort: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModulesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModulesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModulesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModulesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/search:`
///  Search for modules based on filter params provided (which should be any
///  dimension of the module schema, or string search in any metadata value).
///  Return a paginated list of matching modules.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.SearchModulesRequest)
pub struct SearchModulesRequest {
    // message fields
    ///  ID for this module, generated by the database.
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.id)
    pub id: ::std::option::Option<i64>,
    ///  original name of the binary module file
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.hash)
    pub hash: ::std::option::Option<::std::string::String>,
    ///  function imports called by the module (see:
    ///  <https://github.com/WebAssembly/design/blob/main/Modules.md#imports>)
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.imports)
    pub imports: ::std::vec::Vec<Import>,
    ///  function exports provided by the module (see:
    ///  <https://github.com/WebAssembly/design/blob/main/Modules.md#exports>)
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.exports)
    pub exports: ::std::vec::Vec<Export>,
    ///  minimum size in bytes of the module
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.min_size)
    pub min_size: ::std::option::Option<u64>,
    ///  maximum size in bytes of the module
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.max_size)
    pub max_size: ::std::option::Option<u64>,
    ///  optional path or locator to the module (TODO: maybe this is better stored
    ///  as metadata)
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.location)
    pub location: ::std::option::Option<::std::string::String>,
    ///  programming language used to produce this module
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.source_language)
    pub source_language: ::std::option::Option<::protobuf::EnumOrUnknown<SourceLanguage>>,
    ///  arbitrary metadata provided by the operator of this module
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  timestamp when this module was loaded and stored
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.inserted_before)
    pub inserted_before: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  timestamp when this module was loaded and stored
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.inserted_after)
    pub inserted_after: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  the interned strings stored in the wasm binary (panic/abort messages, etc.)
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.strings)
    pub strings: ::std::vec::Vec<::std::string::String>,
    ///  match on any function name in an import or export.
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.function_name)
    pub function_name: ::std::option::Option<::std::string::String>,
    ///  match on the module name e.g. `env` or `wasi_snapshot_preview1`
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.module_name)
    pub module_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesRequest.sort)
    pub sort: ::protobuf::MessageField<Sort>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.SearchModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SearchModulesRequest {
    fn default() -> &'a SearchModulesRequest {
        <SearchModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SearchModulesRequest {
    pub fn new() -> SearchModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &SearchModulesRequest| { &m.id },
            |m: &mut SearchModulesRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &SearchModulesRequest| { &m.hash },
            |m: &mut SearchModulesRequest| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "imports",
            |m: &SearchModulesRequest| { &m.imports },
            |m: &mut SearchModulesRequest| { &mut m.imports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exports",
            |m: &SearchModulesRequest| { &m.exports },
            |m: &mut SearchModulesRequest| { &mut m.exports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_size",
            |m: &SearchModulesRequest| { &m.min_size },
            |m: &mut SearchModulesRequest| { &mut m.min_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_size",
            |m: &SearchModulesRequest| { &m.max_size },
            |m: &mut SearchModulesRequest| { &mut m.max_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location",
            |m: &SearchModulesRequest| { &m.location },
            |m: &mut SearchModulesRequest| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_language",
            |m: &SearchModulesRequest| { &m.source_language },
            |m: &mut SearchModulesRequest| { &mut m.source_language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metadata",
            |m: &SearchModulesRequest| { &m.metadata },
            |m: &mut SearchModulesRequest| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "inserted_before",
            |m: &SearchModulesRequest| { &m.inserted_before },
            |m: &mut SearchModulesRequest| { &mut m.inserted_before },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "inserted_after",
            |m: &SearchModulesRequest| { &m.inserted_after },
            |m: &mut SearchModulesRequest| { &mut m.inserted_after },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "strings",
            |m: &SearchModulesRequest| { &m.strings },
            |m: &mut SearchModulesRequest| { &mut m.strings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "function_name",
            |m: &SearchModulesRequest| { &m.function_name },
            |m: &mut SearchModulesRequest| { &mut m.function_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_name",
            |m: &SearchModulesRequest| { &m.module_name },
            |m: &mut SearchModulesRequest| { &mut m.module_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &SearchModulesRequest| { &m.pagination },
            |m: &mut SearchModulesRequest| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Sort>(
            "sort",
            |m: &SearchModulesRequest| { &m.sort },
            |m: &mut SearchModulesRequest| { &mut m.sort },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SearchModulesRequest>(
            "SearchModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SearchModulesRequest {
    const NAME: &'static str = "SearchModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.hash = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.imports.push(is.read_message()?);
                },
                42 => {
                    self.exports.push(is.read_message()?);
                },
                48 => {
                    self.min_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.max_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                66 => {
                    self.location = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.source_language = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                82 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inserted_before)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inserted_after)?;
                },
                106 => {
                    self.strings.push(is.read_string()?);
                },
                114 => {
                    self.function_name = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.module_name = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sort)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.imports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.exports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.min_size {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.max_size {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.source_language {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.inserted_before.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.inserted_after.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.strings {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        if let Some(v) = self.function_name.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.module_name.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sort.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.hash.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.imports {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.exports {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.min_size {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.max_size {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.location.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.source_language {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(82)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.inserted_before.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.inserted_after.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        for v in &self.strings {
            os.write_string(13, &v)?;
        };
        if let Some(v) = self.function_name.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.module_name.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.sort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SearchModulesRequest {
        SearchModulesRequest::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.hash = ::std::option::Option::None;
        self.imports.clear();
        self.exports.clear();
        self.min_size = ::std::option::Option::None;
        self.max_size = ::std::option::Option::None;
        self.location = ::std::option::Option::None;
        self.source_language = ::std::option::Option::None;
        self.metadata.clear();
        self.inserted_before.clear();
        self.inserted_after.clear();
        self.strings.clear();
        self.function_name = ::std::option::Option::None;
        self.module_name = ::std::option::Option::None;
        self.pagination.clear();
        self.sort.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SearchModulesRequest {
        static instance: ::protobuf::rt::Lazy<SearchModulesRequest> = ::protobuf::rt::Lazy::new();
        instance.get(SearchModulesRequest::new)
    }
}

impl ::protobuf::MessageFull for SearchModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SearchModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SearchModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `SearchModulesRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.SearchModulesResponse)
pub struct SearchModulesResponse {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesResponse.modules)
    pub modules: ::std::vec::Vec<Module>,
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesResponse.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    ///  the full count of results in the database (not the count of this message's
    ///  `modules`).
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesResponse.total)
    pub total: u64,
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesResponse.sort)
    pub sort: ::protobuf::MessageField<Sort>,
    // @@protoc_insertion_point(field:modsurfer.v1.SearchModulesResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.SearchModulesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SearchModulesResponse {
    fn default() -> &'a SearchModulesResponse {
        <SearchModulesResponse as ::protobuf::Message>::default_instance()
    }
}

impl SearchModulesResponse {
    pub fn new() -> SearchModulesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &SearchModulesResponse| { &m.modules },
            |m: &mut SearchModulesResponse| { &mut m.modules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &SearchModulesResponse| { &m.pagination },
            |m: &mut SearchModulesResponse| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &SearchModulesResponse| { &m.total },
            |m: &mut SearchModulesResponse| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Sort>(
            "sort",
            |m: &SearchModulesResponse| { &m.sort },
            |m: &mut SearchModulesResponse| { &mut m.sort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &SearchModulesResponse| { &m.error },
            |m: &mut SearchModulesResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SearchModulesResponse>(
            "SearchModulesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SearchModulesResponse {
    const NAME: &'static str = "SearchModulesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.modules.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                24 => {
                    self.total = is.read_uint64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sort)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.total);
        }
        if let Some(v) = self.sort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.total != 0 {
            os.write_uint64(3, self.total)?;
        }
        if let Some(v) = self.sort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SearchModulesResponse {
        SearchModulesResponse::new()
    }

    fn clear(&mut self) {
        self.modules.clear();
        self.pagination.clear();
        self.total = 0;
        self.sort.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SearchModulesResponse {
        static instance: SearchModulesResponse = SearchModulesResponse {
            modules: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            total: 0,
            sort: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SearchModulesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SearchModulesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SearchModulesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchModulesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `DELETE /api/v1/module:`
///  Remove a module from the database by its ID. Return the module IDs & hashes.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.DeleteModulesRequest)
pub struct DeleteModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.DeleteModulesRequest.module_ids)
    pub module_ids: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.DeleteModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModulesRequest {
    fn default() -> &'a DeleteModulesRequest {
        <DeleteModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModulesRequest {
    pub fn new() -> DeleteModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "module_ids",
            |m: &DeleteModulesRequest| { &m.module_ids },
            |m: &mut DeleteModulesRequest| { &mut m.module_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModulesRequest>(
            "DeleteModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModulesRequest {
    const NAME: &'static str = "DeleteModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int64_into(&mut self.module_ids)?;
                },
                8 => {
                    self.module_ids.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.module_ids {
            my_size += ::protobuf::rt::int64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.module_ids {
            os.write_int64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModulesRequest {
        DeleteModulesRequest::new()
    }

    fn clear(&mut self) {
        self.module_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModulesRequest {
        static instance: DeleteModulesRequest = DeleteModulesRequest {
            module_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `DeleteModulesRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.DeleteModulesResponse)
pub struct DeleteModulesResponse {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.DeleteModulesResponse.module_id_hash)
    pub module_id_hash: ::std::collections::HashMap<i64, ::std::string::String>,
    // @@protoc_insertion_point(field:modsurfer.v1.DeleteModulesResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.DeleteModulesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModulesResponse {
    fn default() -> &'a DeleteModulesResponse {
        <DeleteModulesResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModulesResponse {
    pub fn new() -> DeleteModulesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "module_id_hash",
            |m: &DeleteModulesResponse| { &m.module_id_hash },
            |m: &mut DeleteModulesResponse| { &mut m.module_id_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &DeleteModulesResponse| { &m.error },
            |m: &mut DeleteModulesResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModulesResponse>(
            "DeleteModulesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModulesResponse {
    const NAME: &'static str = "DeleteModulesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int64()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.module_id_hash.insert(key, value);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.module_id_hash {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.module_id_hash {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int64(1, *k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModulesResponse {
        DeleteModulesResponse::new()
    }

    fn clear(&mut self) {
        self.module_id_hash.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModulesResponse {
        static instance: ::protobuf::rt::Lazy<DeleteModulesResponse> = ::protobuf::rt::Lazy::new();
        instance.get(DeleteModulesResponse::new)
    }
}

impl ::protobuf::MessageFull for DeleteModulesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModulesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModulesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModulesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/audit:`
///  Return a list of modules which match the outcome requirements using the provided checkfile.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.AuditModulesRequest)
pub struct AuditModulesRequest {
    // message fields
    ///  the YAML checkfile (e.g. mod.yaml) bytes
    // @@protoc_insertion_point(field:modsurfer.v1.AuditModulesRequest.checkfile)
    pub checkfile: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:modsurfer.v1.AuditModulesRequest.outcome)
    pub outcome: ::protobuf::EnumOrUnknown<AuditOutcome>,
    // @@protoc_insertion_point(field:modsurfer.v1.AuditModulesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.AuditModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuditModulesRequest {
    fn default() -> &'a AuditModulesRequest {
        <AuditModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuditModulesRequest {
    pub fn new() -> AuditModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "checkfile",
            |m: &AuditModulesRequest| { &m.checkfile },
            |m: &mut AuditModulesRequest| { &mut m.checkfile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "outcome",
            |m: &AuditModulesRequest| { &m.outcome },
            |m: &mut AuditModulesRequest| { &mut m.outcome },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &AuditModulesRequest| { &m.pagination },
            |m: &mut AuditModulesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuditModulesRequest>(
            "AuditModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuditModulesRequest {
    const NAME: &'static str = "AuditModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.checkfile = is.read_bytes()?;
                },
                16 => {
                    self.outcome = is.read_enum_or_unknown()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.checkfile.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.checkfile);
        }
        if self.outcome != ::protobuf::EnumOrUnknown::new(AuditOutcome::PASS) {
            my_size += ::protobuf::rt::int32_size(2, self.outcome.value());
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.checkfile.is_empty() {
            os.write_bytes(1, &self.checkfile)?;
        }
        if self.outcome != ::protobuf::EnumOrUnknown::new(AuditOutcome::PASS) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.outcome))?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuditModulesRequest {
        AuditModulesRequest::new()
    }

    fn clear(&mut self) {
        self.checkfile.clear();
        self.outcome = ::protobuf::EnumOrUnknown::new(AuditOutcome::PASS);
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuditModulesRequest {
        static instance: AuditModulesRequest = AuditModulesRequest {
            checkfile: ::std::vec::Vec::new(),
            outcome: ::protobuf::EnumOrUnknown::from_i32(0),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AuditModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuditModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuditModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `AuditModulesRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.AuditModulesResponse)
pub struct AuditModulesResponse {
    // message fields
    ///  each record contains the ID of the invalid Module which failed the audit, as well as the failure 
    ///  report produced by the validation check (encoded in JSON)
    // @@protoc_insertion_point(field:modsurfer.v1.AuditModulesResponse.invalid_module_report)
    pub invalid_module_report: ::std::collections::HashMap<i64, ::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:modsurfer.v1.AuditModulesResponse.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    ///  the full count of results in the database (not the count of this message's
    ///  `modules`).
    // @@protoc_insertion_point(field:modsurfer.v1.AuditModulesResponse.total)
    pub total: u64,
    // @@protoc_insertion_point(field:modsurfer.v1.AuditModulesResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.AuditModulesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuditModulesResponse {
    fn default() -> &'a AuditModulesResponse {
        <AuditModulesResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuditModulesResponse {
    pub fn new() -> AuditModulesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "invalid_module_report",
            |m: &AuditModulesResponse| { &m.invalid_module_report },
            |m: &mut AuditModulesResponse| { &mut m.invalid_module_report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &AuditModulesResponse| { &m.pagination },
            |m: &mut AuditModulesResponse| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &AuditModulesResponse| { &m.total },
            |m: &mut AuditModulesResponse| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &AuditModulesResponse| { &m.error },
            |m: &mut AuditModulesResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuditModulesResponse>(
            "AuditModulesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuditModulesResponse {
    const NAME: &'static str = "AuditModulesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int64()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.invalid_module_report.insert(key, value);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                24 => {
                    self.total = is.read_uint64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.invalid_module_report {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.total);
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.invalid_module_report {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int64(1, *k)?;
            os.write_bytes(2, &v)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.total != 0 {
            os.write_uint64(3, self.total)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuditModulesResponse {
        AuditModulesResponse::new()
    }

    fn clear(&mut self) {
        self.invalid_module_report.clear();
        self.pagination.clear();
        self.total = 0;
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuditModulesResponse {
        static instance: ::protobuf::rt::Lazy<AuditModulesResponse> = ::protobuf::rt::Lazy::new();
        instance.get(AuditModulesResponse::new)
    }
}

impl ::protobuf::MessageFull for AuditModulesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuditModulesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuditModulesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditModulesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  provides context around the validation failure, used in the Report
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.FailureDetail)
pub struct FailureDetail {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.FailureDetail.actual)
    pub actual: ::std::string::String,
    // @@protoc_insertion_point(field:modsurfer.v1.FailureDetail.expected)
    pub expected: ::std::string::String,
    // @@protoc_insertion_point(field:modsurfer.v1.FailureDetail.severity)
    pub severity: u32,
    // @@protoc_insertion_point(field:modsurfer.v1.FailureDetail.classification)
    pub classification: ::protobuf::EnumOrUnknown<Classification>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.FailureDetail.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FailureDetail {
    fn default() -> &'a FailureDetail {
        <FailureDetail as ::protobuf::Message>::default_instance()
    }
}

impl FailureDetail {
    pub fn new() -> FailureDetail {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "actual",
            |m: &FailureDetail| { &m.actual },
            |m: &mut FailureDetail| { &mut m.actual },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expected",
            |m: &FailureDetail| { &m.expected },
            |m: &mut FailureDetail| { &mut m.expected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "severity",
            |m: &FailureDetail| { &m.severity },
            |m: &mut FailureDetail| { &mut m.severity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "classification",
            |m: &FailureDetail| { &m.classification },
            |m: &mut FailureDetail| { &mut m.classification },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FailureDetail>(
            "FailureDetail",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FailureDetail {
    const NAME: &'static str = "FailureDetail";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actual = is.read_string()?;
                },
                18 => {
                    self.expected = is.read_string()?;
                },
                24 => {
                    self.severity = is.read_uint32()?;
                },
                32 => {
                    self.classification = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.actual.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.actual);
        }
        if !self.expected.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.expected);
        }
        if self.severity != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.severity);
        }
        if self.classification != ::protobuf::EnumOrUnknown::new(Classification::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(4, self.classification.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.actual.is_empty() {
            os.write_string(1, &self.actual)?;
        }
        if !self.expected.is_empty() {
            os.write_string(2, &self.expected)?;
        }
        if self.severity != 0 {
            os.write_uint32(3, self.severity)?;
        }
        if self.classification != ::protobuf::EnumOrUnknown::new(Classification::UNKNOWN) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.classification))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FailureDetail {
        FailureDetail::new()
    }

    fn clear(&mut self) {
        self.actual.clear();
        self.expected.clear();
        self.severity = 0;
        self.classification = ::protobuf::EnumOrUnknown::new(Classification::UNKNOWN);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FailureDetail {
        static instance: FailureDetail = FailureDetail {
            actual: ::std::string::String::new(),
            expected: ::std::string::String::new(),
            severity: 0,
            classification: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FailureDetail {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FailureDetail").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FailureDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FailureDetail {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  k/v pair of the dot-separated path to validation field and expectation info, plus any info
///  provided by plugins executed after built-in validation
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.Report)
pub struct Report {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.Report.fails)
    pub fails: ::std::collections::HashMap<::std::string::String, FailureDetail>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.Report.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Report {
    fn default() -> &'a Report {
        <Report as ::protobuf::Message>::default_instance()
    }
}

impl Report {
    pub fn new() -> Report {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "fails",
            |m: &Report| { &m.fails },
            |m: &mut Report| { &mut m.fails },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Report>(
            "Report",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Report {
    const NAME: &'static str = "Report";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.fails.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.fails {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.fails {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Report {
        Report::new()
    }

    fn clear(&mut self) {
        self.fails.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Report {
        static instance: ::protobuf::rt::Lazy<Report> = ::protobuf::rt::Lazy::new();
        instance.get(Report::new)
    }
}

impl ::protobuf::MessageFull for Report {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Report").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Report {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Report {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  input provided to a plugin when it is executed, possibly after another plugin, who would update
///  the report and provide it to the currently running plugin via this value
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.PluginInput)
pub struct PluginInput {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.PluginInput.report)
    pub report: ::protobuf::MessageField<Report>,
    // @@protoc_insertion_point(field:modsurfer.v1.PluginInput.module)
    pub module: ::protobuf::MessageField<Module>,
    // @@protoc_insertion_point(field:modsurfer.v1.PluginInput.wasm)
    pub wasm: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.PluginInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PluginInput {
    fn default() -> &'a PluginInput {
        <PluginInput as ::protobuf::Message>::default_instance()
    }
}

impl PluginInput {
    pub fn new() -> PluginInput {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Report>(
            "report",
            |m: &PluginInput| { &m.report },
            |m: &mut PluginInput| { &mut m.report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Module>(
            "module",
            |m: &PluginInput| { &m.module },
            |m: &mut PluginInput| { &mut m.module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wasm",
            |m: &PluginInput| { &m.wasm },
            |m: &mut PluginInput| { &mut m.wasm },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PluginInput>(
            "PluginInput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PluginInput {
    const NAME: &'static str = "PluginInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.report)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module)?;
                },
                26 => {
                    self.wasm = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.report.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.wasm.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.wasm);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.report.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.module.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.wasm.is_empty() {
            os.write_bytes(3, &self.wasm)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PluginInput {
        PluginInput::new()
    }

    fn clear(&mut self) {
        self.report.clear();
        self.module.clear();
        self.wasm.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PluginInput {
        static instance: PluginInput = PluginInput {
            report: ::protobuf::MessageField::none(),
            module: ::protobuf::MessageField::none(),
            wasm: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PluginInput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PluginInput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PluginInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PluginInput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  output returned from a plugin after it's executed, containing failures which are added to the 
///  parent context Report, which will be provided to the plugin's serial nested Report
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:modsurfer.v1.PluginOutput)
pub struct PluginOutput {
    // message fields
    // @@protoc_insertion_point(field:modsurfer.v1.PluginOutput.failures)
    pub failures: ::std::vec::Vec<FailureDetail>,
    // special fields
    // @@protoc_insertion_point(special_field:modsurfer.v1.PluginOutput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PluginOutput {
    fn default() -> &'a PluginOutput {
        <PluginOutput as ::protobuf::Message>::default_instance()
    }
}

impl PluginOutput {
    pub fn new() -> PluginOutput {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "failures",
            |m: &PluginOutput| { &m.failures },
            |m: &mut PluginOutput| { &mut m.failures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PluginOutput>(
            "PluginOutput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PluginOutput {
    const NAME: &'static str = "PluginOutput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.failures.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.failures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.failures {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PluginOutput {
        PluginOutput::new()
    }

    fn clear(&mut self) {
        self.failures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PluginOutput {
        static instance: PluginOutput = PluginOutput {
            failures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PluginOutput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PluginOutput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PluginOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PluginOutput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Used to type the arguments and return types from wasm elements such as import
///  and export functions.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:modsurfer.v1.ValType)
pub enum ValType {
    // @@protoc_insertion_point(enum_value:modsurfer.v1.ValType.I32)
    I32 = 0,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.ValType.I64)
    I64 = 1,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.ValType.F32)
    F32 = 2,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.ValType.F64)
    F64 = 3,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.ValType.V128)
    V128 = 4,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.ValType.FuncRef)
    FuncRef = 5,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.ValType.ExternRef)
    ExternRef = 6,
}

impl ::protobuf::Enum for ValType {
    const NAME: &'static str = "ValType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ValType> {
        match value {
            0 => ::std::option::Option::Some(ValType::I32),
            1 => ::std::option::Option::Some(ValType::I64),
            2 => ::std::option::Option::Some(ValType::F32),
            3 => ::std::option::Option::Some(ValType::F64),
            4 => ::std::option::Option::Some(ValType::V128),
            5 => ::std::option::Option::Some(ValType::FuncRef),
            6 => ::std::option::Option::Some(ValType::ExternRef),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ValType] = &[
        ValType::I32,
        ValType::I64,
        ValType::F32,
        ValType::F64,
        ValType::V128,
        ValType::FuncRef,
        ValType::ExternRef,
    ];
}

impl ::protobuf::EnumFull for ValType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ValType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ValType {
    fn default() -> Self {
        ValType::I32
    }
}

impl ValType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ValType>("ValType")
    }
}

///  The language (or most similar match) used to produce a wasm module.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:modsurfer.v1.SourceLanguage)
pub enum SourceLanguage {
    // @@protoc_insertion_point(enum_value:modsurfer.v1.SourceLanguage.Unknown)
    Unknown = 0,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.SourceLanguage.Rust)
    Rust = 1,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.SourceLanguage.Go)
    Go = 2,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.SourceLanguage.C)
    C = 3,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.SourceLanguage.Cpp)
    Cpp = 4,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.SourceLanguage.AssemblyScript)
    AssemblyScript = 5,
}

impl ::protobuf::Enum for SourceLanguage {
    const NAME: &'static str = "SourceLanguage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SourceLanguage> {
        match value {
            0 => ::std::option::Option::Some(SourceLanguage::Unknown),
            1 => ::std::option::Option::Some(SourceLanguage::Rust),
            2 => ::std::option::Option::Some(SourceLanguage::Go),
            3 => ::std::option::Option::Some(SourceLanguage::C),
            4 => ::std::option::Option::Some(SourceLanguage::Cpp),
            5 => ::std::option::Option::Some(SourceLanguage::AssemblyScript),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SourceLanguage] = &[
        SourceLanguage::Unknown,
        SourceLanguage::Rust,
        SourceLanguage::Go,
        SourceLanguage::C,
        SourceLanguage::Cpp,
        SourceLanguage::AssemblyScript,
    ];
}

impl ::protobuf::EnumFull for SourceLanguage {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SourceLanguage").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SourceLanguage {
    fn default() -> Self {
        SourceLanguage::Unknown
    }
}

impl SourceLanguage {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SourceLanguage>("SourceLanguage")
    }
}

///  The direction, descending or ascending, of the sort operation.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:modsurfer.v1.Direction)
pub enum Direction {
    // @@protoc_insertion_point(enum_value:modsurfer.v1.Direction.Desc)
    Desc = 0,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.Direction.Asc)
    Asc = 1,
}

impl ::protobuf::Enum for Direction {
    const NAME: &'static str = "Direction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Direction> {
        match value {
            0 => ::std::option::Option::Some(Direction::Desc),
            1 => ::std::option::Option::Some(Direction::Asc),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Direction] = &[
        Direction::Desc,
        Direction::Asc,
    ];
}

impl ::protobuf::EnumFull for Direction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Direction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Direction {
    fn default() -> Self {
        Direction::Desc
    }
}

impl Direction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Direction>("Direction")
    }
}

///  The field within the Module schema that is used as the sorting dimension.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:modsurfer.v1.Field)
pub enum Field {
    // @@protoc_insertion_point(enum_value:modsurfer.v1.Field.CreatedAt)
    CreatedAt = 0,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.Field.Name)
    Name = 1,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.Field.Size)
    Size = 2,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.Field.Language)
    Language = 3,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.Field.ImportsCount)
    ImportsCount = 4,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.Field.ExportsCount)
    ExportsCount = 5,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.Field.Sha256)
    Sha256 = 6,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.Field.Complexity)
    Complexity = 7,
}

impl ::protobuf::Enum for Field {
    const NAME: &'static str = "Field";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Field> {
        match value {
            0 => ::std::option::Option::Some(Field::CreatedAt),
            1 => ::std::option::Option::Some(Field::Name),
            2 => ::std::option::Option::Some(Field::Size),
            3 => ::std::option::Option::Some(Field::Language),
            4 => ::std::option::Option::Some(Field::ImportsCount),
            5 => ::std::option::Option::Some(Field::ExportsCount),
            6 => ::std::option::Option::Some(Field::Sha256),
            7 => ::std::option::Option::Some(Field::Complexity),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Field] = &[
        Field::CreatedAt,
        Field::Name,
        Field::Size,
        Field::Language,
        Field::ImportsCount,
        Field::ExportsCount,
        Field::Sha256,
        Field::Complexity,
    ];
}

impl ::protobuf::EnumFull for Field {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Field").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Field {
    fn default() -> Self {
        Field::CreatedAt
    }
}

impl Field {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Field>("Field")
    }
}

///  Represents the expected outcome of an AuditModulesRequest. If PASS is provided, then
///  the audit returns modules which conform to the checkfile. If FAIL is provided, then
///  the audit returns modules which do not conform to the checkfile.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:modsurfer.v1.AuditOutcome)
pub enum AuditOutcome {
    // @@protoc_insertion_point(enum_value:modsurfer.v1.AuditOutcome.PASS)
    PASS = 0,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.AuditOutcome.FAIL)
    FAIL = 1,
}

impl ::protobuf::Enum for AuditOutcome {
    const NAME: &'static str = "AuditOutcome";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuditOutcome> {
        match value {
            0 => ::std::option::Option::Some(AuditOutcome::PASS),
            1 => ::std::option::Option::Some(AuditOutcome::FAIL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AuditOutcome] = &[
        AuditOutcome::PASS,
        AuditOutcome::FAIL,
    ];
}

impl ::protobuf::EnumFull for AuditOutcome {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AuditOutcome").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AuditOutcome {
    fn default() -> Self {
        AuditOutcome::PASS
    }
}

impl AuditOutcome {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AuditOutcome>("AuditOutcome")
    }
}

///  classifies a validation failure as a particular kind
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:modsurfer.v1.Classification)
pub enum Classification {
    // @@protoc_insertion_point(enum_value:modsurfer.v1.Classification.UNKNOWN)
    UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.Classification.ABI_COMPATIBILITY)
    ABI_COMPATIBILITY = 1,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.Classification.RESOURCE_LIMIT)
    RESOURCE_LIMIT = 2,
    // @@protoc_insertion_point(enum_value:modsurfer.v1.Classification.SECURITY)
    SECURITY = 3,
}

impl ::protobuf::Enum for Classification {
    const NAME: &'static str = "Classification";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Classification> {
        match value {
            0 => ::std::option::Option::Some(Classification::UNKNOWN),
            1 => ::std::option::Option::Some(Classification::ABI_COMPATIBILITY),
            2 => ::std::option::Option::Some(Classification::RESOURCE_LIMIT),
            3 => ::std::option::Option::Some(Classification::SECURITY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Classification] = &[
        Classification::UNKNOWN,
        Classification::ABI_COMPATIBILITY,
        Classification::RESOURCE_LIMIT,
        Classification::SECURITY,
    ];
}

impl ::protobuf::EnumFull for Classification {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Classification").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Classification {
    fn default() -> Self {
        Classification::UNKNOWN
    }
}

impl Classification {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Classification>("Classification")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12proto/v1/api.proto\x12\x0cmodsurfer.v1\x1a\x1fgoogle/protobuf/time\
    stamp.proto\"z\n\x08Function\x12)\n\x04args\x18\x01\x20\x03(\x0e2\x15.mo\
    dsurfer.v1.ValTypeR\x04args\x12/\n\x07returns\x18\x02\x20\x03(\x0e2\x15.\
    modsurfer.v1.ValTypeR\x07returns\x12\x12\n\x04name\x18\x03\x20\x01(\tR\
    \x04name\"U\n\x06Import\x12\x1f\n\x0bmodule_name\x18\x01\x20\x01(\tR\nmo\
    duleName\x12*\n\x04func\x18\x02\x20\x01(\x0b2\x16.modsurfer.v1.FunctionR\
    \x04func\"4\n\x06Export\x12*\n\x04func\x18\x01\x20\x01(\x0b2\x16.modsurf\
    er.v1.FunctionR\x04func\"\xb0\x04\n\x06Module\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\x03R\x02id\x12\x12\n\x04hash\x18\x03\x20\x01(\tR\x04hash\x12.\
    \n\x07imports\x18\x04\x20\x03(\x0b2\x14.modsurfer.v1.ImportR\x07imports\
    \x12.\n\x07exports\x18\x05\x20\x03(\x0b2\x14.modsurfer.v1.ExportR\x07exp\
    orts\x12\x12\n\x04size\x18\x06\x20\x01(\x04R\x04size\x12\x1a\n\x08locati\
    on\x18\x07\x20\x01(\tR\x08location\x12E\n\x0fsource_language\x18\x08\x20\
    \x01(\x0e2\x1c.modsurfer.v1.SourceLanguageR\x0esourceLanguage\x12>\n\x08\
    metadata\x18\t\x20\x03(\x0b2\".modsurfer.v1.Module.MetadataEntryR\x08met\
    adata\x12;\n\x0binserted_at\x18\n\x20\x01(\x0b2\x1a.google.protobuf.Time\
    stampR\ninsertedAt\x12\x18\n\x07strings\x18\x0b\x20\x03(\tR\x07strings\
    \x12#\n\ncomplexity\x18\r\x20\x01(\rH\0R\ncomplexity\x88\x01\x01\x12\x19\
    \n\x05graph\x18\x0e\x20\x01(\tH\x01R\x05graph\x88\x01\x01\x1a;\n\rMetada\
    taEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01B\r\n\x0b_complexityB\x08\n\x06_g\
    raph\"5\n\x05Error\x12\x12\n\x04code\x18\x01\x20\x01(\x05R\x04code\x12\
    \x18\n\x07message\x18\x02\x20\x01(\tR\x07message\":\n\nPagination\x12\
    \x14\n\x05limit\x18\x01\x20\x01(\rR\x05limit\x12\x16\n\x06offset\x18\x02\
    \x20\x01(\rR\x06offset\"h\n\x04Sort\x125\n\tdirection\x18\x01\x20\x01(\
    \x0e2\x17.modsurfer.v1.DirectionR\tdirection\x12)\n\x05field\x18\x02\x20\
    \x01(\x0e2\x13.modsurfer.v1.FieldR\x05field\"\xe1\x01\n\x13CreateModuleR\
    equest\x12\x12\n\x04wasm\x18\x01\x20\x01(\x0cR\x04wasm\x12K\n\x08metadat\
    a\x18\x02\x20\x03(\x0b2/.modsurfer.v1.CreateModuleRequest.MetadataEntryR\
    \x08metadata\x12\x1f\n\x08location\x18\x03\x20\x01(\tH\0R\x08location\
    \x88\x01\x01\x1a;\n\rMetadataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x0b\n\
    \t_location\"\x81\x01\n\x14CreateModuleResponse\x12\x1b\n\tmodule_id\x18\
    \x01\x20\x01(\x03R\x08moduleId\x12\x12\n\x04hash\x18\x02\x20\x01(\tR\x04\
    hash\x12.\n\x05error\x18\x03\x20\x01(\x0b2\x13.modsurfer.v1.ErrorH\0R\
    \x05error\x88\x01\x01B\x08\n\x06_error\"/\n\x10GetModuleRequest\x12\x1b\
    \n\tmodule_id\x18\x01\x20\x01(\x03R\x08moduleId\"{\n\x11GetModuleRespons\
    e\x12,\n\x06module\x18\x01\x20\x01(\x0b2\x14.modsurfer.v1.ModuleR\x06mod\
    ule\x12.\n\x05error\x18\x02\x20\x01(\x0b2\x13.modsurfer.v1.ErrorH\0R\x05\
    error\x88\x01\x01B\x08\n\x06_error\"v\n\x12ListModulesRequest\x128\n\npa\
    gination\x18\x01\x20\x01(\x0b2\x18.modsurfer.v1.PaginationR\npagination\
    \x12&\n\x04sort\x18\x02\x20\x01(\x0b2\x12.modsurfer.v1.SortR\x04sort\"\
    \xf7\x01\n\x13ListModulesResponse\x12.\n\x07modules\x18\x01\x20\x03(\x0b\
    2\x14.modsurfer.v1.ModuleR\x07modules\x128\n\npagination\x18\x02\x20\x01\
    (\x0b2\x18.modsurfer.v1.PaginationR\npagination\x12\x14\n\x05total\x18\
    \x03\x20\x01(\x04R\x05total\x12&\n\x04sort\x18\x04\x20\x01(\x0b2\x12.mod\
    surfer.v1.SortR\x04sort\x12.\n\x05error\x18\x05\x20\x01(\x0b2\x13.modsur\
    fer.v1.ErrorH\0R\x05error\x88\x01\x01B\x08\n\x06_error\"\xce\x07\n\x14Se\
    archModulesRequest\x12\x13\n\x02id\x18\x01\x20\x01(\x03H\0R\x02id\x88\
    \x01\x01\x12\x17\n\x04hash\x18\x03\x20\x01(\tH\x01R\x04hash\x88\x01\x01\
    \x12.\n\x07imports\x18\x04\x20\x03(\x0b2\x14.modsurfer.v1.ImportR\x07imp\
    orts\x12.\n\x07exports\x18\x05\x20\x03(\x0b2\x14.modsurfer.v1.ExportR\
    \x07exports\x12\x1e\n\x08min_size\x18\x06\x20\x01(\x04H\x02R\x07minSize\
    \x88\x01\x01\x12\x1e\n\x08max_size\x18\x07\x20\x01(\x04H\x03R\x07maxSize\
    \x88\x01\x01\x12\x1f\n\x08location\x18\x08\x20\x01(\tH\x04R\x08location\
    \x88\x01\x01\x12J\n\x0fsource_language\x18\t\x20\x01(\x0e2\x1c.modsurfer\
    .v1.SourceLanguageH\x05R\x0esourceLanguage\x88\x01\x01\x12L\n\x08metadat\
    a\x18\n\x20\x03(\x0b20.modsurfer.v1.SearchModulesRequest.MetadataEntryR\
    \x08metadata\x12H\n\x0finserted_before\x18\x0b\x20\x01(\x0b2\x1a.google.\
    protobuf.TimestampH\x06R\x0einsertedBefore\x88\x01\x01\x12F\n\x0einserte\
    d_after\x18\x0c\x20\x01(\x0b2\x1a.google.protobuf.TimestampH\x07R\rinser\
    tedAfter\x88\x01\x01\x12\x18\n\x07strings\x18\r\x20\x03(\tR\x07strings\
    \x12(\n\rfunction_name\x18\x0e\x20\x01(\tH\x08R\x0cfunctionName\x88\x01\
    \x01\x12$\n\x0bmodule_name\x18\x0f\x20\x01(\tH\tR\nmoduleName\x88\x01\
    \x01\x128\n\npagination\x18\x10\x20\x01(\x0b2\x18.modsurfer.v1.Paginatio\
    nR\npagination\x12&\n\x04sort\x18\x11\x20\x01(\x0b2\x12.modsurfer.v1.Sor\
    tR\x04sort\x1a;\n\rMetadataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x05\n\
    \x03_idB\x07\n\x05_hashB\x0b\n\t_min_sizeB\x0b\n\t_max_sizeB\x0b\n\t_loc\
    ationB\x12\n\x10_source_languageB\x12\n\x10_inserted_beforeB\x11\n\x0f_i\
    nserted_afterB\x10\n\x0e_function_nameB\x0e\n\x0c_module_name\"\xf9\x01\
    \n\x15SearchModulesResponse\x12.\n\x07modules\x18\x01\x20\x03(\x0b2\x14.\
    modsurfer.v1.ModuleR\x07modules\x128\n\npagination\x18\x02\x20\x01(\x0b2\
    \x18.modsurfer.v1.PaginationR\npagination\x12\x14\n\x05total\x18\x03\x20\
    \x01(\x04R\x05total\x12&\n\x04sort\x18\x04\x20\x01(\x0b2\x12.modsurfer.v\
    1.SortR\x04sort\x12.\n\x05error\x18\x05\x20\x01(\x0b2\x13.modsurfer.v1.E\
    rrorH\0R\x05error\x88\x01\x01B\x08\n\x06_error\"5\n\x14DeleteModulesRequ\
    est\x12\x1d\n\nmodule_ids\x18\x01\x20\x03(\x03R\tmoduleIds\"\xef\x01\n\
    \x15DeleteModulesResponse\x12[\n\x0emodule_id_hash\x18\x01\x20\x03(\x0b2\
    5.modsurfer.v1.DeleteModulesResponse.ModuleIdHashEntryR\x0cmoduleIdHash\
    \x12.\n\x05error\x18\x02\x20\x01(\x0b2\x13.modsurfer.v1.ErrorH\0R\x05err\
    or\x88\x01\x01\x1a?\n\x11ModuleIdHashEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\x03R\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01B\x08\n\x06_error\"\xa3\x01\n\x13AuditModulesRequest\x12\x1c\n\tchec\
    kfile\x18\x01\x20\x01(\x0cR\tcheckfile\x124\n\x07outcome\x18\x02\x20\x01\
    (\x0e2\x1a.modsurfer.v1.AuditOutcomeR\x07outcome\x128\n\npagination\x18\
    \x03\x20\x01(\x0b2\x18.modsurfer.v1.PaginationR\npagination\"\xd9\x02\n\
    \x14AuditModulesResponse\x12o\n\x15invalid_module_report\x18\x01\x20\x03\
    (\x0b2;.modsurfer.v1.AuditModulesResponse.InvalidModuleReportEntryR\x13i\
    nvalidModuleReport\x128\n\npagination\x18\x02\x20\x01(\x0b2\x18.modsurfe\
    r.v1.PaginationR\npagination\x12\x14\n\x05total\x18\x03\x20\x01(\x04R\
    \x05total\x12.\n\x05error\x18\x04\x20\x01(\x0b2\x13.modsurfer.v1.ErrorH\
    \0R\x05error\x88\x01\x01\x1aF\n\x18InvalidModuleReportEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\x03R\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x0cR\x05value:\x028\x01B\x08\n\x06_error\"\xa5\x01\n\rFailureDetail\x12\
    \x16\n\x06actual\x18\x01\x20\x01(\tR\x06actual\x12\x1a\n\x08expected\x18\
    \x02\x20\x01(\tR\x08expected\x12\x1a\n\x08severity\x18\x03\x20\x01(\rR\
    \x08severity\x12D\n\x0eclassification\x18\x04\x20\x01(\x0e2\x1c.modsurfe\
    r.v1.ClassificationR\x0eclassification\"\x96\x01\n\x06Report\x125\n\x05f\
    ails\x18\x01\x20\x03(\x0b2\x1f.modsurfer.v1.Report.FailsEntryR\x05fails\
    \x1aU\n\nFailsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x121\n\
    \x05value\x18\x02\x20\x01(\x0b2\x1b.modsurfer.v1.FailureDetailR\x05value\
    :\x028\x01\"}\n\x0bPluginInput\x12,\n\x06report\x18\x01\x20\x01(\x0b2\
    \x14.modsurfer.v1.ReportR\x06report\x12,\n\x06module\x18\x02\x20\x01(\
    \x0b2\x14.modsurfer.v1.ModuleR\x06module\x12\x12\n\x04wasm\x18\x03\x20\
    \x01(\x0cR\x04wasm\"G\n\x0cPluginOutput\x127\n\x08failures\x18\x01\x20\
    \x03(\x0b2\x1b.modsurfer.v1.FailureDetailR\x08failures*S\n\x07ValType\
    \x12\x07\n\x03I32\x10\0\x12\x07\n\x03I64\x10\x01\x12\x07\n\x03F32\x10\
    \x02\x12\x07\n\x03F64\x10\x03\x12\x08\n\x04V128\x10\x04\x12\x0b\n\x07Fun\
    cRef\x10\x05\x12\r\n\tExternRef\x10\x06*S\n\x0eSourceLanguage\x12\x0b\n\
    \x07Unknown\x10\0\x12\x08\n\x04Rust\x10\x01\x12\x06\n\x02Go\x10\x02\x12\
    \x05\n\x01C\x10\x03\x12\x07\n\x03Cpp\x10\x04\x12\x12\n\x0eAssemblyScript\
    \x10\x05*\x1e\n\tDirection\x12\x08\n\x04Desc\x10\0\x12\x07\n\x03Asc\x10\
    \x01*x\n\x05Field\x12\r\n\tCreatedAt\x10\0\x12\x08\n\x04Name\x10\x01\x12\
    \x08\n\x04Size\x10\x02\x12\x0c\n\x08Language\x10\x03\x12\x10\n\x0cImport\
    sCount\x10\x04\x12\x10\n\x0cExportsCount\x10\x05\x12\n\n\x06Sha256\x10\
    \x06\x12\x0e\n\nComplexity\x10\x07*\"\n\x0cAuditOutcome\x12\x08\n\x04PAS\
    S\x10\0\x12\x08\n\x04FAIL\x10\x01*V\n\x0eClassification\x12\x0b\n\x07UNK\
    NOWN\x10\0\x12\x15\n\x11ABI_COMPATIBILITY\x10\x01\x12\x12\n\x0eRESOURCE_\
    LIMIT\x10\x02\x12\x0c\n\x08SECURITY\x10\x03J\xf2^\n\x07\x12\x05\0\0\x9f\
    \x02\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\
    \x15\n\t\n\x02\x03\0\x12\x03\x03\0)\nr\n\x02\x05\0\x12\x04\x07\0\x0f\x01\
    \x1af\x20Used\x20to\x20type\x20the\x20arguments\x20and\x20return\x20type\
    s\x20from\x20wasm\x20elements\x20such\x20as\x20import\n\x20and\x20export\
    \x20functions.\n\n\n\n\x03\x05\0\x01\x12\x03\x07\x05\x0c\n\x0b\n\x04\x05\
    \0\x02\0\x12\x03\x08\x02\n\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x08\x02\
    \x05\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x08\x08\t\n\x0b\n\x04\x05\0\x02\
    \x01\x12\x03\t\x02\n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\t\x02\x05\n\
    \x0c\n\x05\x05\0\x02\x01\x02\x12\x03\t\x08\t\n\x0b\n\x04\x05\0\x02\x02\
    \x12\x03\n\x02\n\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\n\x02\x05\n\x0c\n\
    \x05\x05\0\x02\x02\x02\x12\x03\n\x08\t\n\x0b\n\x04\x05\0\x02\x03\x12\x03\
    \x0b\x02\n\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\x0b\x02\x05\n\x0c\n\x05\
    \x05\0\x02\x03\x02\x12\x03\x0b\x08\t\n\x0b\n\x04\x05\0\x02\x04\x12\x03\
    \x0c\x02\x0b\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x0c\x02\x06\n\x0c\n\
    \x05\x05\0\x02\x04\x02\x12\x03\x0c\t\n\n\x0b\n\x04\x05\0\x02\x05\x12\x03\
    \r\x02\x0e\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\r\x02\t\n\x0c\n\x05\x05\
    \0\x02\x05\x02\x12\x03\r\x0c\r\n\x0b\n\x04\x05\0\x02\x06\x12\x03\x0e\x02\
    \x10\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\x0e\x02\x0b\n\x0c\n\x05\x05\0\
    \x02\x06\x02\x12\x03\x0e\x0e\x0f\nL\n\x02\x04\0\x12\x04\x12\0\x16\x01\
    \x1a@\x20Contained\x20by\x20an\x20import\x20or\x20export\x20element\x20w\
    ithin\x20a\x20wasm\x20binary.\n\n\n\n\x03\x04\0\x01\x12\x03\x12\x08\x10\
    \n\x0b\n\x04\x04\0\x02\0\x12\x03\x13\x02\x1c\n\x0c\n\x05\x04\0\x02\0\x04\
    \x12\x03\x13\x02\n\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x13\x0b\x12\n\x0c\
    \n\x05\x04\0\x02\0\x01\x12\x03\x13\x13\x17\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x03\x13\x1a\x1b\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x14\x02\x1f\n\x0c\
    \n\x05\x04\0\x02\x01\x04\x12\x03\x14\x02\n\n\x0c\n\x05\x04\0\x02\x01\x06\
    \x12\x03\x14\x0b\x12\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x14\x13\x1a\n\
    \x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x14\x1d\x1e\n\x0b\n\x04\x04\0\x02\
    \x02\x12\x03\x15\x02\x12\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x15\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x15\t\r\n\x0c\n\x05\x04\0\x02\
    \x02\x03\x12\x03\x15\x10\x11\n\x8d\x01\n\x02\x04\x01\x12\x04\x1a\0\x1d\
    \x01\x1a\x80\x01\x20A\x20function\x20and\x20module\x20namespace\x20that\
    \x20is\x20defined\x20outside\x20of\x20the\x20current\n\x20module,\x20and\
    \x20referenced\x20&\x20called\x20by\x20the\x20current\x20module.\n\n\n\n\
    \x03\x04\x01\x01\x12\x03\x1a\x08\x0e\n\x0b\n\x04\x04\x01\x02\0\x12\x03\
    \x1b\x02\x19\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x1b\x02\x08\n\x0c\n\
    \x05\x04\x01\x02\0\x01\x12\x03\x1b\t\x14\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03\x1b\x17\x18\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x1c\x02\x14\n\
    \x0c\n\x05\x04\x01\x02\x01\x06\x12\x03\x1c\x02\n\n\x0c\n\x05\x04\x01\x02\
    \x01\x01\x12\x03\x1c\x0b\x0f\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x1c\
    \x12\x13\nu\n\x02\x04\x02\x12\x03!\0%\x1aj\x20A\x20function\x20that\x20i\
    s\x20defined\x20inside\x20the\x20current\x20module,\x20made\x20available\
    \x20to\n\x20outside\x20modules\x20/\x20environments.\n\n\n\n\x03\x04\x02\
    \x01\x12\x03!\x08\x0e\n\x0b\n\x04\x04\x02\x02\0\x12\x03!\x11#\n\x0c\n\
    \x05\x04\x02\x02\0\x06\x12\x03!\x11\x19\n\x0c\n\x05\x04\x02\x02\0\x01\
    \x12\x03!\x1a\x1e\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03!!\"\nQ\n\x02\x05\
    \x01\x12\x04$\0+\x01\x1aE\x20The\x20language\x20(or\x20most\x20similar\
    \x20match)\x20used\x20to\x20produce\x20a\x20wasm\x20module.\n\n\n\n\x03\
    \x05\x01\x01\x12\x03$\x05\x13\n\x0b\n\x04\x05\x01\x02\0\x12\x03%\x02\x0e\
    \n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03%\x02\t\n\x0c\n\x05\x05\x01\x02\0\
    \x02\x12\x03%\x0c\r\n\x0b\n\x04\x05\x01\x02\x01\x12\x03&\x02\x0b\n\x0c\n\
    \x05\x05\x01\x02\x01\x01\x12\x03&\x02\x06\n\x0c\n\x05\x05\x01\x02\x01\
    \x02\x12\x03&\t\n\n\x0b\n\x04\x05\x01\x02\x02\x12\x03'\x02\t\n\x0c\n\x05\
    \x05\x01\x02\x02\x01\x12\x03'\x02\x04\n\x0c\n\x05\x05\x01\x02\x02\x02\
    \x12\x03'\x07\x08\n\x0b\n\x04\x05\x01\x02\x03\x12\x03(\x02\x08\n\x0c\n\
    \x05\x05\x01\x02\x03\x01\x12\x03(\x02\x03\n\x0c\n\x05\x05\x01\x02\x03\
    \x02\x12\x03(\x06\x07\n\x0b\n\x04\x05\x01\x02\x04\x12\x03)\x02\n\n\x0c\n\
    \x05\x05\x01\x02\x04\x01\x12\x03)\x02\x05\n\x0c\n\x05\x05\x01\x02\x04\
    \x02\x12\x03)\x08\t\n\x0b\n\x04\x05\x01\x02\x05\x12\x03*\x02\x15\n\x0c\n\
    \x05\x05\x01\x02\x05\x01\x12\x03*\x02\x10\n\x0c\n\x05\x05\x01\x02\x05\
    \x02\x12\x03*\x13\x14\nk\n\x02\x04\x03\x12\x04/\0K\x01\x1a_\x20Details\
    \x20about\x20a\x20wasm\x20module,\x20either\x20extracted\x20directly\x20\
    from\x20the\x20binary,\x20or\n\x20inferred\x20somehow.\n\n\n\n\x03\x04\
    \x03\x01\x12\x03/\x08\x0e\n=\n\x04\x04\x03\x02\0\x12\x031\x02\x0f\x1a0\
    \x20ID\x20for\x20this\x20module,\x20generated\x20by\x20the\x20database.\
    \n\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x031\x02\x07\n\x0c\n\x05\x04\x03\
    \x02\0\x01\x12\x031\x08\n\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x031\r\x0e\n\
    3\n\x04\x04\x03\x02\x01\x12\x033\x02\x12\x1a&\x20sha256\x20hash\x20of\
    \x20the\x20modules\x20raw\x20bytes\n\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\
    \x033\x02\x08\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x033\t\r\n\x0c\n\x05\
    \x04\x03\x02\x01\x03\x12\x033\x10\x11\n\x81\x01\n\x04\x04\x03\x02\x02\
    \x12\x036\x02\x1e\x1at\x20function\x20imports\x20called\x20by\x20the\x20\
    module\x20(see:\n\x20<https://github.com/WebAssembly/design/blob/main/Mo\
    dules.md#imports)>\n\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x036\x02\n\n\
    \x0c\n\x05\x04\x03\x02\x02\x06\x12\x036\x0b\x11\n\x0c\n\x05\x04\x03\x02\
    \x02\x01\x12\x036\x12\x19\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x036\x1c\
    \x1d\n\x83\x01\n\x04\x04\x03\x02\x03\x12\x039\x02\x1e\x1av\x20function\
    \x20exports\x20provided\x20by\x20the\x20module\x20(see:\n\x20<https://gi\
    thub.com/WebAssembly/design/blob/main/Modules.md#exports)>\n\n\x0c\n\x05\
    \x04\x03\x02\x03\x04\x12\x039\x02\n\n\x0c\n\x05\x04\x03\x02\x03\x06\x12\
    \x039\x0b\x11\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x039\x12\x19\n\x0c\n\
    \x05\x04\x03\x02\x03\x03\x12\x039\x1c\x1d\n*\n\x04\x04\x03\x02\x04\x12\
    \x03;\x02\x12\x1a\x1d\x20size\x20in\x20bytes\x20of\x20the\x20module\n\n\
    \x0c\n\x05\x04\x03\x02\x04\x05\x12\x03;\x02\x08\n\x0c\n\x05\x04\x03\x02\
    \x04\x01\x12\x03;\t\r\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03;\x10\x11\n\
    ,\n\x04\x04\x03\x02\x05\x12\x03=\x02\x16\x1a\x1f\x20path\x20or\x20locato\
    r\x20to\x20the\x20module\n\n\x0c\n\x05\x04\x03\x02\x05\x05\x12\x03=\x02\
    \x08\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x03=\t\x11\n\x0c\n\x05\x04\x03\
    \x02\x05\x03\x12\x03=\x14\x15\n?\n\x04\x04\x03\x02\x06\x12\x03?\x02%\x1a\
    2\x20programming\x20language\x20used\x20to\x20produce\x20this\x20module\
    \n\n\x0c\n\x05\x04\x03\x02\x06\x06\x12\x03?\x02\x10\n\x0c\n\x05\x04\x03\
    \x02\x06\x01\x12\x03?\x11\x20\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x03?#$\
    \nI\n\x04\x04\x03\x02\x07\x12\x03A\x02#\x1a<\x20arbitrary\x20metadata\
    \x20provided\x20by\x20the\x20operator\x20of\x20this\x20module\n\n\x0c\n\
    \x05\x04\x03\x02\x07\x06\x12\x03A\x02\x15\n\x0c\n\x05\x04\x03\x02\x07\
    \x01\x12\x03A\x16\x1e\n\x0c\n\x05\x04\x03\x02\x07\x03\x12\x03A!\"\n?\n\
    \x04\x04\x03\x02\x08\x12\x03C\x02-\x1a2\x20timestamp\x20when\x20this\x20\
    module\x20was\x20loaded\x20and\x20stored\n\n\x0c\n\x05\x04\x03\x02\x08\
    \x06\x12\x03C\x02\x1b\n\x0c\n\x05\x04\x03\x02\x08\x01\x12\x03C\x1c'\n\
    \x0c\n\x05\x04\x03\x02\x08\x03\x12\x03C*,\nZ\n\x04\x04\x03\x02\t\x12\x03\
    E\x02\x1f\x1aM\x20the\x20interned\x20strings\x20stored\x20in\x20the\x20w\
    asm\x20binary\x20(panic/abort\x20messages,\x20etc.)\n\n\x0c\n\x05\x04\
    \x03\x02\t\x04\x12\x03E\x02\n\n\x0c\n\x05\x04\x03\x02\t\x05\x12\x03E\x0b\
    \x11\n\x0c\n\x05\x04\x03\x02\t\x01\x12\x03E\x12\x19\n\x0c\n\x05\x04\x03\
    \x02\t\x03\x12\x03E\x1c\x1e\nu\n\x04\x04\x03\x02\n\x12\x03H\x02\"\x1ah\
    \x20the\x20cyclomatic\x20complexity\n\x20(<https://en.wikipedia.org/wiki\
    /Cyclomatic_complexity>)\x20of\x20the\x20instructions\n\n\x0c\n\x05\x04\
    \x03\x02\n\x04\x12\x03H\x02\n\n\x0c\n\x05\x04\x03\x02\n\x05\x12\x03H\x0b\
    \x11\n\x0c\n\x05\x04\x03\x02\n\x01\x12\x03H\x12\x1c\n\x0c\n\x05\x04\x03\
    \x02\n\x03\x12\x03H\x1f!\n%\n\x04\x04\x03\x02\x0b\x12\x03J\x02\x1d\x1a\
    \x18\x20the\x20grah\x20in\x20Dot\x20format\n\n\x0c\n\x05\x04\x03\x02\x0b\
    \x04\x12\x03J\x02\n\n\x0c\n\x05\x04\x03\x02\x0b\x05\x12\x03J\x0b\x11\n\
    \x0c\n\x05\x04\x03\x02\x0b\x01\x12\x03J\x12\x17\n\x0c\n\x05\x04\x03\x02\
    \x0b\x03\x12\x03J\x1a\x1c\n?\n\x02\x04\x04\x12\x04N\0Q\x01\x1a3\x20An\
    \x20error\x20message\x20indicating\x20a\x20problem\x20in\x20the\x20API.\
    \n\n\n\n\x03\x04\x04\x01\x12\x03N\x08\r\n\x0b\n\x04\x04\x04\x02\0\x12\
    \x03O\x02\x11\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03O\x02\x07\n\x0c\n\x05\
    \x04\x04\x02\0\x01\x12\x03O\x08\x0c\n\x0c\n\x05\x04\x04\x02\0\x03\x12\
    \x03O\x0f\x10\n\x0b\n\x04\x04\x04\x02\x01\x12\x03P\x02\x15\n\x0c\n\x05\
    \x04\x04\x02\x01\x05\x12\x03P\x02\x08\n\x0c\n\x05\x04\x04\x02\x01\x01\
    \x12\x03P\t\x10\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03P\x13\x14\n]\n\
    \x02\x04\x05\x12\x04U\0X\x01\x1aQ\x20Control/limit\x20the\x20way\x20resu\
    lts\x20are\x20paginated\x20when\x20working\x20with\x20large\n\x20respons\
    es.\n\n\n\n\x03\x04\x05\x01\x12\x03U\x08\x12\n\x0b\n\x04\x04\x05\x02\0\
    \x12\x03V\x02\x13\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03V\x02\x08\n\x0c\n\
    \x05\x04\x05\x02\0\x01\x12\x03V\t\x0e\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x03V\x11\x12\n\x0b\n\x04\x04\x05\x02\x01\x12\x03W\x02\x14\n\x0c\n\x05\
    \x04\x05\x02\x01\x05\x12\x03W\x02\x08\n\x0c\n\x05\x04\x05\x02\x01\x01\
    \x12\x03W\t\x0f\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03W\x12\x13\n8\n\
    \x02\x04\x06\x12\x04[\0^\x01\x1a,\x20Determine\x20how\x20to\x20sort\x20r\
    esults\x20from\x20the\x20API\n\n\n\n\x03\x04\x06\x01\x12\x03[\x08\x0c\n\
    \x0b\n\x04\x04\x06\x02\0\x12\x03\\\x02\x1a\n\x0c\n\x05\x04\x06\x02\0\x06\
    \x12\x03\\\x02\x0b\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03\\\x0c\x15\n\x0c\
    \n\x05\x04\x06\x02\0\x03\x12\x03\\\x18\x19\n\x0b\n\x04\x04\x06\x02\x01\
    \x12\x03]\x02\x12\n\x0c\n\x05\x04\x06\x02\x01\x06\x12\x03]\x02\x07\n\x0c\
    \n\x05\x04\x06\x02\x01\x01\x12\x03]\x08\r\n\x0c\n\x05\x04\x06\x02\x01\
    \x03\x12\x03]\x10\x11\nL\n\x02\x05\x02\x12\x04a\0d\x01\x1a@\x20The\x20di\
    rection,\x20descending\x20or\x20ascending,\x20of\x20the\x20sort\x20opera\
    tion.\n\n\n\n\x03\x05\x02\x01\x12\x03a\x05\x0e\n\x0b\n\x04\x05\x02\x02\0\
    \x12\x03b\x02\x0b\n\x0c\n\x05\x05\x02\x02\0\x01\x12\x03b\x02\x06\n\x0c\n\
    \x05\x05\x02\x02\0\x02\x12\x03b\t\n\n\x0b\n\x04\x05\x02\x02\x01\x12\x03c\
    \x02\n\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x03c\x02\x05\n\x0c\n\x05\x05\
    \x02\x02\x01\x02\x12\x03c\x08\t\nW\n\x02\x05\x03\x12\x04g\0p\x01\x1aK\
    \x20The\x20field\x20within\x20the\x20Module\x20schema\x20that\x20is\x20u\
    sed\x20as\x20the\x20sorting\x20dimension.\n\n\n\n\x03\x05\x03\x01\x12\
    \x03g\x05\n\n\x0b\n\x04\x05\x03\x02\0\x12\x03h\x02\x10\n\x0c\n\x05\x05\
    \x03\x02\0\x01\x12\x03h\x02\x0b\n\x0c\n\x05\x05\x03\x02\0\x02\x12\x03h\
    \x0e\x0f\n\x0b\n\x04\x05\x03\x02\x01\x12\x03i\x02\x0b\n\x0c\n\x05\x05\
    \x03\x02\x01\x01\x12\x03i\x02\x06\n\x0c\n\x05\x05\x03\x02\x01\x02\x12\
    \x03i\t\n\n\x0b\n\x04\x05\x03\x02\x02\x12\x03j\x02\x0b\n\x0c\n\x05\x05\
    \x03\x02\x02\x01\x12\x03j\x02\x06\n\x0c\n\x05\x05\x03\x02\x02\x02\x12\
    \x03j\t\n\n\x0b\n\x04\x05\x03\x02\x03\x12\x03k\x02\x0f\n\x0c\n\x05\x05\
    \x03\x02\x03\x01\x12\x03k\x02\n\n\x0c\n\x05\x05\x03\x02\x03\x02\x12\x03k\
    \r\x0e\n\x0b\n\x04\x05\x03\x02\x04\x12\x03l\x02\x13\n\x0c\n\x05\x05\x03\
    \x02\x04\x01\x12\x03l\x02\x0e\n\x0c\n\x05\x05\x03\x02\x04\x02\x12\x03l\
    \x11\x12\n\x0b\n\x04\x05\x03\x02\x05\x12\x03m\x02\x13\n\x0c\n\x05\x05\
    \x03\x02\x05\x01\x12\x03m\x02\x0e\n\x0c\n\x05\x05\x03\x02\x05\x02\x12\
    \x03m\x11\x12\n\x0b\n\x04\x05\x03\x02\x06\x12\x03n\x02\r\n\x0c\n\x05\x05\
    \x03\x02\x06\x01\x12\x03n\x02\x08\n\x0c\n\x05\x05\x03\x02\x06\x02\x12\
    \x03n\x0b\x0c\n\x0b\n\x04\x05\x03\x02\x07\x12\x03o\x02\x11\n\x0c\n\x05\
    \x05\x03\x02\x07\x01\x12\x03o\x02\x0c\n\x0c\n\x05\x05\x03\x02\x07\x02\
    \x12\x03o\x0f\x10\nl\n\x02\x04\x07\x12\x04t\0y\x01\x1a`\x20`PUT\x20/api/\
    v1/module:`\n\x20Insert\x20a\x20module,\x20extract\x20data\x20from\x20bi\
    nary.\x20Return\x20the\x20module\x20ID\x20&\x20hash.\n\n\n\n\x03\x04\x07\
    \x01\x12\x03t\x08\x1b\n\x0b\n\x04\x04\x07\x02\0\x12\x03u\x02\x11\n\x0c\n\
    \x05\x04\x07\x02\0\x05\x12\x03u\x02\x07\n\x0c\n\x05\x04\x07\x02\0\x01\
    \x12\x03u\x08\x0c\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03u\x0f\x10\n\x0b\n\
    \x04\x04\x07\x02\x01\x12\x03v\x02#\n\x0c\n\x05\x04\x07\x02\x01\x06\x12\
    \x03v\x02\x15\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03v\x16\x1e\n\x0c\n\
    \x05\x04\x07\x02\x01\x03\x12\x03v!\"\nS\n\x04\x04\x07\x02\x02\x12\x03x\
    \x02\x1f\x1aF\x20a\x20valid\x20URL\x20with\x20a\x20scheme\x20prefix\x20e\
    .g.\x20`s3://`,\x20`file://`,\x20`https://`\n\n\x0c\n\x05\x04\x07\x02\
    \x02\x04\x12\x03x\x02\n\n\x0c\n\x05\x04\x07\x02\x02\x05\x12\x03x\x0b\x11\
    \n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x03x\x12\x1a\n\x0c\n\x05\x04\x07\
    \x02\x02\x03\x12\x03x\x1d\x1e\nK\n\x02\x04\x08\x12\x05|\0\x80\x01\x01\
    \x1a>\x20The\x20message\x20returned\x20in\x20response\x20to\x20a\x20`Cre\
    ateModuleRequest`.\n\n\n\n\x03\x04\x08\x01\x12\x03|\x08\x1c\n\x0b\n\x04\
    \x04\x08\x02\0\x12\x03}\x02\x16\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03}\
    \x02\x07\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03}\x08\x11\n\x0c\n\x05\x04\
    \x08\x02\0\x03\x12\x03}\x14\x15\n\x0b\n\x04\x04\x08\x02\x01\x12\x03~\x02\
    \x12\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03~\x02\x08\n\x0c\n\x05\x04\
    \x08\x02\x01\x01\x12\x03~\t\r\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03~\
    \x10\x11\n\x0b\n\x04\x04\x08\x02\x02\x12\x03\x7f\x02\x1b\n\x0c\n\x05\x04\
    \x08\x02\x02\x04\x12\x03\x7f\x02\n\n\x0c\n\x05\x04\x08\x02\x02\x06\x12\
    \x03\x7f\x0b\x10\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x03\x7f\x11\x16\n\
    \x0c\n\x05\x04\x08\x02\x02\x03\x12\x03\x7f\x19\x1a\n=\n\x02\x04\t\x12\
    \x04\x84\x01\01\x1a1\x20`POST\x20/api/v1/module:`\n\x20Return\x20a\x20si\
    ngle\x20module.\n\n\x0b\n\x03\x04\t\x01\x12\x04\x84\x01\x08\x18\n\x0c\n\
    \x04\x04\t\x02\0\x12\x04\x84\x01\x1b/\n\r\n\x05\x04\t\x02\0\x05\x12\x04\
    \x84\x01\x1b\x20\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x84\x01!*\n\r\n\x05\
    \x04\t\x02\0\x03\x12\x04\x84\x01-.\nI\n\x02\x04\n\x12\x06\x87\x01\0\x8a\
    \x01\x01\x1a;\x20The\x20message\x20returned\x20in\x20response\x20to\x20a\
    \x20`GetModuleRequest`.\n\n\x0b\n\x03\x04\n\x01\x12\x04\x87\x01\x08\x19\
    \n\x0c\n\x04\x04\n\x02\0\x12\x04\x88\x01\x02\x14\n\r\n\x05\x04\n\x02\0\
    \x06\x12\x04\x88\x01\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x88\x01\t\
    \x0f\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x88\x01\x12\x13\n\x0c\n\x04\x04\n\
    \x02\x01\x12\x04\x89\x01\x02\x1b\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\x89\
    \x01\x02\n\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\x89\x01\x0b\x10\n\r\n\x05\
    \x04\n\x02\x01\x01\x12\x04\x89\x01\x11\x16\n\r\n\x05\x04\n\x02\x01\x03\
    \x12\x04\x89\x01\x19\x1a\nN\n\x02\x04\x0b\x12\x06\x8e\x01\0\x91\x01\x01\
    \x1a@\x20`POST\x20/api/v1/modules:`\n\x20Return\x20paginated\x20list\x20\
    of\x20all\x20modules.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\x8e\x01\x08\x1a\
    \n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x8f\x01\x02\x1c\n\r\n\x05\x04\x0b\x02\
    \0\x06\x12\x04\x8f\x01\x02\x0c\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x8f\
    \x01\r\x17\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x8f\x01\x1a\x1b\n\x0c\n\
    \x04\x04\x0b\x02\x01\x12\x04\x90\x01\x02\x10\n\r\n\x05\x04\x0b\x02\x01\
    \x06\x12\x04\x90\x01\x02\x06\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x90\
    \x01\x07\x0b\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x90\x01\x0e\x0f\nK\n\
    \x02\x04\x0c\x12\x06\x94\x01\0\x9c\x01\x01\x1a=\x20The\x20message\x20ret\
    urned\x20in\x20response\x20to\x20a\x20`ListModulesRequest`.\n\n\x0b\n\
    \x03\x04\x0c\x01\x12\x04\x94\x01\x08\x1b\n\x0c\n\x04\x04\x0c\x02\0\x12\
    \x04\x95\x01\x02\x1e\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\x95\x01\x02\n\n\
    \r\n\x05\x04\x0c\x02\0\x06\x12\x04\x95\x01\x0b\x11\n\r\n\x05\x04\x0c\x02\
    \0\x01\x12\x04\x95\x01\x12\x19\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\x95\
    \x01\x1c\x1d\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\x96\x01\x02\x1c\n\r\n\
    \x05\x04\x0c\x02\x01\x06\x12\x04\x96\x01\x02\x0c\n\r\n\x05\x04\x0c\x02\
    \x01\x01\x12\x04\x96\x01\r\x17\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\x96\
    \x01\x1a\x1b\ng\n\x04\x04\x0c\x02\x02\x12\x04\x99\x01\x02\x13\x1aY\x20th\
    e\x20full\x20count\x20of\x20results\x20in\x20the\x20database\x20(not\x20\
    the\x20count\x20of\x20this\x20message's\n\x20`modules`).\n\n\r\n\x05\x04\
    \x0c\x02\x02\x05\x12\x04\x99\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x02\x01\
    \x12\x04\x99\x01\t\x0e\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\x99\x01\x11\
    \x12\n\x0c\n\x04\x04\x0c\x02\x03\x12\x04\x9a\x01\x02\x10\n\r\n\x05\x04\
    \x0c\x02\x03\x06\x12\x04\x9a\x01\x02\x06\n\r\n\x05\x04\x0c\x02\x03\x01\
    \x12\x04\x9a\x01\x07\x0b\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\x9a\x01\
    \x0e\x0f\n\x0c\n\x04\x04\x0c\x02\x04\x12\x04\x9b\x01\x02\x1b\n\r\n\x05\
    \x04\x0c\x02\x04\x04\x12\x04\x9b\x01\x02\n\n\r\n\x05\x04\x0c\x02\x04\x06\
    \x12\x04\x9b\x01\x0b\x10\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\x9b\x01\
    \x11\x16\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\x9b\x01\x19\x1a\n\xe8\x01\
    \n\x02\x04\r\x12\x06\xa2\x01\0\xc5\x01\x01\x1a\xd9\x01\x20`POST\x20/api/\
    v1/search:`\n\x20Search\x20for\x20modules\x20based\x20on\x20filter\x20pa\
    rams\x20provided\x20(which\x20should\x20be\x20any\n\x20dimension\x20of\
    \x20the\x20module\x20schema,\x20or\x20string\x20search\x20in\x20any\x20m\
    etadata\x20value).\n\x20Return\x20a\x20paginated\x20list\x20of\x20matchi\
    ng\x20modules.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xa2\x01\x08\x1c\n>\n\x04\
    \x04\r\x02\0\x12\x04\xa4\x01\x02\x18\x1a0\x20ID\x20for\x20this\x20module\
    ,\x20generated\x20by\x20the\x20database.\n\n\r\n\x05\x04\r\x02\0\x04\x12\
    \x04\xa4\x01\x02\n\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xa4\x01\x0b\x10\n\r\
    \n\x05\x04\r\x02\0\x01\x12\x04\xa4\x01\x11\x13\n\r\n\x05\x04\r\x02\0\x03\
    \x12\x04\xa4\x01\x16\x17\n7\n\x04\x04\r\x02\x01\x12\x04\xa6\x01\x02\x1b\
    \x1a)\x20original\x20name\x20of\x20the\x20binary\x20module\x20file\n\n\r\
    \n\x05\x04\r\x02\x01\x04\x12\x04\xa6\x01\x02\n\n\r\n\x05\x04\r\x02\x01\
    \x05\x12\x04\xa6\x01\x0b\x11\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xa6\x01\
    \x12\x16\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xa6\x01\x19\x1a\n\x82\x01\n\
    \x04\x04\r\x02\x02\x12\x04\xa9\x01\x02\x1e\x1at\x20function\x20imports\
    \x20called\x20by\x20the\x20module\x20(see:\n\x20<https://github.com/WebA\
    ssembly/design/blob/main/Modules.md#imports>)\n\n\r\n\x05\x04\r\x02\x02\
    \x04\x12\x04\xa9\x01\x02\n\n\r\n\x05\x04\r\x02\x02\x06\x12\x04\xa9\x01\
    \x0b\x11\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\xa9\x01\x12\x19\n\r\n\x05\
    \x04\r\x02\x02\x03\x12\x04\xa9\x01\x1c\x1d\n\x84\x01\n\x04\x04\r\x02\x03\
    \x12\x04\xac\x01\x02\x1e\x1av\x20function\x20exports\x20provided\x20by\
    \x20the\x20module\x20(see:\n\x20<https://github.com/WebAssembly/design/b\
    lob/main/Modules.md#exports>)\n\n\r\n\x05\x04\r\x02\x03\x04\x12\x04\xac\
    \x01\x02\n\n\r\n\x05\x04\r\x02\x03\x06\x12\x04\xac\x01\x0b\x11\n\r\n\x05\
    \x04\r\x02\x03\x01\x12\x04\xac\x01\x12\x19\n\r\n\x05\x04\r\x02\x03\x03\
    \x12\x04\xac\x01\x1c\x1d\n3\n\x04\x04\r\x02\x04\x12\x04\xae\x01\x02\x1f\
    \x1a%\x20minimum\x20size\x20in\x20bytes\x20of\x20the\x20module\n\n\r\n\
    \x05\x04\r\x02\x04\x04\x12\x04\xae\x01\x02\n\n\r\n\x05\x04\r\x02\x04\x05\
    \x12\x04\xae\x01\x0b\x11\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\xae\x01\x12\
    \x1a\n\r\n\x05\x04\r\x02\x04\x03\x12\x04\xae\x01\x1d\x1e\n3\n\x04\x04\r\
    \x02\x05\x12\x04\xb0\x01\x02\x1f\x1a%\x20maximum\x20size\x20in\x20bytes\
    \x20of\x20the\x20module\n\n\r\n\x05\x04\r\x02\x05\x04\x12\x04\xb0\x01\
    \x02\n\n\r\n\x05\x04\r\x02\x05\x05\x12\x04\xb0\x01\x0b\x11\n\r\n\x05\x04\
    \r\x02\x05\x01\x12\x04\xb0\x01\x12\x1a\n\r\n\x05\x04\r\x02\x05\x03\x12\
    \x04\xb0\x01\x1d\x1e\ng\n\x04\x04\r\x02\x06\x12\x04\xb3\x01\x02\x1f\x1aY\
    \x20optional\x20path\x20or\x20locator\x20to\x20the\x20module\x20(TODO:\
    \x20maybe\x20this\x20is\x20better\x20stored\n\x20as\x20metadata)\n\n\r\n\
    \x05\x04\r\x02\x06\x04\x12\x04\xb3\x01\x02\n\n\r\n\x05\x04\r\x02\x06\x05\
    \x12\x04\xb3\x01\x0b\x11\n\r\n\x05\x04\r\x02\x06\x01\x12\x04\xb3\x01\x12\
    \x1a\n\r\n\x05\x04\r\x02\x06\x03\x12\x04\xb3\x01\x1d\x1e\n@\n\x04\x04\r\
    \x02\x07\x12\x04\xb5\x01\x02.\x1a2\x20programming\x20language\x20used\
    \x20to\x20produce\x20this\x20module\n\n\r\n\x05\x04\r\x02\x07\x04\x12\
    \x04\xb5\x01\x02\n\n\r\n\x05\x04\r\x02\x07\x06\x12\x04\xb5\x01\x0b\x19\n\
    \r\n\x05\x04\r\x02\x07\x01\x12\x04\xb5\x01\x1a)\n\r\n\x05\x04\r\x02\x07\
    \x03\x12\x04\xb5\x01,-\nJ\n\x04\x04\r\x02\x08\x12\x04\xb7\x01\x02$\x1a<\
    \x20arbitrary\x20metadata\x20provided\x20by\x20the\x20operator\x20of\x20\
    this\x20module\n\n\r\n\x05\x04\r\x02\x08\x06\x12\x04\xb7\x01\x02\x15\n\r\
    \n\x05\x04\r\x02\x08\x01\x12\x04\xb7\x01\x16\x1e\n\r\n\x05\x04\r\x02\x08\
    \x03\x12\x04\xb7\x01!#\n@\n\x04\x04\r\x02\t\x12\x04\xb9\x01\x02:\x1a2\
    \x20timestamp\x20when\x20this\x20module\x20was\x20loaded\x20and\x20store\
    d\n\n\r\n\x05\x04\r\x02\t\x04\x12\x04\xb9\x01\x02\n\n\r\n\x05\x04\r\x02\
    \t\x06\x12\x04\xb9\x01\x0b$\n\r\n\x05\x04\r\x02\t\x01\x12\x04\xb9\x01%4\
    \n\r\n\x05\x04\r\x02\t\x03\x12\x04\xb9\x0179\n@\n\x04\x04\r\x02\n\x12\
    \x04\xbb\x01\x029\x1a2\x20timestamp\x20when\x20this\x20module\x20was\x20\
    loaded\x20and\x20stored\n\n\r\n\x05\x04\r\x02\n\x04\x12\x04\xbb\x01\x02\
    \n\n\r\n\x05\x04\r\x02\n\x06\x12\x04\xbb\x01\x0b$\n\r\n\x05\x04\r\x02\n\
    \x01\x12\x04\xbb\x01%3\n\r\n\x05\x04\r\x02\n\x03\x12\x04\xbb\x0168\n[\n\
    \x04\x04\r\x02\x0b\x12\x04\xbd\x01\x02\x1f\x1aM\x20the\x20interned\x20st\
    rings\x20stored\x20in\x20the\x20wasm\x20binary\x20(panic/abort\x20messag\
    es,\x20etc.)\n\n\r\n\x05\x04\r\x02\x0b\x04\x12\x04\xbd\x01\x02\n\n\r\n\
    \x05\x04\r\x02\x0b\x05\x12\x04\xbd\x01\x0b\x11\n\r\n\x05\x04\r\x02\x0b\
    \x01\x12\x04\xbd\x01\x12\x19\n\r\n\x05\x04\r\x02\x0b\x03\x12\x04\xbd\x01\
    \x1c\x1e\nB\n\x04\x04\r\x02\x0c\x12\x04\xbf\x01\x02%\x1a4\x20match\x20on\
    \x20any\x20function\x20name\x20in\x20an\x20import\x20or\x20export.\n\n\r\
    \n\x05\x04\r\x02\x0c\x04\x12\x04\xbf\x01\x02\n\n\r\n\x05\x04\r\x02\x0c\
    \x05\x12\x04\xbf\x01\x0b\x11\n\r\n\x05\x04\r\x02\x0c\x01\x12\x04\xbf\x01\
    \x12\x1f\n\r\n\x05\x04\r\x02\x0c\x03\x12\x04\xbf\x01\"$\nO\n\x04\x04\r\
    \x02\r\x12\x04\xc1\x01\x02#\x1aA\x20match\x20on\x20the\x20module\x20name\
    \x20e.g.\x20`env`\x20or\x20`wasi_snapshot_preview1`\n\n\r\n\x05\x04\r\
    \x02\r\x04\x12\x04\xc1\x01\x02\n\n\r\n\x05\x04\r\x02\r\x05\x12\x04\xc1\
    \x01\x0b\x11\n\r\n\x05\x04\r\x02\r\x01\x12\x04\xc1\x01\x12\x1d\n\r\n\x05\
    \x04\r\x02\r\x03\x12\x04\xc1\x01\x20\"\n\x0c\n\x04\x04\r\x02\x0e\x12\x04\
    \xc3\x01\x02\x1d\n\r\n\x05\x04\r\x02\x0e\x06\x12\x04\xc3\x01\x02\x0c\n\r\
    \n\x05\x04\r\x02\x0e\x01\x12\x04\xc3\x01\r\x17\n\r\n\x05\x04\r\x02\x0e\
    \x03\x12\x04\xc3\x01\x1a\x1c\n\x0c\n\x04\x04\r\x02\x0f\x12\x04\xc4\x01\
    \x02\x11\n\r\n\x05\x04\r\x02\x0f\x06\x12\x04\xc4\x01\x02\x06\n\r\n\x05\
    \x04\r\x02\x0f\x01\x12\x04\xc4\x01\x07\x0b\n\r\n\x05\x04\r\x02\x0f\x03\
    \x12\x04\xc4\x01\x0e\x10\nM\n\x02\x04\x0e\x12\x06\xc8\x01\0\xd0\x01\x01\
    \x1a?\x20The\x20message\x20returned\x20in\x20response\x20to\x20a\x20`Sea\
    rchModulesRequest`.\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xc8\x01\x08\x1d\n\
    \x0c\n\x04\x04\x0e\x02\0\x12\x04\xc9\x01\x02\x1e\n\r\n\x05\x04\x0e\x02\0\
    \x04\x12\x04\xc9\x01\x02\n\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xc9\x01\
    \x0b\x11\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xc9\x01\x12\x19\n\r\n\x05\
    \x04\x0e\x02\0\x03\x12\x04\xc9\x01\x1c\x1d\n\x0c\n\x04\x04\x0e\x02\x01\
    \x12\x04\xca\x01\x02\x1c\n\r\n\x05\x04\x0e\x02\x01\x06\x12\x04\xca\x01\
    \x02\x0c\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xca\x01\r\x17\n\r\n\x05\
    \x04\x0e\x02\x01\x03\x12\x04\xca\x01\x1a\x1b\ng\n\x04\x04\x0e\x02\x02\
    \x12\x04\xcd\x01\x02\x13\x1aY\x20the\x20full\x20count\x20of\x20results\
    \x20in\x20the\x20database\x20(not\x20the\x20count\x20of\x20this\x20messa\
    ge's\n\x20`modules`).\n\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xcd\x01\
    \x02\x08\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xcd\x01\t\x0e\n\r\n\x05\
    \x04\x0e\x02\x02\x03\x12\x04\xcd\x01\x11\x12\n\x0c\n\x04\x04\x0e\x02\x03\
    \x12\x04\xce\x01\x02\x10\n\r\n\x05\x04\x0e\x02\x03\x06\x12\x04\xce\x01\
    \x02\x06\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xce\x01\x07\x0b\n\r\n\x05\
    \x04\x0e\x02\x03\x03\x12\x04\xce\x01\x0e\x0f\n\x0c\n\x04\x04\x0e\x02\x04\
    \x12\x04\xcf\x01\x02\x1b\n\r\n\x05\x04\x0e\x02\x04\x04\x12\x04\xcf\x01\
    \x02\n\n\r\n\x05\x04\x0e\x02\x04\x06\x12\x04\xcf\x01\x0b\x10\n\r\n\x05\
    \x04\x0e\x02\x04\x01\x12\x04\xcf\x01\x11\x16\n\r\n\x05\x04\x0e\x02\x04\
    \x03\x12\x04\xcf\x01\x19\x1a\nt\n\x02\x04\x0f\x12\x04\xd4\x01\0?\x1ah\
    \x20`DELETE\x20/api/v1/module:`\n\x20Remove\x20a\x20module\x20from\x20th\
    e\x20database\x20by\x20its\x20ID.\x20Return\x20the\x20module\x20IDs\x20&\
    \x20hashes.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xd4\x01\x08\x1c\n\x0c\n\
    \x04\x04\x0f\x02\0\x12\x04\xd4\x01\x1f=\n\r\n\x05\x04\x0f\x02\0\x04\x12\
    \x04\xd4\x01\x1f'\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xd4\x01(-\n\r\n\
    \x05\x04\x0f\x02\0\x01\x12\x04\xd4\x01.8\n\r\n\x05\x04\x0f\x02\0\x03\x12\
    \x04\xd4\x01;<\nM\n\x02\x04\x10\x12\x06\xd7\x01\0\xda\x01\x01\x1a?\x20Th\
    e\x20message\x20returned\x20in\x20response\x20to\x20a\x20`DeleteModulesR\
    equest`.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xd7\x01\x08\x1d\n\x0c\n\x04\
    \x04\x10\x02\0\x12\x04\xd8\x01\x02(\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\
    \xd8\x01\x02\x14\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xd8\x01\x15#\n\r\n\
    \x05\x04\x10\x02\0\x03\x12\x04\xd8\x01&'\n\x0c\n\x04\x04\x10\x02\x01\x12\
    \x04\xd9\x01\x02\x1b\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xd9\x01\x02\n\
    \n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\xd9\x01\x0b\x10\n\r\n\x05\x04\x10\
    \x02\x01\x01\x12\x04\xd9\x01\x11\x16\n\r\n\x05\x04\x10\x02\x01\x03\x12\
    \x04\xd9\x01\x19\x1a\n\xfc\x01\n\x02\x05\x04\x12\x06\xdf\x01\0\xe2\x01\
    \x01\x1a\xed\x01\x20Represents\x20the\x20expected\x20outcome\x20of\x20an\
    \x20AuditModulesRequest.\x20If\x20PASS\x20is\x20provided,\x20then\n\x20t\
    he\x20audit\x20returns\x20modules\x20which\x20conform\x20to\x20the\x20ch\
    eckfile.\x20If\x20FAIL\x20is\x20provided,\x20then\n\x20the\x20audit\x20r\
    eturns\x20modules\x20which\x20do\x20not\x20conform\x20to\x20the\x20check\
    file.\n\n\x0b\n\x03\x05\x04\x01\x12\x04\xdf\x01\x05\x11\n\x0c\n\x04\x05\
    \x04\x02\0\x12\x04\xe0\x01\x02\x0b\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\
    \xe0\x01\x02\x06\n\r\n\x05\x05\x04\x02\0\x02\x12\x04\xe0\x01\t\n\n\x0c\n\
    \x04\x05\x04\x02\x01\x12\x04\xe1\x01\x02\x0b\n\r\n\x05\x05\x04\x02\x01\
    \x01\x12\x04\xe1\x01\x02\x06\n\r\n\x05\x05\x04\x02\x01\x02\x12\x04\xe1\
    \x01\t\n\n\x82\x01\n\x02\x04\x11\x12\x06\xe6\x01\0\xeb\x01\x01\x1at\x20`\
    POST\x20/api/v1/audit:`\n\x20Return\x20a\x20list\x20of\x20modules\x20whi\
    ch\x20match\x20the\x20outcome\x20requirements\x20using\x20the\x20provide\
    d\x20checkfile.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xe6\x01\x08\x1b\n8\n\
    \x04\x04\x11\x02\0\x12\x04\xe8\x01\x02\x16\x1a*\x20the\x20YAML\x20checkf\
    ile\x20(e.g.\x20mod.yaml)\x20bytes\n\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\
    \xe8\x01\x02\x07\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xe8\x01\x08\x11\n\r\
    \n\x05\x04\x11\x02\0\x03\x12\x04\xe8\x01\x14\x15\n\x0c\n\x04\x04\x11\x02\
    \x01\x12\x04\xe9\x01\x02\x1b\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\xe9\
    \x01\x02\x0e\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xe9\x01\x0f\x16\n\r\n\
    \x05\x04\x11\x02\x01\x03\x12\x04\xe9\x01\x19\x1a\n\x0c\n\x04\x04\x11\x02\
    \x02\x12\x04\xea\x01\x02\x1c\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\xea\
    \x01\x02\x0c\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xea\x01\r\x17\n\r\n\
    \x05\x04\x11\x02\x02\x03\x12\x04\xea\x01\x1a\x1b\nL\n\x02\x04\x12\x12\
    \x06\xee\x01\0\xf7\x01\x01\x1a>\x20The\x20message\x20returned\x20in\x20r\
    esponse\x20to\x20a\x20`AuditModulesRequest`.\n\n\x0b\n\x03\x04\x12\x01\
    \x12\x04\xee\x01\x08\x1c\n\xad\x01\n\x04\x04\x12\x02\0\x12\x04\xf1\x01\
    \x02.\x1a\x9e\x01\x20each\x20record\x20contains\x20the\x20ID\x20of\x20th\
    e\x20invalid\x20Module\x20which\x20failed\x20the\x20audit,\x20as\x20well\
    \x20as\x20the\x20failure\x20\n\x20report\x20produced\x20by\x20the\x20val\
    idation\x20check\x20(encoded\x20in\x20JSON)\n\n\r\n\x05\x04\x12\x02\0\
    \x06\x12\x04\xf1\x01\x02\x13\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xf1\x01\
    \x14)\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xf1\x01,-\n\x0c\n\x04\x04\x12\
    \x02\x01\x12\x04\xf2\x01\x02\x1c\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\
    \xf2\x01\x02\x0c\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xf2\x01\r\x17\n\r\
    \n\x05\x04\x12\x02\x01\x03\x12\x04\xf2\x01\x1a\x1b\ng\n\x04\x04\x12\x02\
    \x02\x12\x04\xf5\x01\x02\x13\x1aY\x20the\x20full\x20count\x20of\x20resul\
    ts\x20in\x20the\x20database\x20(not\x20the\x20count\x20of\x20this\x20mes\
    sage's\n\x20`modules`).\n\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\xf5\x01\
    \x02\x08\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xf5\x01\t\x0e\n\r\n\x05\
    \x04\x12\x02\x02\x03\x12\x04\xf5\x01\x11\x12\n\x0c\n\x04\x04\x12\x02\x03\
    \x12\x04\xf6\x01\x02\x1b\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\xf6\x01\
    \x02\n\n\r\n\x05\x04\x12\x02\x03\x06\x12\x04\xf6\x01\x0b\x10\n\r\n\x05\
    \x04\x12\x02\x03\x01\x12\x04\xf6\x01\x11\x16\n\r\n\x05\x04\x12\x02\x03\
    \x03\x12\x04\xf6\x01\x19\x1a\ni\n\x02\x05\x05\x12\x06\xfe\x01\0\x83\x02\
    \x01\x1a6\x20classifies\x20a\x20validation\x20failure\x20as\x20a\x20part\
    icular\x20kind\n2#\nModsurfer\x20CLI\x20Plug-in\x20Definitions\n\n\x0b\n\
    \x03\x05\x05\x01\x12\x04\xfe\x01\x05\x13\n\x0c\n\x04\x05\x05\x02\0\x12\
    \x04\xff\x01\x02\x0e\n\r\n\x05\x05\x05\x02\0\x01\x12\x04\xff\x01\x02\t\n\
    \r\n\x05\x05\x05\x02\0\x02\x12\x04\xff\x01\x0c\r\n\x0c\n\x04\x05\x05\x02\
    \x01\x12\x04\x80\x02\x02\x18\n\r\n\x05\x05\x05\x02\x01\x01\x12\x04\x80\
    \x02\x02\x13\n\r\n\x05\x05\x05\x02\x01\x02\x12\x04\x80\x02\x16\x17\n\x0c\
    \n\x04\x05\x05\x02\x02\x12\x04\x81\x02\x02\x15\n\r\n\x05\x05\x05\x02\x02\
    \x01\x12\x04\x81\x02\x02\x10\n\r\n\x05\x05\x05\x02\x02\x02\x12\x04\x81\
    \x02\x13\x14\n\x0c\n\x04\x05\x05\x02\x03\x12\x04\x82\x02\x02\x0f\n\r\n\
    \x05\x05\x05\x02\x03\x01\x12\x04\x82\x02\x02\n\n\r\n\x05\x05\x05\x02\x03\
    \x02\x12\x04\x82\x02\r\x0e\nR\n\x02\x04\x13\x12\x06\x86\x02\0\x8b\x02\
    \x01\x1aD\x20provides\x20context\x20around\x20the\x20validation\x20failu\
    re,\x20used\x20in\x20the\x20Report\n\n\x0b\n\x03\x04\x13\x01\x12\x04\x86\
    \x02\x08\x15\n\x0c\n\x04\x04\x13\x02\0\x12\x04\x87\x02\x02\x14\n\r\n\x05\
    \x04\x13\x02\0\x05\x12\x04\x87\x02\x02\x08\n\r\n\x05\x04\x13\x02\0\x01\
    \x12\x04\x87\x02\t\x0f\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x87\x02\x12\
    \x13\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\x88\x02\x02\x16\n\r\n\x05\x04\
    \x13\x02\x01\x05\x12\x04\x88\x02\x02\x08\n\r\n\x05\x04\x13\x02\x01\x01\
    \x12\x04\x88\x02\t\x11\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\x88\x02\x14\
    \x15\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\x89\x02\x02\x16\n\r\n\x05\x04\
    \x13\x02\x02\x05\x12\x04\x89\x02\x02\x08\n\r\n\x05\x04\x13\x02\x02\x01\
    \x12\x04\x89\x02\t\x11\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\x89\x02\x14\
    \x15\n\x0c\n\x04\x04\x13\x02\x03\x12\x04\x8a\x02\x02$\n\r\n\x05\x04\x13\
    \x02\x03\x06\x12\x04\x8a\x02\x02\x10\n\r\n\x05\x04\x13\x02\x03\x01\x12\
    \x04\x8a\x02\x11\x1f\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\x8a\x02\"#\n\
    \xa3\x01\n\x02\x04\x14\x12\x06\x8f\x02\0\x91\x02\x01\x1a\x94\x01\x20k/v\
    \x20pair\x20of\x20the\x20dot-separated\x20path\x20to\x20validation\x20fi\
    eld\x20and\x20expectation\x20info,\x20plus\x20any\x20info\n\x20provided\
    \x20by\x20plugins\x20executed\x20after\x20built-in\x20validation\n\n\x0b\
    \n\x03\x04\x14\x01\x12\x04\x8f\x02\x08\x0e\n\x0c\n\x04\x04\x14\x02\0\x12\
    \x04\x90\x02\x02'\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\x90\x02\x02\x1c\n\
    \r\n\x05\x04\x14\x02\0\x01\x12\x04\x90\x02\x1d\"\n\r\n\x05\x04\x14\x02\0\
    \x03\x12\x04\x90\x02%&\n\xba\x01\n\x02\x04\x15\x12\x06\x95\x02\0\x99\x02\
    \x01\x1a\xab\x01\x20input\x20provided\x20to\x20a\x20plugin\x20when\x20it\
    \x20is\x20executed,\x20possibly\x20after\x20another\x20plugin,\x20who\
    \x20would\x20update\n\x20the\x20report\x20and\x20provide\x20it\x20to\x20\
    the\x20currently\x20running\x20plugin\x20via\x20this\x20value\n\n\x0b\n\
    \x03\x04\x15\x01\x12\x04\x95\x02\x08\x13\n\x0c\n\x04\x04\x15\x02\0\x12\
    \x04\x96\x02\x02\x14\n\r\n\x05\x04\x15\x02\0\x06\x12\x04\x96\x02\x02\x08\
    \n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x96\x02\t\x0f\n\r\n\x05\x04\x15\x02\
    \0\x03\x12\x04\x96\x02\x12\x13\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\x97\
    \x02\x02\x14\n\r\n\x05\x04\x15\x02\x01\x06\x12\x04\x97\x02\x02\x08\n\r\n\
    \x05\x04\x15\x02\x01\x01\x12\x04\x97\x02\t\x0f\n\r\n\x05\x04\x15\x02\x01\
    \x03\x12\x04\x97\x02\x12\x13\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\x98\x02\
    \x02\x11\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\x98\x02\x02\x07\n\r\n\x05\
    \x04\x15\x02\x02\x01\x12\x04\x98\x02\x08\x0c\n\r\n\x05\x04\x15\x02\x02\
    \x03\x12\x04\x98\x02\x0f\x10\n\xc3\x01\n\x02\x04\x16\x12\x06\x9d\x02\0\
    \x9f\x02\x01\x1a\xb4\x01\x20output\x20returned\x20from\x20a\x20plugin\
    \x20after\x20it's\x20executed,\x20containing\x20failures\x20which\x20are\
    \x20added\x20to\x20the\x20\n\x20parent\x20context\x20Report,\x20which\
    \x20will\x20be\x20provided\x20to\x20the\x20plugin's\x20serial\x20nested\
    \x20Report\n\n\x0b\n\x03\x04\x16\x01\x12\x04\x9d\x02\x08\x14\n\x0c\n\x04\
    \x04\x16\x02\0\x12\x04\x9e\x02\x02&\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\
    \x9e\x02\x02\n\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\x9e\x02\x0b\x18\n\r\n\
    \x05\x04\x16\x02\0\x01\x12\x04\x9e\x02\x19!\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\x9e\x02$%b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(23);
            messages.push(Function::generated_message_descriptor_data());
            messages.push(Import::generated_message_descriptor_data());
            messages.push(Export::generated_message_descriptor_data());
            messages.push(Module::generated_message_descriptor_data());
            messages.push(Error::generated_message_descriptor_data());
            messages.push(Pagination::generated_message_descriptor_data());
            messages.push(Sort::generated_message_descriptor_data());
            messages.push(CreateModuleRequest::generated_message_descriptor_data());
            messages.push(CreateModuleResponse::generated_message_descriptor_data());
            messages.push(GetModuleRequest::generated_message_descriptor_data());
            messages.push(GetModuleResponse::generated_message_descriptor_data());
            messages.push(ListModulesRequest::generated_message_descriptor_data());
            messages.push(ListModulesResponse::generated_message_descriptor_data());
            messages.push(SearchModulesRequest::generated_message_descriptor_data());
            messages.push(SearchModulesResponse::generated_message_descriptor_data());
            messages.push(DeleteModulesRequest::generated_message_descriptor_data());
            messages.push(DeleteModulesResponse::generated_message_descriptor_data());
            messages.push(AuditModulesRequest::generated_message_descriptor_data());
            messages.push(AuditModulesResponse::generated_message_descriptor_data());
            messages.push(FailureDetail::generated_message_descriptor_data());
            messages.push(Report::generated_message_descriptor_data());
            messages.push(PluginInput::generated_message_descriptor_data());
            messages.push(PluginOutput::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(6);
            enums.push(ValType::generated_enum_descriptor_data());
            enums.push(SourceLanguage::generated_enum_descriptor_data());
            enums.push(Direction::generated_enum_descriptor_data());
            enums.push(Field::generated_enum_descriptor_data());
            enums.push(AuditOutcome::generated_enum_descriptor_data());
            enums.push(Classification::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
