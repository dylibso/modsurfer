// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `proto/v1/api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  Contained by an import or export element within a wasm binary.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Function)
pub struct Function {
    // message fields
    // @@protoc_insertion_point(field:Function.params)
    pub params: ::std::vec::Vec<::protobuf::EnumOrUnknown<ValType>>,
    // @@protoc_insertion_point(field:Function.results)
    pub results: ::std::vec::Vec<::protobuf::EnumOrUnknown<ValType>>,
    // @@protoc_insertion_point(field:Function.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Function.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Function {
    fn default() -> &'a Function {
        <Function as ::protobuf::Message>::default_instance()
    }
}

impl Function {
    pub fn new() -> Function {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "params",
            |m: &Function| { &m.params },
            |m: &mut Function| { &mut m.params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &Function| { &m.results },
            |m: &mut Function| { &mut m.results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Function| { &m.name },
            |m: &mut Function| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Function>(
            "Function",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Function {
    const NAME: &'static str = "Function";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.params.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.params)?
                },
                16 => {
                    self.results.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.results)?
                },
                26 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.params {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        for value in &self.results {
            my_size += ::protobuf::rt::int32_size(2, value.value());
        };
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.params {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.results {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Function {
        Function::new()
    }

    fn clear(&mut self) {
        self.params.clear();
        self.results.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Function {
        static instance: Function = Function {
            params: ::std::vec::Vec::new(),
            results: ::std::vec::Vec::new(),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Function {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Function").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Function {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Function {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A function and module namespace that is defined outside of the current
///  module, and referenced & called by the current module.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Import)
pub struct Import {
    // message fields
    // @@protoc_insertion_point(field:Import.module_name)
    pub module_name: ::std::string::String,
    // @@protoc_insertion_point(field:Import.func)
    pub func: ::protobuf::MessageField<Function>,
    // special fields
    // @@protoc_insertion_point(special_field:Import.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Import {
    fn default() -> &'a Import {
        <Import as ::protobuf::Message>::default_instance()
    }
}

impl Import {
    pub fn new() -> Import {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_name",
            |m: &Import| { &m.module_name },
            |m: &mut Import| { &mut m.module_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Function>(
            "func",
            |m: &Import| { &m.func },
            |m: &mut Import| { &mut m.func },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Import>(
            "Import",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Import {
    const NAME: &'static str = "Import";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.module_name = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.func)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.module_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.module_name);
        }
        if let Some(v) = self.func.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.module_name.is_empty() {
            os.write_string(1, &self.module_name)?;
        }
        if let Some(v) = self.func.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Import {
        Import::new()
    }

    fn clear(&mut self) {
        self.module_name.clear();
        self.func.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Import {
        static instance: Import = Import {
            module_name: ::std::string::String::new(),
            func: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Import {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Import").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Import {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Import {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A function that is defined inside the current module, made available to
///  outside modules / environments.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Export)
pub struct Export {
    // message fields
    // @@protoc_insertion_point(field:Export.func)
    pub func: ::protobuf::MessageField<Function>,
    // special fields
    // @@protoc_insertion_point(special_field:Export.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Export {
    fn default() -> &'a Export {
        <Export as ::protobuf::Message>::default_instance()
    }
}

impl Export {
    pub fn new() -> Export {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Function>(
            "func",
            |m: &Export| { &m.func },
            |m: &mut Export| { &mut m.func },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Export>(
            "Export",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Export {
    const NAME: &'static str = "Export";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.func)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.func.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.func.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Export {
        Export::new()
    }

    fn clear(&mut self) {
        self.func.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Export {
        static instance: Export = Export {
            func: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Export {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Export").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Export {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Export {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Details about a wasm module, either extracted directly from the binary, or
///  inferred somehow.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Module)
pub struct Module {
    // message fields
    ///  ID for this module, generated by the database.
    // @@protoc_insertion_point(field:Module.id)
    pub id: i64,
    ///  sha256 hash of the modules raw bytes
    // @@protoc_insertion_point(field:Module.hash)
    pub hash: ::std::string::String,
    ///  function imports called by the module (see:
    ///  <https://github.com/WebAssembly/design/blob/main/Modules.md#imports)>
    // @@protoc_insertion_point(field:Module.imports)
    pub imports: ::std::vec::Vec<Import>,
    ///  function exports provided by the module (see:
    ///  <https://github.com/WebAssembly/design/blob/main/Modules.md#exports)>
    // @@protoc_insertion_point(field:Module.exports)
    pub exports: ::std::vec::Vec<Export>,
    ///  size in bytes of the module
    // @@protoc_insertion_point(field:Module.size)
    pub size: u64,
    ///  path or locator to the module
    // @@protoc_insertion_point(field:Module.location)
    pub location: ::std::string::String,
    ///  programming language used to produce this module
    // @@protoc_insertion_point(field:Module.source_language)
    pub source_language: ::protobuf::EnumOrUnknown<SourceLanguage>,
    ///  arbitrary metadata provided by the operator of this module
    // @@protoc_insertion_point(field:Module.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  timestamp when this module was loaded and stored
    // @@protoc_insertion_point(field:Module.inserted_at)
    pub inserted_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  the interned strings stored in the wasm binary (panic/abort messages, etc.)
    // @@protoc_insertion_point(field:Module.strings)
    pub strings: ::std::vec::Vec<::std::string::String>,
    ///  the cyclomatic complexity
    ///  (<https://en.wikipedia.org/wiki/Cyclomatic_complexity>) of the instructions
    // @@protoc_insertion_point(field:Module.complexity)
    pub complexity: ::std::option::Option<u32>,
    ///  the serialized graph in json format
    // @@protoc_insertion_point(field:Module.graph)
    pub graph: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:Module.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Module {
    fn default() -> &'a Module {
        <Module as ::protobuf::Message>::default_instance()
    }
}

impl Module {
    pub fn new() -> Module {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Module| { &m.id },
            |m: &mut Module| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &Module| { &m.hash },
            |m: &mut Module| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "imports",
            |m: &Module| { &m.imports },
            |m: &mut Module| { &mut m.imports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exports",
            |m: &Module| { &m.exports },
            |m: &mut Module| { &mut m.exports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "size",
            |m: &Module| { &m.size },
            |m: &mut Module| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "location",
            |m: &Module| { &m.location },
            |m: &mut Module| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_language",
            |m: &Module| { &m.source_language },
            |m: &mut Module| { &mut m.source_language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metadata",
            |m: &Module| { &m.metadata },
            |m: &mut Module| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "inserted_at",
            |m: &Module| { &m.inserted_at },
            |m: &mut Module| { &mut m.inserted_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "strings",
            |m: &Module| { &m.strings },
            |m: &mut Module| { &mut m.strings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "complexity",
            |m: &Module| { &m.complexity },
            |m: &mut Module| { &mut m.complexity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "graph",
            |m: &Module| { &m.graph },
            |m: &mut Module| { &mut m.graph },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Module>(
            "Module",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Module {
    const NAME: &'static str = "Module";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int64()?;
                },
                26 => {
                    self.hash = is.read_string()?;
                },
                34 => {
                    self.imports.push(is.read_message()?);
                },
                42 => {
                    self.exports.push(is.read_message()?);
                },
                48 => {
                    self.size = is.read_uint64()?;
                },
                58 => {
                    self.location = is.read_string()?;
                },
                64 => {
                    self.source_language = is.read_enum_or_unknown()?;
                },
                74 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inserted_at)?;
                },
                90 => {
                    self.strings.push(is.read_string()?);
                },
                104 => {
                    self.complexity = ::std::option::Option::Some(is.read_uint32()?);
                },
                114 => {
                    self.graph = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.id);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.hash);
        }
        for value in &self.imports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.exports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.size != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.size);
        }
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.location);
        }
        if self.source_language != ::protobuf::EnumOrUnknown::new(SourceLanguage::Unknown) {
            my_size += ::protobuf::rt::int32_size(8, self.source_language.value());
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.inserted_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.strings {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(v) = self.complexity {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.graph.as_ref() {
            my_size += ::protobuf::rt::bytes_size(14, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if !self.hash.is_empty() {
            os.write_string(3, &self.hash)?;
        }
        for v in &self.imports {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.exports {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.size != 0 {
            os.write_uint64(6, self.size)?;
        }
        if !self.location.is_empty() {
            os.write_string(7, &self.location)?;
        }
        if self.source_language != ::protobuf::EnumOrUnknown::new(SourceLanguage::Unknown) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.source_language))?;
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(74)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.inserted_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        for v in &self.strings {
            os.write_string(11, &v)?;
        };
        if let Some(v) = self.complexity {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.graph.as_ref() {
            os.write_bytes(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Module {
        Module::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.hash.clear();
        self.imports.clear();
        self.exports.clear();
        self.size = 0;
        self.location.clear();
        self.source_language = ::protobuf::EnumOrUnknown::new(SourceLanguage::Unknown);
        self.metadata.clear();
        self.inserted_at.clear();
        self.strings.clear();
        self.complexity = ::std::option::Option::None;
        self.graph = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Module {
        static instance: ::protobuf::rt::Lazy<Module> = ::protobuf::rt::Lazy::new();
        instance.get(Module::new)
    }
}

impl ::protobuf::MessageFull for Module {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Module").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Module {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Module {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  An error message indicating a problem in the API.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Error)
pub struct Error {
    // message fields
    // @@protoc_insertion_point(field:Error.code)
    pub code: i32,
    // @@protoc_insertion_point(field:Error.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Error.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Error {
    fn default() -> &'a Error {
        <Error as ::protobuf::Message>::default_instance()
    }
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &Error| { &m.code },
            |m: &mut Error| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &Error| { &m.message },
            |m: &mut Error| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Error>(
            "Error",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Error {
    const NAME: &'static str = "Error";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_int32()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Error {
        Error::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Error {
        static instance: Error = Error {
            code: 0,
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Error {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Error").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Error {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Control/limit the way results are paginated when working with large
///  responses.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Pagination)
pub struct Pagination {
    // message fields
    // @@protoc_insertion_point(field:Pagination.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:Pagination.offset)
    pub offset: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Pagination.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pagination {
    fn default() -> &'a Pagination {
        <Pagination as ::protobuf::Message>::default_instance()
    }
}

impl Pagination {
    pub fn new() -> Pagination {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &Pagination| { &m.limit },
            |m: &mut Pagination| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offset",
            |m: &Pagination| { &m.offset },
            |m: &mut Pagination| { &mut m.offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pagination>(
            "Pagination",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pagination {
    const NAME: &'static str = "Pagination";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.limit = is.read_uint32()?;
                },
                16 => {
                    self.offset = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.limit);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.offset);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.limit != 0 {
            os.write_uint32(1, self.limit)?;
        }
        if self.offset != 0 {
            os.write_uint32(2, self.offset)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pagination {
        Pagination::new()
    }

    fn clear(&mut self) {
        self.limit = 0;
        self.offset = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pagination {
        static instance: Pagination = Pagination {
            limit: 0,
            offset: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pagination {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pagination").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pagination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pagination {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Determine how to sort results from the API
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Sort)
pub struct Sort {
    // message fields
    // @@protoc_insertion_point(field:Sort.direction)
    pub direction: ::protobuf::EnumOrUnknown<Direction>,
    // @@protoc_insertion_point(field:Sort.field)
    pub field: ::protobuf::EnumOrUnknown<Field>,
    // special fields
    // @@protoc_insertion_point(special_field:Sort.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Sort {
    fn default() -> &'a Sort {
        <Sort as ::protobuf::Message>::default_instance()
    }
}

impl Sort {
    pub fn new() -> Sort {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &Sort| { &m.direction },
            |m: &mut Sort| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "field",
            |m: &Sort| { &m.field },
            |m: &mut Sort| { &mut m.field },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sort>(
            "Sort",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Sort {
    const NAME: &'static str = "Sort";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.direction = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.field = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.direction != ::protobuf::EnumOrUnknown::new(Direction::Desc) {
            my_size += ::protobuf::rt::int32_size(1, self.direction.value());
        }
        if self.field != ::protobuf::EnumOrUnknown::new(Field::CreatedAt) {
            my_size += ::protobuf::rt::int32_size(2, self.field.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.direction != ::protobuf::EnumOrUnknown::new(Direction::Desc) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.direction))?;
        }
        if self.field != ::protobuf::EnumOrUnknown::new(Field::CreatedAt) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.field))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Sort {
        Sort::new()
    }

    fn clear(&mut self) {
        self.direction = ::protobuf::EnumOrUnknown::new(Direction::Desc);
        self.field = ::protobuf::EnumOrUnknown::new(Field::CreatedAt);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Sort {
        static instance: Sort = Sort {
            direction: ::protobuf::EnumOrUnknown::from_i32(0),
            field: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Sort {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Sort").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Sort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sort {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `PUT /api/v1/module:`
///  Insert a module, extract data from binary. Return the module ID & hash.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CreateModuleRequest)
pub struct CreateModuleRequest {
    // message fields
    // @@protoc_insertion_point(field:CreateModuleRequest.wasm)
    pub wasm: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:CreateModuleRequest.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  a valid URL with a scheme prefix e.g. `s3://`, `file://`, `https://`
    // @@protoc_insertion_point(field:CreateModuleRequest.location)
    pub location: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CreateModuleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateModuleRequest {
    fn default() -> &'a CreateModuleRequest {
        <CreateModuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateModuleRequest {
    pub fn new() -> CreateModuleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wasm",
            |m: &CreateModuleRequest| { &m.wasm },
            |m: &mut CreateModuleRequest| { &mut m.wasm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metadata",
            |m: &CreateModuleRequest| { &m.metadata },
            |m: &mut CreateModuleRequest| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location",
            |m: &CreateModuleRequest| { &m.location },
            |m: &mut CreateModuleRequest| { &mut m.location },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateModuleRequest>(
            "CreateModuleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateModuleRequest {
    const NAME: &'static str = "CreateModuleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.wasm = is.read_bytes()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                26 => {
                    self.location = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.wasm.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.wasm);
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.wasm.is_empty() {
            os.write_bytes(1, &self.wasm)?;
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.location.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateModuleRequest {
        CreateModuleRequest::new()
    }

    fn clear(&mut self) {
        self.wasm.clear();
        self.metadata.clear();
        self.location = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateModuleRequest {
        static instance: ::protobuf::rt::Lazy<CreateModuleRequest> = ::protobuf::rt::Lazy::new();
        instance.get(CreateModuleRequest::new)
    }
}

impl ::protobuf::MessageFull for CreateModuleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateModuleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateModuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateModuleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `CreateModuleRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CreateModuleResponse)
pub struct CreateModuleResponse {
    // message fields
    // @@protoc_insertion_point(field:CreateModuleResponse.module_id)
    pub module_id: i64,
    // @@protoc_insertion_point(field:CreateModuleResponse.hash)
    pub hash: ::std::string::String,
    // @@protoc_insertion_point(field:CreateModuleResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:CreateModuleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateModuleResponse {
    fn default() -> &'a CreateModuleResponse {
        <CreateModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateModuleResponse {
    pub fn new() -> CreateModuleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &CreateModuleResponse| { &m.module_id },
            |m: &mut CreateModuleResponse| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &CreateModuleResponse| { &m.hash },
            |m: &mut CreateModuleResponse| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &CreateModuleResponse| { &m.error },
            |m: &mut CreateModuleResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateModuleResponse>(
            "CreateModuleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateModuleResponse {
    const NAME: &'static str = "CreateModuleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.module_id = is.read_int64()?;
                },
                18 => {
                    self.hash = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.module_id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.module_id);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hash);
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.module_id != 0 {
            os.write_int64(1, self.module_id)?;
        }
        if !self.hash.is_empty() {
            os.write_string(2, &self.hash)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateModuleResponse {
        CreateModuleResponse::new()
    }

    fn clear(&mut self) {
        self.module_id = 0;
        self.hash.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateModuleResponse {
        static instance: CreateModuleResponse = CreateModuleResponse {
            module_id: 0,
            hash: ::std::string::String::new(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateModuleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateModuleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateModuleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/module:`
///  Return a single module.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GetModuleRequest)
pub struct GetModuleRequest {
    // message fields
    // @@protoc_insertion_point(field:GetModuleRequest.module_id)
    pub module_id: i64,
    // special fields
    // @@protoc_insertion_point(special_field:GetModuleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleRequest {
    fn default() -> &'a GetModuleRequest {
        <GetModuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleRequest {
    pub fn new() -> GetModuleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &GetModuleRequest| { &m.module_id },
            |m: &mut GetModuleRequest| { &mut m.module_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleRequest>(
            "GetModuleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleRequest {
    const NAME: &'static str = "GetModuleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.module_id = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.module_id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.module_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.module_id != 0 {
            os.write_int64(1, self.module_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleRequest {
        GetModuleRequest::new()
    }

    fn clear(&mut self) {
        self.module_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleRequest {
        static instance: GetModuleRequest = GetModuleRequest {
            module_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `GetModuleRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GetModuleResponse)
pub struct GetModuleResponse {
    // message fields
    // @@protoc_insertion_point(field:GetModuleResponse.module)
    pub module: ::protobuf::MessageField<Module>,
    // @@protoc_insertion_point(field:GetModuleResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:GetModuleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleResponse {
    fn default() -> &'a GetModuleResponse {
        <GetModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleResponse {
    pub fn new() -> GetModuleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Module>(
            "module",
            |m: &GetModuleResponse| { &m.module },
            |m: &mut GetModuleResponse| { &mut m.module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &GetModuleResponse| { &m.error },
            |m: &mut GetModuleResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleResponse>(
            "GetModuleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleResponse {
    const NAME: &'static str = "GetModuleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.module.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleResponse {
        GetModuleResponse::new()
    }

    fn clear(&mut self) {
        self.module.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleResponse {
        static instance: GetModuleResponse = GetModuleResponse {
            module: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/modules:`
///  Return paginated list of all modules.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListModulesRequest)
pub struct ListModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:ListModulesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // @@protoc_insertion_point(field:ListModulesRequest.sort)
    pub sort: ::protobuf::MessageField<Sort>,
    // special fields
    // @@protoc_insertion_point(special_field:ListModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModulesRequest {
    fn default() -> &'a ListModulesRequest {
        <ListModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModulesRequest {
    pub fn new() -> ListModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &ListModulesRequest| { &m.pagination },
            |m: &mut ListModulesRequest| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Sort>(
            "sort",
            |m: &ListModulesRequest| { &m.sort },
            |m: &mut ListModulesRequest| { &mut m.sort },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModulesRequest>(
            "ListModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModulesRequest {
    const NAME: &'static str = "ListModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sort)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.sort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModulesRequest {
        ListModulesRequest::new()
    }

    fn clear(&mut self) {
        self.pagination.clear();
        self.sort.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModulesRequest {
        static instance: ListModulesRequest = ListModulesRequest {
            pagination: ::protobuf::MessageField::none(),
            sort: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `ListModulesRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListModulesResponse)
pub struct ListModulesResponse {
    // message fields
    // @@protoc_insertion_point(field:ListModulesResponse.modules)
    pub modules: ::std::vec::Vec<Module>,
    // @@protoc_insertion_point(field:ListModulesResponse.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    ///  the full count of results in the database (not the count of this message's
    ///  `modules`).
    // @@protoc_insertion_point(field:ListModulesResponse.total)
    pub total: u64,
    // @@protoc_insertion_point(field:ListModulesResponse.sort)
    pub sort: ::protobuf::MessageField<Sort>,
    // @@protoc_insertion_point(field:ListModulesResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:ListModulesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModulesResponse {
    fn default() -> &'a ListModulesResponse {
        <ListModulesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListModulesResponse {
    pub fn new() -> ListModulesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &ListModulesResponse| { &m.modules },
            |m: &mut ListModulesResponse| { &mut m.modules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &ListModulesResponse| { &m.pagination },
            |m: &mut ListModulesResponse| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &ListModulesResponse| { &m.total },
            |m: &mut ListModulesResponse| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Sort>(
            "sort",
            |m: &ListModulesResponse| { &m.sort },
            |m: &mut ListModulesResponse| { &mut m.sort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &ListModulesResponse| { &m.error },
            |m: &mut ListModulesResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModulesResponse>(
            "ListModulesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModulesResponse {
    const NAME: &'static str = "ListModulesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.modules.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                24 => {
                    self.total = is.read_uint64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sort)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.total);
        }
        if let Some(v) = self.sort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.total != 0 {
            os.write_uint64(3, self.total)?;
        }
        if let Some(v) = self.sort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModulesResponse {
        ListModulesResponse::new()
    }

    fn clear(&mut self) {
        self.modules.clear();
        self.pagination.clear();
        self.total = 0;
        self.sort.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModulesResponse {
        static instance: ListModulesResponse = ListModulesResponse {
            modules: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            total: 0,
            sort: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModulesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModulesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModulesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModulesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/search:`
///  Search for modules based on filter params provided (which should be any
///  dimension of the module schema, or string search in any metadata value).
///  Return a paginated list of matching modules.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SearchModulesRequest)
pub struct SearchModulesRequest {
    // message fields
    ///  ID for this module, generated by the database.
    // @@protoc_insertion_point(field:SearchModulesRequest.id)
    pub id: ::std::option::Option<i64>,
    ///  original name of the binary module file
    // @@protoc_insertion_point(field:SearchModulesRequest.hash)
    pub hash: ::std::option::Option<::std::string::String>,
    ///  function imports called by the module (see:
    ///  <https://github.com/WebAssembly/design/blob/main/Modules.md#imports>)
    // @@protoc_insertion_point(field:SearchModulesRequest.imports)
    pub imports: ::std::vec::Vec<Import>,
    ///  function exports provided by the module (see:
    ///  <https://github.com/WebAssembly/design/blob/main/Modules.md#exports>)
    // @@protoc_insertion_point(field:SearchModulesRequest.exports)
    pub exports: ::std::vec::Vec<Export>,
    ///  minimum size in bytes of the module
    // @@protoc_insertion_point(field:SearchModulesRequest.min_size)
    pub min_size: ::std::option::Option<u64>,
    ///  maximum size in bytes of the module
    // @@protoc_insertion_point(field:SearchModulesRequest.max_size)
    pub max_size: ::std::option::Option<u64>,
    ///  optional path or locator to the module (TODO: maybe this is better stored
    ///  as metadata)
    // @@protoc_insertion_point(field:SearchModulesRequest.location)
    pub location: ::std::option::Option<::std::string::String>,
    ///  programming language used to produce this module
    // @@protoc_insertion_point(field:SearchModulesRequest.source_language)
    pub source_language: ::std::option::Option<::protobuf::EnumOrUnknown<SourceLanguage>>,
    ///  arbitrary metadata provided by the operator of this module
    // @@protoc_insertion_point(field:SearchModulesRequest.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  timestamp when this module was loaded and stored
    // @@protoc_insertion_point(field:SearchModulesRequest.inserted_before)
    pub inserted_before: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  timestamp when this module was loaded and stored
    // @@protoc_insertion_point(field:SearchModulesRequest.inserted_after)
    pub inserted_after: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  the interned strings stored in the wasm binary (panic/abort messages, etc.)
    // @@protoc_insertion_point(field:SearchModulesRequest.strings)
    pub strings: ::std::vec::Vec<::std::string::String>,
    ///  match on any function name in an import or export.
    // @@protoc_insertion_point(field:SearchModulesRequest.function_name)
    pub function_name: ::std::option::Option<::std::string::String>,
    ///  match on the module name e.g. `env` or `wasi_snapshot_preview1`
    // @@protoc_insertion_point(field:SearchModulesRequest.module_name)
    pub module_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SearchModulesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // @@protoc_insertion_point(field:SearchModulesRequest.sort)
    pub sort: ::protobuf::MessageField<Sort>,
    // special fields
    // @@protoc_insertion_point(special_field:SearchModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SearchModulesRequest {
    fn default() -> &'a SearchModulesRequest {
        <SearchModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SearchModulesRequest {
    pub fn new() -> SearchModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &SearchModulesRequest| { &m.id },
            |m: &mut SearchModulesRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &SearchModulesRequest| { &m.hash },
            |m: &mut SearchModulesRequest| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "imports",
            |m: &SearchModulesRequest| { &m.imports },
            |m: &mut SearchModulesRequest| { &mut m.imports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exports",
            |m: &SearchModulesRequest| { &m.exports },
            |m: &mut SearchModulesRequest| { &mut m.exports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_size",
            |m: &SearchModulesRequest| { &m.min_size },
            |m: &mut SearchModulesRequest| { &mut m.min_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_size",
            |m: &SearchModulesRequest| { &m.max_size },
            |m: &mut SearchModulesRequest| { &mut m.max_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location",
            |m: &SearchModulesRequest| { &m.location },
            |m: &mut SearchModulesRequest| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_language",
            |m: &SearchModulesRequest| { &m.source_language },
            |m: &mut SearchModulesRequest| { &mut m.source_language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metadata",
            |m: &SearchModulesRequest| { &m.metadata },
            |m: &mut SearchModulesRequest| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "inserted_before",
            |m: &SearchModulesRequest| { &m.inserted_before },
            |m: &mut SearchModulesRequest| { &mut m.inserted_before },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "inserted_after",
            |m: &SearchModulesRequest| { &m.inserted_after },
            |m: &mut SearchModulesRequest| { &mut m.inserted_after },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "strings",
            |m: &SearchModulesRequest| { &m.strings },
            |m: &mut SearchModulesRequest| { &mut m.strings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "function_name",
            |m: &SearchModulesRequest| { &m.function_name },
            |m: &mut SearchModulesRequest| { &mut m.function_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_name",
            |m: &SearchModulesRequest| { &m.module_name },
            |m: &mut SearchModulesRequest| { &mut m.module_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &SearchModulesRequest| { &m.pagination },
            |m: &mut SearchModulesRequest| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Sort>(
            "sort",
            |m: &SearchModulesRequest| { &m.sort },
            |m: &mut SearchModulesRequest| { &mut m.sort },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SearchModulesRequest>(
            "SearchModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SearchModulesRequest {
    const NAME: &'static str = "SearchModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.hash = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.imports.push(is.read_message()?);
                },
                42 => {
                    self.exports.push(is.read_message()?);
                },
                48 => {
                    self.min_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.max_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                66 => {
                    self.location = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.source_language = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                82 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inserted_before)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inserted_after)?;
                },
                106 => {
                    self.strings.push(is.read_string()?);
                },
                114 => {
                    self.function_name = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.module_name = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sort)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.imports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.exports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.min_size {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.max_size {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.source_language {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.inserted_before.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.inserted_after.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.strings {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        if let Some(v) = self.function_name.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.module_name.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sort.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.hash.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.imports {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.exports {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.min_size {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.max_size {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.location.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.source_language {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(82)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.inserted_before.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.inserted_after.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        for v in &self.strings {
            os.write_string(13, &v)?;
        };
        if let Some(v) = self.function_name.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.module_name.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.sort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SearchModulesRequest {
        SearchModulesRequest::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.hash = ::std::option::Option::None;
        self.imports.clear();
        self.exports.clear();
        self.min_size = ::std::option::Option::None;
        self.max_size = ::std::option::Option::None;
        self.location = ::std::option::Option::None;
        self.source_language = ::std::option::Option::None;
        self.metadata.clear();
        self.inserted_before.clear();
        self.inserted_after.clear();
        self.strings.clear();
        self.function_name = ::std::option::Option::None;
        self.module_name = ::std::option::Option::None;
        self.pagination.clear();
        self.sort.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SearchModulesRequest {
        static instance: ::protobuf::rt::Lazy<SearchModulesRequest> = ::protobuf::rt::Lazy::new();
        instance.get(SearchModulesRequest::new)
    }
}

impl ::protobuf::MessageFull for SearchModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SearchModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SearchModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `SearchModulesRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SearchModulesResponse)
pub struct SearchModulesResponse {
    // message fields
    // @@protoc_insertion_point(field:SearchModulesResponse.modules)
    pub modules: ::std::vec::Vec<Module>,
    // @@protoc_insertion_point(field:SearchModulesResponse.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    ///  the full count of results in the database (not the count of this message's
    ///  `modules`).
    // @@protoc_insertion_point(field:SearchModulesResponse.total)
    pub total: u64,
    // @@protoc_insertion_point(field:SearchModulesResponse.sort)
    pub sort: ::protobuf::MessageField<Sort>,
    // @@protoc_insertion_point(field:SearchModulesResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:SearchModulesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SearchModulesResponse {
    fn default() -> &'a SearchModulesResponse {
        <SearchModulesResponse as ::protobuf::Message>::default_instance()
    }
}

impl SearchModulesResponse {
    pub fn new() -> SearchModulesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &SearchModulesResponse| { &m.modules },
            |m: &mut SearchModulesResponse| { &mut m.modules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &SearchModulesResponse| { &m.pagination },
            |m: &mut SearchModulesResponse| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &SearchModulesResponse| { &m.total },
            |m: &mut SearchModulesResponse| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Sort>(
            "sort",
            |m: &SearchModulesResponse| { &m.sort },
            |m: &mut SearchModulesResponse| { &mut m.sort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &SearchModulesResponse| { &m.error },
            |m: &mut SearchModulesResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SearchModulesResponse>(
            "SearchModulesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SearchModulesResponse {
    const NAME: &'static str = "SearchModulesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.modules.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                24 => {
                    self.total = is.read_uint64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sort)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.total);
        }
        if let Some(v) = self.sort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.total != 0 {
            os.write_uint64(3, self.total)?;
        }
        if let Some(v) = self.sort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SearchModulesResponse {
        SearchModulesResponse::new()
    }

    fn clear(&mut self) {
        self.modules.clear();
        self.pagination.clear();
        self.total = 0;
        self.sort.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SearchModulesResponse {
        static instance: SearchModulesResponse = SearchModulesResponse {
            modules: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            total: 0,
            sort: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SearchModulesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SearchModulesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SearchModulesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchModulesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `DELETE /api/v1/module:`
///  Remove a module from the database by its ID. Return the module IDs & hashes.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeleteModulesRequest)
pub struct DeleteModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:DeleteModulesRequest.module_ids)
    pub module_ids: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:DeleteModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModulesRequest {
    fn default() -> &'a DeleteModulesRequest {
        <DeleteModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModulesRequest {
    pub fn new() -> DeleteModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "module_ids",
            |m: &DeleteModulesRequest| { &m.module_ids },
            |m: &mut DeleteModulesRequest| { &mut m.module_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModulesRequest>(
            "DeleteModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModulesRequest {
    const NAME: &'static str = "DeleteModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int64_into(&mut self.module_ids)?;
                },
                8 => {
                    self.module_ids.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.module_ids {
            my_size += ::protobuf::rt::int64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.module_ids {
            os.write_int64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModulesRequest {
        DeleteModulesRequest::new()
    }

    fn clear(&mut self) {
        self.module_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModulesRequest {
        static instance: DeleteModulesRequest = DeleteModulesRequest {
            module_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `DeleteModulesRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeleteModulesResponse)
pub struct DeleteModulesResponse {
    // message fields
    // @@protoc_insertion_point(field:DeleteModulesResponse.module_id_hash)
    pub module_id_hash: ::std::collections::HashMap<i64, ::std::string::String>,
    // @@protoc_insertion_point(field:DeleteModulesResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:DeleteModulesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModulesResponse {
    fn default() -> &'a DeleteModulesResponse {
        <DeleteModulesResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModulesResponse {
    pub fn new() -> DeleteModulesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "module_id_hash",
            |m: &DeleteModulesResponse| { &m.module_id_hash },
            |m: &mut DeleteModulesResponse| { &mut m.module_id_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &DeleteModulesResponse| { &m.error },
            |m: &mut DeleteModulesResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModulesResponse>(
            "DeleteModulesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModulesResponse {
    const NAME: &'static str = "DeleteModulesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int64()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.module_id_hash.insert(key, value);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.module_id_hash {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.module_id_hash {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int64(1, *k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModulesResponse {
        DeleteModulesResponse::new()
    }

    fn clear(&mut self) {
        self.module_id_hash.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModulesResponse {
        static instance: ::protobuf::rt::Lazy<DeleteModulesResponse> = ::protobuf::rt::Lazy::new();
        instance.get(DeleteModulesResponse::new)
    }
}

impl ::protobuf::MessageFull for DeleteModulesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModulesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModulesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModulesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/audit:`
///  Return a list of modules which match the outcome requirements using the provided checkfile.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AuditModulesRequest)
pub struct AuditModulesRequest {
    // message fields
    ///  the YAML checkfile (e.g. mod.yaml) bytes
    // @@protoc_insertion_point(field:AuditModulesRequest.checkfile)
    pub checkfile: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:AuditModulesRequest.outcome)
    pub outcome: ::protobuf::EnumOrUnknown<AuditOutcome>,
    // @@protoc_insertion_point(field:AuditModulesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:AuditModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuditModulesRequest {
    fn default() -> &'a AuditModulesRequest {
        <AuditModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuditModulesRequest {
    pub fn new() -> AuditModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "checkfile",
            |m: &AuditModulesRequest| { &m.checkfile },
            |m: &mut AuditModulesRequest| { &mut m.checkfile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "outcome",
            |m: &AuditModulesRequest| { &m.outcome },
            |m: &mut AuditModulesRequest| { &mut m.outcome },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &AuditModulesRequest| { &m.pagination },
            |m: &mut AuditModulesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuditModulesRequest>(
            "AuditModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuditModulesRequest {
    const NAME: &'static str = "AuditModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.checkfile = is.read_bytes()?;
                },
                16 => {
                    self.outcome = is.read_enum_or_unknown()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.checkfile.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.checkfile);
        }
        if self.outcome != ::protobuf::EnumOrUnknown::new(AuditOutcome::PASS) {
            my_size += ::protobuf::rt::int32_size(2, self.outcome.value());
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.checkfile.is_empty() {
            os.write_bytes(1, &self.checkfile)?;
        }
        if self.outcome != ::protobuf::EnumOrUnknown::new(AuditOutcome::PASS) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.outcome))?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuditModulesRequest {
        AuditModulesRequest::new()
    }

    fn clear(&mut self) {
        self.checkfile.clear();
        self.outcome = ::protobuf::EnumOrUnknown::new(AuditOutcome::PASS);
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuditModulesRequest {
        static instance: AuditModulesRequest = AuditModulesRequest {
            checkfile: ::std::vec::Vec::new(),
            outcome: ::protobuf::EnumOrUnknown::from_i32(0),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AuditModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuditModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuditModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `AuditModulesRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AuditModulesResponse)
pub struct AuditModulesResponse {
    // message fields
    ///  each record contains the ID of the invalid Module which failed the audit, as well as the failure 
    ///  report produced by the validation check (encoded in JSON)
    // @@protoc_insertion_point(field:AuditModulesResponse.invalid_module_report)
    pub invalid_module_report: ::std::collections::HashMap<i64, ::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:AuditModulesResponse.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    ///  the full count of results in the database (not the count of this message's
    ///  `modules`).
    // @@protoc_insertion_point(field:AuditModulesResponse.total)
    pub total: u64,
    // @@protoc_insertion_point(field:AuditModulesResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:AuditModulesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuditModulesResponse {
    fn default() -> &'a AuditModulesResponse {
        <AuditModulesResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuditModulesResponse {
    pub fn new() -> AuditModulesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "invalid_module_report",
            |m: &AuditModulesResponse| { &m.invalid_module_report },
            |m: &mut AuditModulesResponse| { &mut m.invalid_module_report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &AuditModulesResponse| { &m.pagination },
            |m: &mut AuditModulesResponse| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &AuditModulesResponse| { &m.total },
            |m: &mut AuditModulesResponse| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &AuditModulesResponse| { &m.error },
            |m: &mut AuditModulesResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuditModulesResponse>(
            "AuditModulesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuditModulesResponse {
    const NAME: &'static str = "AuditModulesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int64()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.invalid_module_report.insert(key, value);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                24 => {
                    self.total = is.read_uint64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.invalid_module_report {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.total);
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.invalid_module_report {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int64(1, *k)?;
            os.write_bytes(2, &v)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.total != 0 {
            os.write_uint64(3, self.total)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuditModulesResponse {
        AuditModulesResponse::new()
    }

    fn clear(&mut self) {
        self.invalid_module_report.clear();
        self.pagination.clear();
        self.total = 0;
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuditModulesResponse {
        static instance: ::protobuf::rt::Lazy<AuditModulesResponse> = ::protobuf::rt::Lazy::new();
        instance.get(AuditModulesResponse::new)
    }
}

impl ::protobuf::MessageFull for AuditModulesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuditModulesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuditModulesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditModulesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/diff:`
///  Return the diff of two modules
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DiffRequest)
pub struct DiffRequest {
    // message fields
    // @@protoc_insertion_point(field:DiffRequest.module1)
    pub module1: i64,
    // @@protoc_insertion_point(field:DiffRequest.module2)
    pub module2: i64,
    // @@protoc_insertion_point(field:DiffRequest.color_terminal)
    pub color_terminal: bool,
    // @@protoc_insertion_point(field:DiffRequest.with_context)
    pub with_context: bool,
    // special fields
    // @@protoc_insertion_point(special_field:DiffRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DiffRequest {
    fn default() -> &'a DiffRequest {
        <DiffRequest as ::protobuf::Message>::default_instance()
    }
}

impl DiffRequest {
    pub fn new() -> DiffRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module1",
            |m: &DiffRequest| { &m.module1 },
            |m: &mut DiffRequest| { &mut m.module1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module2",
            |m: &DiffRequest| { &m.module2 },
            |m: &mut DiffRequest| { &mut m.module2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_terminal",
            |m: &DiffRequest| { &m.color_terminal },
            |m: &mut DiffRequest| { &mut m.color_terminal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "with_context",
            |m: &DiffRequest| { &m.with_context },
            |m: &mut DiffRequest| { &mut m.with_context },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DiffRequest>(
            "DiffRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DiffRequest {
    const NAME: &'static str = "DiffRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.module1 = is.read_int64()?;
                },
                16 => {
                    self.module2 = is.read_int64()?;
                },
                24 => {
                    self.color_terminal = is.read_bool()?;
                },
                32 => {
                    self.with_context = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.module1 != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.module1);
        }
        if self.module2 != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.module2);
        }
        if self.color_terminal != false {
            my_size += 1 + 1;
        }
        if self.with_context != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.module1 != 0 {
            os.write_int64(1, self.module1)?;
        }
        if self.module2 != 0 {
            os.write_int64(2, self.module2)?;
        }
        if self.color_terminal != false {
            os.write_bool(3, self.color_terminal)?;
        }
        if self.with_context != false {
            os.write_bool(4, self.with_context)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DiffRequest {
        DiffRequest::new()
    }

    fn clear(&mut self) {
        self.module1 = 0;
        self.module2 = 0;
        self.color_terminal = false;
        self.with_context = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DiffRequest {
        static instance: DiffRequest = DiffRequest {
            module1: 0,
            module2: 0,
            color_terminal: false,
            with_context: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DiffRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DiffRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DiffRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiffRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to `DiffRequest`, contains a text representation of the difference
///  between the two specified modules.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DiffResponse)
pub struct DiffResponse {
    // message fields
    // @@protoc_insertion_point(field:DiffResponse.diff)
    pub diff: ::std::string::String,
    // @@protoc_insertion_point(field:DiffResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:DiffResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DiffResponse {
    fn default() -> &'a DiffResponse {
        <DiffResponse as ::protobuf::Message>::default_instance()
    }
}

impl DiffResponse {
    pub fn new() -> DiffResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "diff",
            |m: &DiffResponse| { &m.diff },
            |m: &mut DiffResponse| { &mut m.diff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &DiffResponse| { &m.error },
            |m: &mut DiffResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DiffResponse>(
            "DiffResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DiffResponse {
    const NAME: &'static str = "DiffResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.diff = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.diff.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.diff);
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.diff.is_empty() {
            os.write_string(1, &self.diff)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DiffResponse {
        DiffResponse::new()
    }

    fn clear(&mut self) {
        self.diff.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DiffResponse {
        static instance: DiffResponse = DiffResponse {
            diff: ::std::string::String::new(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DiffResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DiffResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DiffResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiffResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/validate:`
///  Return the failure report (if applicable) of a wasm module validation against a given checkfile.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ValidateModuleRequest)
pub struct ValidateModuleRequest {
    // message fields
    ///  the YAML checkfile (e.g. mod.yaml) bytes
    // @@protoc_insertion_point(field:ValidateModuleRequest.checkfile)
    pub checkfile: ::std::vec::Vec<u8>,
    // message oneof groups
    pub module_input: ::std::option::Option<validate_module_request::Module_input>,
    // special fields
    // @@protoc_insertion_point(special_field:ValidateModuleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidateModuleRequest {
    fn default() -> &'a ValidateModuleRequest {
        <ValidateModuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl ValidateModuleRequest {
    pub fn new() -> ValidateModuleRequest {
        ::std::default::Default::default()
    }

    // bytes module = 2;

    pub fn module(&self) -> &[u8] {
        match self.module_input {
            ::std::option::Option::Some(validate_module_request::Module_input::Module(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_module(&mut self) {
        self.module_input = ::std::option::Option::None;
    }

    pub fn has_module(&self) -> bool {
        match self.module_input {
            ::std::option::Option::Some(validate_module_request::Module_input::Module(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_module(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_input = ::std::option::Option::Some(validate_module_request::Module_input::Module(v))
    }

    // Mutable pointer to the field.
    pub fn mut_module(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(validate_module_request::Module_input::Module(_)) = self.module_input {
        } else {
            self.module_input = ::std::option::Option::Some(validate_module_request::Module_input::Module(::std::vec::Vec::new()));
        }
        match self.module_input {
            ::std::option::Option::Some(validate_module_request::Module_input::Module(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_module(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_module() {
            match self.module_input.take() {
                ::std::option::Option::Some(validate_module_request::Module_input::Module(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // int64 module_id = 3;

    pub fn module_id(&self) -> i64 {
        match self.module_input {
            ::std::option::Option::Some(validate_module_request::Module_input::ModuleId(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_module_id(&mut self) {
        self.module_input = ::std::option::Option::None;
    }

    pub fn has_module_id(&self) -> bool {
        match self.module_input {
            ::std::option::Option::Some(validate_module_request::Module_input::ModuleId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_module_id(&mut self, v: i64) {
        self.module_input = ::std::option::Option::Some(validate_module_request::Module_input::ModuleId(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "checkfile",
            |m: &ValidateModuleRequest| { &m.checkfile },
            |m: &mut ValidateModuleRequest| { &mut m.checkfile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "module",
            ValidateModuleRequest::has_module,
            ValidateModuleRequest::module,
            ValidateModuleRequest::set_module,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "module_id",
            ValidateModuleRequest::has_module_id,
            ValidateModuleRequest::module_id,
            ValidateModuleRequest::set_module_id,
        ));
        oneofs.push(validate_module_request::Module_input::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidateModuleRequest>(
            "ValidateModuleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidateModuleRequest {
    const NAME: &'static str = "ValidateModuleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.checkfile = is.read_bytes()?;
                },
                18 => {
                    self.module_input = ::std::option::Option::Some(validate_module_request::Module_input::Module(is.read_bytes()?));
                },
                24 => {
                    self.module_input = ::std::option::Option::Some(validate_module_request::Module_input::ModuleId(is.read_int64()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.checkfile.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.checkfile);
        }
        if let ::std::option::Option::Some(ref v) = self.module_input {
            match v {
                &validate_module_request::Module_input::Module(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &validate_module_request::Module_input::ModuleId(v) => {
                    my_size += ::protobuf::rt::int64_size(3, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.checkfile.is_empty() {
            os.write_bytes(1, &self.checkfile)?;
        }
        if let ::std::option::Option::Some(ref v) = self.module_input {
            match v {
                &validate_module_request::Module_input::Module(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &validate_module_request::Module_input::ModuleId(v) => {
                    os.write_int64(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidateModuleRequest {
        ValidateModuleRequest::new()
    }

    fn clear(&mut self) {
        self.checkfile.clear();
        self.module_input = ::std::option::Option::None;
        self.module_input = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidateModuleRequest {
        static instance: ValidateModuleRequest = ValidateModuleRequest {
            checkfile: ::std::vec::Vec::new(),
            module_input: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidateModuleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidateModuleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidateModuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidateModuleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ValidateModuleRequest`
pub mod validate_module_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:ValidateModuleRequest.module_input)
    pub enum Module_input {
        // @@protoc_insertion_point(oneof_field:ValidateModuleRequest.module)
        Module(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:ValidateModuleRequest.module_id)
        ModuleId(i64),
    }

    impl ::protobuf::Oneof for Module_input {
    }

    impl ::protobuf::OneofFull for Module_input {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ValidateModuleRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("module_input").unwrap()).clone()
        }
    }

    impl Module_input {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Module_input>("module_input")
        }
    }
}

///  The failure report produced by the validation check (encoded in JSON).
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ValidateModuleResponse)
pub struct ValidateModuleResponse {
    // message fields
    // @@protoc_insertion_point(field:ValidateModuleResponse.invalid_module_report)
    pub invalid_module_report: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ValidateModuleResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:ValidateModuleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidateModuleResponse {
    fn default() -> &'a ValidateModuleResponse {
        <ValidateModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl ValidateModuleResponse {
    pub fn new() -> ValidateModuleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "invalid_module_report",
            |m: &ValidateModuleResponse| { &m.invalid_module_report },
            |m: &mut ValidateModuleResponse| { &mut m.invalid_module_report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &ValidateModuleResponse| { &m.error },
            |m: &mut ValidateModuleResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidateModuleResponse>(
            "ValidateModuleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidateModuleResponse {
    const NAME: &'static str = "ValidateModuleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invalid_module_report = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.invalid_module_report.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.invalid_module_report);
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.invalid_module_report.is_empty() {
            os.write_bytes(1, &self.invalid_module_report)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidateModuleResponse {
        ValidateModuleResponse::new()
    }

    fn clear(&mut self) {
        self.invalid_module_report.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidateModuleResponse {
        static instance: ValidateModuleResponse = ValidateModuleResponse {
            invalid_module_report: ::std::vec::Vec::new(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidateModuleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidateModuleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidateModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidateModuleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Used to type the arguments and return types from wasm elements such as import
///  and export functions.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ValType)
pub enum ValType {
    // @@protoc_insertion_point(enum_value:ValType.I32)
    I32 = 0,
    // @@protoc_insertion_point(enum_value:ValType.I64)
    I64 = 1,
    // @@protoc_insertion_point(enum_value:ValType.F32)
    F32 = 2,
    // @@protoc_insertion_point(enum_value:ValType.F64)
    F64 = 3,
    // @@protoc_insertion_point(enum_value:ValType.V128)
    V128 = 4,
    // @@protoc_insertion_point(enum_value:ValType.FuncRef)
    FuncRef = 5,
    // @@protoc_insertion_point(enum_value:ValType.ExternRef)
    ExternRef = 6,
}

impl ::protobuf::Enum for ValType {
    const NAME: &'static str = "ValType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ValType> {
        match value {
            0 => ::std::option::Option::Some(ValType::I32),
            1 => ::std::option::Option::Some(ValType::I64),
            2 => ::std::option::Option::Some(ValType::F32),
            3 => ::std::option::Option::Some(ValType::F64),
            4 => ::std::option::Option::Some(ValType::V128),
            5 => ::std::option::Option::Some(ValType::FuncRef),
            6 => ::std::option::Option::Some(ValType::ExternRef),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ValType] = &[
        ValType::I32,
        ValType::I64,
        ValType::F32,
        ValType::F64,
        ValType::V128,
        ValType::FuncRef,
        ValType::ExternRef,
    ];
}

impl ::protobuf::EnumFull for ValType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ValType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ValType {
    fn default() -> Self {
        ValType::I32
    }
}

impl ValType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ValType>("ValType")
    }
}

///  The language (or most similar match) used to produce a wasm module.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SourceLanguage)
pub enum SourceLanguage {
    // @@protoc_insertion_point(enum_value:SourceLanguage.Unknown)
    Unknown = 0,
    // @@protoc_insertion_point(enum_value:SourceLanguage.Rust)
    Rust = 1,
    // @@protoc_insertion_point(enum_value:SourceLanguage.Go)
    Go = 2,
    // @@protoc_insertion_point(enum_value:SourceLanguage.C)
    C = 3,
    // @@protoc_insertion_point(enum_value:SourceLanguage.Cpp)
    Cpp = 4,
    // @@protoc_insertion_point(enum_value:SourceLanguage.AssemblyScript)
    AssemblyScript = 5,
}

impl ::protobuf::Enum for SourceLanguage {
    const NAME: &'static str = "SourceLanguage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SourceLanguage> {
        match value {
            0 => ::std::option::Option::Some(SourceLanguage::Unknown),
            1 => ::std::option::Option::Some(SourceLanguage::Rust),
            2 => ::std::option::Option::Some(SourceLanguage::Go),
            3 => ::std::option::Option::Some(SourceLanguage::C),
            4 => ::std::option::Option::Some(SourceLanguage::Cpp),
            5 => ::std::option::Option::Some(SourceLanguage::AssemblyScript),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SourceLanguage] = &[
        SourceLanguage::Unknown,
        SourceLanguage::Rust,
        SourceLanguage::Go,
        SourceLanguage::C,
        SourceLanguage::Cpp,
        SourceLanguage::AssemblyScript,
    ];
}

impl ::protobuf::EnumFull for SourceLanguage {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SourceLanguage").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SourceLanguage {
    fn default() -> Self {
        SourceLanguage::Unknown
    }
}

impl SourceLanguage {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SourceLanguage>("SourceLanguage")
    }
}

///  The direction, descending or ascending, of the sort operation.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Direction)
pub enum Direction {
    // @@protoc_insertion_point(enum_value:Direction.Desc)
    Desc = 0,
    // @@protoc_insertion_point(enum_value:Direction.Asc)
    Asc = 1,
}

impl ::protobuf::Enum for Direction {
    const NAME: &'static str = "Direction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Direction> {
        match value {
            0 => ::std::option::Option::Some(Direction::Desc),
            1 => ::std::option::Option::Some(Direction::Asc),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Direction] = &[
        Direction::Desc,
        Direction::Asc,
    ];
}

impl ::protobuf::EnumFull for Direction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Direction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Direction {
    fn default() -> Self {
        Direction::Desc
    }
}

impl Direction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Direction>("Direction")
    }
}

///  The field within the Module schema that is used as the sorting dimension.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Field)
pub enum Field {
    // @@protoc_insertion_point(enum_value:Field.CreatedAt)
    CreatedAt = 0,
    // @@protoc_insertion_point(enum_value:Field.Name)
    Name = 1,
    // @@protoc_insertion_point(enum_value:Field.Size)
    Size = 2,
    // @@protoc_insertion_point(enum_value:Field.Language)
    Language = 3,
    // @@protoc_insertion_point(enum_value:Field.ImportsCount)
    ImportsCount = 4,
    // @@protoc_insertion_point(enum_value:Field.ExportsCount)
    ExportsCount = 5,
    // @@protoc_insertion_point(enum_value:Field.Sha256)
    Sha256 = 6,
    // @@protoc_insertion_point(enum_value:Field.Complexity)
    Complexity = 7,
}

impl ::protobuf::Enum for Field {
    const NAME: &'static str = "Field";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Field> {
        match value {
            0 => ::std::option::Option::Some(Field::CreatedAt),
            1 => ::std::option::Option::Some(Field::Name),
            2 => ::std::option::Option::Some(Field::Size),
            3 => ::std::option::Option::Some(Field::Language),
            4 => ::std::option::Option::Some(Field::ImportsCount),
            5 => ::std::option::Option::Some(Field::ExportsCount),
            6 => ::std::option::Option::Some(Field::Sha256),
            7 => ::std::option::Option::Some(Field::Complexity),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Field] = &[
        Field::CreatedAt,
        Field::Name,
        Field::Size,
        Field::Language,
        Field::ImportsCount,
        Field::ExportsCount,
        Field::Sha256,
        Field::Complexity,
    ];
}

impl ::protobuf::EnumFull for Field {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Field").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Field {
    fn default() -> Self {
        Field::CreatedAt
    }
}

impl Field {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Field>("Field")
    }
}

///  Represents the expected outcome of an AuditModulesRequest. If PASS is provided, then
///  the audit returns modules which conform to the checkfile. If FAIL is provided, then
///  the audit returns modules which do not conform to the checkfile.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:AuditOutcome)
pub enum AuditOutcome {
    // @@protoc_insertion_point(enum_value:AuditOutcome.PASS)
    PASS = 0,
    // @@protoc_insertion_point(enum_value:AuditOutcome.FAIL)
    FAIL = 1,
}

impl ::protobuf::Enum for AuditOutcome {
    const NAME: &'static str = "AuditOutcome";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuditOutcome> {
        match value {
            0 => ::std::option::Option::Some(AuditOutcome::PASS),
            1 => ::std::option::Option::Some(AuditOutcome::FAIL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AuditOutcome] = &[
        AuditOutcome::PASS,
        AuditOutcome::FAIL,
    ];
}

impl ::protobuf::EnumFull for AuditOutcome {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AuditOutcome").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AuditOutcome {
    fn default() -> Self {
        AuditOutcome::PASS
    }
}

impl AuditOutcome {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AuditOutcome>("AuditOutcome")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12proto/v1/api.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"d\n\x08\
    Function\x12\x20\n\x06params\x18\x01\x20\x03(\x0e2\x08.ValTypeR\x06param\
    s\x12\"\n\x07results\x18\x02\x20\x03(\x0e2\x08.ValTypeR\x07results\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\"H\n\x06Import\x12\x1f\n\x0bm\
    odule_name\x18\x01\x20\x01(\tR\nmoduleName\x12\x1d\n\x04func\x18\x02\x20\
    \x01(\x0b2\t.FunctionR\x04func\"'\n\x06Export\x12\x1d\n\x04func\x18\x01\
    \x20\x01(\x0b2\t.FunctionR\x04func\"\xfc\x03\n\x06Module\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x03R\x02id\x12\x12\n\x04hash\x18\x03\x20\x01(\tR\x04ha\
    sh\x12!\n\x07imports\x18\x04\x20\x03(\x0b2\x07.ImportR\x07imports\x12!\n\
    \x07exports\x18\x05\x20\x03(\x0b2\x07.ExportR\x07exports\x12\x12\n\x04si\
    ze\x18\x06\x20\x01(\x04R\x04size\x12\x1a\n\x08location\x18\x07\x20\x01(\
    \tR\x08location\x128\n\x0fsource_language\x18\x08\x20\x01(\x0e2\x0f.Sour\
    ceLanguageR\x0esourceLanguage\x121\n\x08metadata\x18\t\x20\x03(\x0b2\x15\
    .Module.MetadataEntryR\x08metadata\x12;\n\x0binserted_at\x18\n\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\ninsertedAt\x12\x18\n\x07strings\
    \x18\x0b\x20\x03(\tR\x07strings\x12#\n\ncomplexity\x18\r\x20\x01(\rH\0R\
    \ncomplexity\x88\x01\x01\x12\x19\n\x05graph\x18\x0e\x20\x01(\x0cH\x01R\
    \x05graph\x88\x01\x01\x1a;\n\rMetadataEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01B\r\n\x0b_complexityB\x08\n\x06_graph\"5\n\x05Error\x12\x12\n\x04cod\
    e\x18\x01\x20\x01(\x05R\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\tR\
    \x07message\":\n\nPagination\x12\x14\n\x05limit\x18\x01\x20\x01(\rR\x05l\
    imit\x12\x16\n\x06offset\x18\x02\x20\x01(\rR\x06offset\"N\n\x04Sort\x12(\
    \n\tdirection\x18\x01\x20\x01(\x0e2\n.DirectionR\tdirection\x12\x1c\n\
    \x05field\x18\x02\x20\x01(\x0e2\x06.FieldR\x05field\"\xd4\x01\n\x13Creat\
    eModuleRequest\x12\x12\n\x04wasm\x18\x01\x20\x01(\x0cR\x04wasm\x12>\n\
    \x08metadata\x18\x02\x20\x03(\x0b2\".CreateModuleRequest.MetadataEntryR\
    \x08metadata\x12\x1f\n\x08location\x18\x03\x20\x01(\tH\0R\x08location\
    \x88\x01\x01\x1a;\n\rMetadataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x0b\n\
    \t_location\"t\n\x14CreateModuleResponse\x12\x1b\n\tmodule_id\x18\x01\
    \x20\x01(\x03R\x08moduleId\x12\x12\n\x04hash\x18\x02\x20\x01(\tR\x04hash\
    \x12!\n\x05error\x18\x03\x20\x01(\x0b2\x06.ErrorH\0R\x05error\x88\x01\
    \x01B\x08\n\x06_error\"/\n\x10GetModuleRequest\x12\x1b\n\tmodule_id\x18\
    \x01\x20\x01(\x03R\x08moduleId\"a\n\x11GetModuleResponse\x12\x1f\n\x06mo\
    dule\x18\x01\x20\x01(\x0b2\x07.ModuleR\x06module\x12!\n\x05error\x18\x02\
    \x20\x01(\x0b2\x06.ErrorH\0R\x05error\x88\x01\x01B\x08\n\x06_error\"\\\n\
    \x12ListModulesRequest\x12+\n\npagination\x18\x01\x20\x01(\x0b2\x0b.Pagi\
    nationR\npagination\x12\x19\n\x04sort\x18\x02\x20\x01(\x0b2\x05.SortR\
    \x04sort\"\xc3\x01\n\x13ListModulesResponse\x12!\n\x07modules\x18\x01\
    \x20\x03(\x0b2\x07.ModuleR\x07modules\x12+\n\npagination\x18\x02\x20\x01\
    (\x0b2\x0b.PaginationR\npagination\x12\x14\n\x05total\x18\x03\x20\x01(\
    \x04R\x05total\x12\x19\n\x04sort\x18\x04\x20\x01(\x0b2\x05.SortR\x04sort\
    \x12!\n\x05error\x18\x05\x20\x01(\x0b2\x06.ErrorH\0R\x05error\x88\x01\
    \x01B\x08\n\x06_error\"\x80\x07\n\x14SearchModulesRequest\x12\x13\n\x02i\
    d\x18\x01\x20\x01(\x03H\0R\x02id\x88\x01\x01\x12\x17\n\x04hash\x18\x03\
    \x20\x01(\tH\x01R\x04hash\x88\x01\x01\x12!\n\x07imports\x18\x04\x20\x03(\
    \x0b2\x07.ImportR\x07imports\x12!\n\x07exports\x18\x05\x20\x03(\x0b2\x07\
    .ExportR\x07exports\x12\x1e\n\x08min_size\x18\x06\x20\x01(\x04H\x02R\x07\
    minSize\x88\x01\x01\x12\x1e\n\x08max_size\x18\x07\x20\x01(\x04H\x03R\x07\
    maxSize\x88\x01\x01\x12\x1f\n\x08location\x18\x08\x20\x01(\tH\x04R\x08lo\
    cation\x88\x01\x01\x12=\n\x0fsource_language\x18\t\x20\x01(\x0e2\x0f.Sou\
    rceLanguageH\x05R\x0esourceLanguage\x88\x01\x01\x12?\n\x08metadata\x18\n\
    \x20\x03(\x0b2#.SearchModulesRequest.MetadataEntryR\x08metadata\x12H\n\
    \x0finserted_before\x18\x0b\x20\x01(\x0b2\x1a.google.protobuf.TimestampH\
    \x06R\x0einsertedBefore\x88\x01\x01\x12F\n\x0einserted_after\x18\x0c\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampH\x07R\rinsertedAfter\x88\x01\
    \x01\x12\x18\n\x07strings\x18\r\x20\x03(\tR\x07strings\x12(\n\rfunction_\
    name\x18\x0e\x20\x01(\tH\x08R\x0cfunctionName\x88\x01\x01\x12$\n\x0bmodu\
    le_name\x18\x0f\x20\x01(\tH\tR\nmoduleName\x88\x01\x01\x12+\n\npaginatio\
    n\x18\x10\x20\x01(\x0b2\x0b.PaginationR\npagination\x12\x19\n\x04sort\
    \x18\x11\x20\x01(\x0b2\x05.SortR\x04sort\x1a;\n\rMetadataEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01B\x05\n\x03_idB\x07\n\x05_hashB\x0b\n\t_min_sizeB\
    \x0b\n\t_max_sizeB\x0b\n\t_locationB\x12\n\x10_source_languageB\x12\n\
    \x10_inserted_beforeB\x11\n\x0f_inserted_afterB\x10\n\x0e_function_nameB\
    \x0e\n\x0c_module_name\"\xc5\x01\n\x15SearchModulesResponse\x12!\n\x07mo\
    dules\x18\x01\x20\x03(\x0b2\x07.ModuleR\x07modules\x12+\n\npagination\
    \x18\x02\x20\x01(\x0b2\x0b.PaginationR\npagination\x12\x14\n\x05total\
    \x18\x03\x20\x01(\x04R\x05total\x12\x19\n\x04sort\x18\x04\x20\x01(\x0b2\
    \x05.SortR\x04sort\x12!\n\x05error\x18\x05\x20\x01(\x0b2\x06.ErrorH\0R\
    \x05error\x88\x01\x01B\x08\n\x06_error\"5\n\x14DeleteModulesRequest\x12\
    \x1d\n\nmodule_ids\x18\x01\x20\x03(\x03R\tmoduleIds\"\xd5\x01\n\x15Delet\
    eModulesResponse\x12N\n\x0emodule_id_hash\x18\x01\x20\x03(\x0b2(.DeleteM\
    odulesResponse.ModuleIdHashEntryR\x0cmoduleIdHash\x12!\n\x05error\x18\
    \x02\x20\x01(\x0b2\x06.ErrorH\0R\x05error\x88\x01\x01\x1a?\n\x11ModuleId\
    HashEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03key\x12\x14\n\x05val\
    ue\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x08\n\x06_error\"\x89\x01\n\
    \x13AuditModulesRequest\x12\x1c\n\tcheckfile\x18\x01\x20\x01(\x0cR\tchec\
    kfile\x12'\n\x07outcome\x18\x02\x20\x01(\x0e2\r.AuditOutcomeR\x07outcome\
    \x12+\n\npagination\x18\x03\x20\x01(\x0b2\x0b.PaginationR\npagination\"\
    \xb2\x02\n\x14AuditModulesResponse\x12b\n\x15invalid_module_report\x18\
    \x01\x20\x03(\x0b2..AuditModulesResponse.InvalidModuleReportEntryR\x13in\
    validModuleReport\x12+\n\npagination\x18\x02\x20\x01(\x0b2\x0b.Paginatio\
    nR\npagination\x12\x14\n\x05total\x18\x03\x20\x01(\x04R\x05total\x12!\n\
    \x05error\x18\x04\x20\x01(\x0b2\x06.ErrorH\0R\x05error\x88\x01\x01\x1aF\
    \n\x18InvalidModuleReportEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value:\x028\x01B\x08\
    \n\x06_error\"\x8b\x01\n\x0bDiffRequest\x12\x18\n\x07module1\x18\x01\x20\
    \x01(\x03R\x07module1\x12\x18\n\x07module2\x18\x02\x20\x01(\x03R\x07modu\
    le2\x12%\n\x0ecolor_terminal\x18\x03\x20\x01(\x08R\rcolorTerminal\x12!\n\
    \x0cwith_context\x18\x04\x20\x01(\x08R\x0bwithContext\"O\n\x0cDiffRespon\
    se\x12\x12\n\x04diff\x18\x01\x20\x01(\tR\x04diff\x12!\n\x05error\x18\x02\
    \x20\x01(\x0b2\x06.ErrorH\0R\x05error\x88\x01\x01B\x08\n\x06_error\"~\n\
    \x15ValidateModuleRequest\x12\x1c\n\tcheckfile\x18\x01\x20\x01(\x0cR\tch\
    eckfile\x12\x18\n\x06module\x18\x02\x20\x01(\x0cH\0R\x06module\x12\x1d\n\
    \tmodule_id\x18\x03\x20\x01(\x03H\0R\x08moduleIdB\x0e\n\x0cmodule_input\
    \"y\n\x16ValidateModuleResponse\x122\n\x15invalid_module_report\x18\x01\
    \x20\x01(\x0cR\x13invalidModuleReport\x12!\n\x05error\x18\x02\x20\x01(\
    \x0b2\x06.ErrorH\0R\x05error\x88\x01\x01B\x08\n\x06_error*S\n\x07ValType\
    \x12\x07\n\x03I32\x10\0\x12\x07\n\x03I64\x10\x01\x12\x07\n\x03F32\x10\
    \x02\x12\x07\n\x03F64\x10\x03\x12\x08\n\x04V128\x10\x04\x12\x0b\n\x07Fun\
    cRef\x10\x05\x12\r\n\tExternRef\x10\x06*S\n\x0eSourceLanguage\x12\x0b\n\
    \x07Unknown\x10\0\x12\x08\n\x04Rust\x10\x01\x12\x06\n\x02Go\x10\x02\x12\
    \x05\n\x01C\x10\x03\x12\x07\n\x03Cpp\x10\x04\x12\x12\n\x0eAssemblyScript\
    \x10\x05*\x1e\n\tDirection\x12\x08\n\x04Desc\x10\0\x12\x07\n\x03Asc\x10\
    \x01*x\n\x05Field\x12\r\n\tCreatedAt\x10\0\x12\x08\n\x04Name\x10\x01\x12\
    \x08\n\x04Size\x10\x02\x12\x0c\n\x08Language\x10\x03\x12\x10\n\x0cImport\
    sCount\x10\x04\x12\x10\n\x0cExportsCount\x10\x05\x12\n\n\x06Sha256\x10\
    \x06\x12\x0e\n\nComplexity\x10\x07*\"\n\x0cAuditOutcome\x12\x08\n\x04PAS\
    S\x10\0\x12\x08\n\x04FAIL\x10\x01J\x90^\n\x07\x12\x05\0\0\x99\x02\x01\n\
    \x08\n\x01\x0c\x12\x03\0\0\x12\n\t\n\x02\x03\0\x12\x03\x02\0)\nr\n\x02\
    \x05\0\x12\x04\x06\0\x0e\x01\x1af\x20Used\x20to\x20type\x20the\x20argume\
    nts\x20and\x20return\x20types\x20from\x20wasm\x20elements\x20such\x20as\
    \x20import\n\x20and\x20export\x20functions.\n\n\n\n\x03\x05\0\x01\x12\
    \x03\x06\x05\x0c\n\x0b\n\x04\x05\0\x02\0\x12\x03\x07\x02\n\n\x0c\n\x05\
    \x05\0\x02\0\x01\x12\x03\x07\x02\x05\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\
    \x07\x08\t\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x08\x02\n\n\x0c\n\x05\x05\0\
    \x02\x01\x01\x12\x03\x08\x02\x05\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\
    \x08\x08\t\n\x0b\n\x04\x05\0\x02\x02\x12\x03\t\x02\n\n\x0c\n\x05\x05\0\
    \x02\x02\x01\x12\x03\t\x02\x05\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\t\
    \x08\t\n\x0b\n\x04\x05\0\x02\x03\x12\x03\n\x02\n\n\x0c\n\x05\x05\0\x02\
    \x03\x01\x12\x03\n\x02\x05\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\n\x08\t\
    \n\x0b\n\x04\x05\0\x02\x04\x12\x03\x0b\x02\x0b\n\x0c\n\x05\x05\0\x02\x04\
    \x01\x12\x03\x0b\x02\x06\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x0b\t\n\n\
    \x0b\n\x04\x05\0\x02\x05\x12\x03\x0c\x02\x0e\n\x0c\n\x05\x05\0\x02\x05\
    \x01\x12\x03\x0c\x02\t\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x0c\x0c\r\n\
    \x0b\n\x04\x05\0\x02\x06\x12\x03\r\x02\x10\n\x0c\n\x05\x05\0\x02\x06\x01\
    \x12\x03\r\x02\x0b\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\r\x0e\x0f\nL\n\
    \x02\x04\0\x12\x04\x11\0\x15\x01\x1a@\x20Contained\x20by\x20an\x20import\
    \x20or\x20export\x20element\x20within\x20a\x20wasm\x20binary.\n\n\n\n\
    \x03\x04\0\x01\x12\x03\x11\x08\x10\n\x0b\n\x04\x04\0\x02\0\x12\x03\x12\
    \x02\x1e\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x12\x02\n\n\x0c\n\x05\x04\0\
    \x02\0\x06\x12\x03\x12\x0b\x12\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x12\
    \x13\x19\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x12\x1c\x1d\n\x0b\n\x04\x04\
    \0\x02\x01\x12\x03\x13\x02\x1f\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x13\
    \x02\n\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x13\x0b\x12\n\x0c\n\x05\x04\
    \0\x02\x01\x01\x12\x03\x13\x13\x1a\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\
    \x13\x1d\x1e\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x14\x02\x12\n\x0c\n\x05\
    \x04\0\x02\x02\x05\x12\x03\x14\x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\
    \x03\x14\t\r\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x14\x10\x11\n\x8d\x01\
    \n\x02\x04\x01\x12\x04\x19\0\x1c\x01\x1a\x80\x01\x20A\x20function\x20and\
    \x20module\x20namespace\x20that\x20is\x20defined\x20outside\x20of\x20the\
    \x20current\n\x20module,\x20and\x20referenced\x20&\x20called\x20by\x20th\
    e\x20current\x20module.\n\n\n\n\x03\x04\x01\x01\x12\x03\x19\x08\x0e\n\
    \x0b\n\x04\x04\x01\x02\0\x12\x03\x1a\x02\x19\n\x0c\n\x05\x04\x01\x02\0\
    \x05\x12\x03\x1a\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x1a\t\x14\
    \n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x1a\x17\x18\n\x0b\n\x04\x04\x01\
    \x02\x01\x12\x03\x1b\x02\x14\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03\x1b\
    \x02\n\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x1b\x0b\x0f\n\x0c\n\x05\
    \x04\x01\x02\x01\x03\x12\x03\x1b\x12\x13\nu\n\x02\x04\x02\x12\x03\x20\0%\
    \x1aj\x20A\x20function\x20that\x20is\x20defined\x20inside\x20the\x20curr\
    ent\x20module,\x20made\x20available\x20to\n\x20outside\x20modules\x20/\
    \x20environments.\n\n\n\n\x03\x04\x02\x01\x12\x03\x20\x08\x0e\n\x0b\n\
    \x04\x04\x02\x02\0\x12\x03\x20\x11#\n\x0c\n\x05\x04\x02\x02\0\x06\x12\
    \x03\x20\x11\x19\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x20\x1a\x1e\n\x0c\
    \n\x05\x04\x02\x02\0\x03\x12\x03\x20!\"\nQ\n\x02\x05\x01\x12\x04#\0*\x01\
    \x1aE\x20The\x20language\x20(or\x20most\x20similar\x20match)\x20used\x20\
    to\x20produce\x20a\x20wasm\x20module.\n\n\n\n\x03\x05\x01\x01\x12\x03#\
    \x05\x13\n\x0b\n\x04\x05\x01\x02\0\x12\x03$\x02\x0e\n\x0c\n\x05\x05\x01\
    \x02\0\x01\x12\x03$\x02\t\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03$\x0c\r\n\
    \x0b\n\x04\x05\x01\x02\x01\x12\x03%\x02\x0b\n\x0c\n\x05\x05\x01\x02\x01\
    \x01\x12\x03%\x02\x06\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03%\t\n\n\x0b\
    \n\x04\x05\x01\x02\x02\x12\x03&\x02\t\n\x0c\n\x05\x05\x01\x02\x02\x01\
    \x12\x03&\x02\x04\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03&\x07\x08\n\x0b\
    \n\x04\x05\x01\x02\x03\x12\x03'\x02\x08\n\x0c\n\x05\x05\x01\x02\x03\x01\
    \x12\x03'\x02\x03\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03'\x06\x07\n\x0b\
    \n\x04\x05\x01\x02\x04\x12\x03(\x02\n\n\x0c\n\x05\x05\x01\x02\x04\x01\
    \x12\x03(\x02\x05\n\x0c\n\x05\x05\x01\x02\x04\x02\x12\x03(\x08\t\n\x0b\n\
    \x04\x05\x01\x02\x05\x12\x03)\x02\x15\n\x0c\n\x05\x05\x01\x02\x05\x01\
    \x12\x03)\x02\x10\n\x0c\n\x05\x05\x01\x02\x05\x02\x12\x03)\x13\x14\nk\n\
    \x02\x04\x03\x12\x04.\0J\x01\x1a_\x20Details\x20about\x20a\x20wasm\x20mo\
    dule,\x20either\x20extracted\x20directly\x20from\x20the\x20binary,\x20or\
    \n\x20inferred\x20somehow.\n\n\n\n\x03\x04\x03\x01\x12\x03.\x08\x0e\n=\n\
    \x04\x04\x03\x02\0\x12\x030\x02\x0f\x1a0\x20ID\x20for\x20this\x20module,\
    \x20generated\x20by\x20the\x20database.\n\n\x0c\n\x05\x04\x03\x02\0\x05\
    \x12\x030\x02\x07\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x030\x08\n\n\x0c\n\
    \x05\x04\x03\x02\0\x03\x12\x030\r\x0e\n3\n\x04\x04\x03\x02\x01\x12\x032\
    \x02\x12\x1a&\x20sha256\x20hash\x20of\x20the\x20modules\x20raw\x20bytes\
    \n\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x032\x02\x08\n\x0c\n\x05\x04\x03\
    \x02\x01\x01\x12\x032\t\r\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x032\x10\
    \x11\n\x81\x01\n\x04\x04\x03\x02\x02\x12\x035\x02\x1e\x1at\x20function\
    \x20imports\x20called\x20by\x20the\x20module\x20(see:\n\x20<https://gith\
    ub.com/WebAssembly/design/blob/main/Modules.md#imports)>\n\n\x0c\n\x05\
    \x04\x03\x02\x02\x04\x12\x035\x02\n\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\
    \x035\x0b\x11\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x035\x12\x19\n\x0c\n\
    \x05\x04\x03\x02\x02\x03\x12\x035\x1c\x1d\n\x83\x01\n\x04\x04\x03\x02\
    \x03\x12\x038\x02\x1e\x1av\x20function\x20exports\x20provided\x20by\x20t\
    he\x20module\x20(see:\n\x20<https://github.com/WebAssembly/design/blob/m\
    ain/Modules.md#exports)>\n\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x038\x02\
    \n\n\x0c\n\x05\x04\x03\x02\x03\x06\x12\x038\x0b\x11\n\x0c\n\x05\x04\x03\
    \x02\x03\x01\x12\x038\x12\x19\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x038\
    \x1c\x1d\n*\n\x04\x04\x03\x02\x04\x12\x03:\x02\x12\x1a\x1d\x20size\x20in\
    \x20bytes\x20of\x20the\x20module\n\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\
    \x03:\x02\x08\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03:\t\r\n\x0c\n\x05\
    \x04\x03\x02\x04\x03\x12\x03:\x10\x11\n,\n\x04\x04\x03\x02\x05\x12\x03<\
    \x02\x16\x1a\x1f\x20path\x20or\x20locator\x20to\x20the\x20module\n\n\x0c\
    \n\x05\x04\x03\x02\x05\x05\x12\x03<\x02\x08\n\x0c\n\x05\x04\x03\x02\x05\
    \x01\x12\x03<\t\x11\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x03<\x14\x15\n?\
    \n\x04\x04\x03\x02\x06\x12\x03>\x02%\x1a2\x20programming\x20language\x20\
    used\x20to\x20produce\x20this\x20module\n\n\x0c\n\x05\x04\x03\x02\x06\
    \x06\x12\x03>\x02\x10\n\x0c\n\x05\x04\x03\x02\x06\x01\x12\x03>\x11\x20\n\
    \x0c\n\x05\x04\x03\x02\x06\x03\x12\x03>#$\nI\n\x04\x04\x03\x02\x07\x12\
    \x03@\x02#\x1a<\x20arbitrary\x20metadata\x20provided\x20by\x20the\x20ope\
    rator\x20of\x20this\x20module\n\n\x0c\n\x05\x04\x03\x02\x07\x06\x12\x03@\
    \x02\x15\n\x0c\n\x05\x04\x03\x02\x07\x01\x12\x03@\x16\x1e\n\x0c\n\x05\
    \x04\x03\x02\x07\x03\x12\x03@!\"\n?\n\x04\x04\x03\x02\x08\x12\x03B\x02-\
    \x1a2\x20timestamp\x20when\x20this\x20module\x20was\x20loaded\x20and\x20\
    stored\n\n\x0c\n\x05\x04\x03\x02\x08\x06\x12\x03B\x02\x1b\n\x0c\n\x05\
    \x04\x03\x02\x08\x01\x12\x03B\x1c'\n\x0c\n\x05\x04\x03\x02\x08\x03\x12\
    \x03B*,\nZ\n\x04\x04\x03\x02\t\x12\x03D\x02\x1f\x1aM\x20the\x20interned\
    \x20strings\x20stored\x20in\x20the\x20wasm\x20binary\x20(panic/abort\x20\
    messages,\x20etc.)\n\n\x0c\n\x05\x04\x03\x02\t\x04\x12\x03D\x02\n\n\x0c\
    \n\x05\x04\x03\x02\t\x05\x12\x03D\x0b\x11\n\x0c\n\x05\x04\x03\x02\t\x01\
    \x12\x03D\x12\x19\n\x0c\n\x05\x04\x03\x02\t\x03\x12\x03D\x1c\x1e\nu\n\
    \x04\x04\x03\x02\n\x12\x03G\x02\"\x1ah\x20the\x20cyclomatic\x20complexit\
    y\n\x20(<https://en.wikipedia.org/wiki/Cyclomatic_complexity>)\x20of\x20\
    the\x20instructions\n\n\x0c\n\x05\x04\x03\x02\n\x04\x12\x03G\x02\n\n\x0c\
    \n\x05\x04\x03\x02\n\x05\x12\x03G\x0b\x11\n\x0c\n\x05\x04\x03\x02\n\x01\
    \x12\x03G\x12\x1c\n\x0c\n\x05\x04\x03\x02\n\x03\x12\x03G\x1f!\n2\n\x04\
    \x04\x03\x02\x0b\x12\x03I\x02\x1c\x1a%\x20the\x20serialized\x20graph\x20\
    in\x20json\x20format\n\n\x0c\n\x05\x04\x03\x02\x0b\x04\x12\x03I\x02\n\n\
    \x0c\n\x05\x04\x03\x02\x0b\x05\x12\x03I\x0b\x10\n\x0c\n\x05\x04\x03\x02\
    \x0b\x01\x12\x03I\x11\x16\n\x0c\n\x05\x04\x03\x02\x0b\x03\x12\x03I\x19\
    \x1b\n?\n\x02\x04\x04\x12\x04M\0P\x01\x1a3\x20An\x20error\x20message\x20\
    indicating\x20a\x20problem\x20in\x20the\x20API.\n\n\n\n\x03\x04\x04\x01\
    \x12\x03M\x08\r\n\x0b\n\x04\x04\x04\x02\0\x12\x03N\x02\x11\n\x0c\n\x05\
    \x04\x04\x02\0\x05\x12\x03N\x02\x07\n\x0c\n\x05\x04\x04\x02\0\x01\x12\
    \x03N\x08\x0c\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03N\x0f\x10\n\x0b\n\x04\
    \x04\x04\x02\x01\x12\x03O\x02\x15\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\
    \x03O\x02\x08\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03O\t\x10\n\x0c\n\x05\
    \x04\x04\x02\x01\x03\x12\x03O\x13\x14\n]\n\x02\x04\x05\x12\x04T\0W\x01\
    \x1aQ\x20Control/limit\x20the\x20way\x20results\x20are\x20paginated\x20w\
    hen\x20working\x20with\x20large\n\x20responses.\n\n\n\n\x03\x04\x05\x01\
    \x12\x03T\x08\x12\n\x0b\n\x04\x04\x05\x02\0\x12\x03U\x02\x13\n\x0c\n\x05\
    \x04\x05\x02\0\x05\x12\x03U\x02\x08\n\x0c\n\x05\x04\x05\x02\0\x01\x12\
    \x03U\t\x0e\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03U\x11\x12\n\x0b\n\x04\
    \x04\x05\x02\x01\x12\x03V\x02\x14\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\
    \x03V\x02\x08\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03V\t\x0f\n\x0c\n\x05\
    \x04\x05\x02\x01\x03\x12\x03V\x12\x13\n8\n\x02\x04\x06\x12\x04Z\0]\x01\
    \x1a,\x20Determine\x20how\x20to\x20sort\x20results\x20from\x20the\x20API\
    \n\n\n\n\x03\x04\x06\x01\x12\x03Z\x08\x0c\n\x0b\n\x04\x04\x06\x02\0\x12\
    \x03[\x02\x1a\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03[\x02\x0b\n\x0c\n\x05\
    \x04\x06\x02\0\x01\x12\x03[\x0c\x15\n\x0c\n\x05\x04\x06\x02\0\x03\x12\
    \x03[\x18\x19\n\x0b\n\x04\x04\x06\x02\x01\x12\x03\\\x02\x12\n\x0c\n\x05\
    \x04\x06\x02\x01\x06\x12\x03\\\x02\x07\n\x0c\n\x05\x04\x06\x02\x01\x01\
    \x12\x03\\\x08\r\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03\\\x10\x11\nL\n\
    \x02\x05\x02\x12\x04`\0c\x01\x1a@\x20The\x20direction,\x20descending\x20\
    or\x20ascending,\x20of\x20the\x20sort\x20operation.\n\n\n\n\x03\x05\x02\
    \x01\x12\x03`\x05\x0e\n\x0b\n\x04\x05\x02\x02\0\x12\x03a\x02\x0b\n\x0c\n\
    \x05\x05\x02\x02\0\x01\x12\x03a\x02\x06\n\x0c\n\x05\x05\x02\x02\0\x02\
    \x12\x03a\t\n\n\x0b\n\x04\x05\x02\x02\x01\x12\x03b\x02\n\n\x0c\n\x05\x05\
    \x02\x02\x01\x01\x12\x03b\x02\x05\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\
    \x03b\x08\t\nW\n\x02\x05\x03\x12\x04f\0o\x01\x1aK\x20The\x20field\x20wit\
    hin\x20the\x20Module\x20schema\x20that\x20is\x20used\x20as\x20the\x20sor\
    ting\x20dimension.\n\n\n\n\x03\x05\x03\x01\x12\x03f\x05\n\n\x0b\n\x04\
    \x05\x03\x02\0\x12\x03g\x02\x10\n\x0c\n\x05\x05\x03\x02\0\x01\x12\x03g\
    \x02\x0b\n\x0c\n\x05\x05\x03\x02\0\x02\x12\x03g\x0e\x0f\n\x0b\n\x04\x05\
    \x03\x02\x01\x12\x03h\x02\x0b\n\x0c\n\x05\x05\x03\x02\x01\x01\x12\x03h\
    \x02\x06\n\x0c\n\x05\x05\x03\x02\x01\x02\x12\x03h\t\n\n\x0b\n\x04\x05\
    \x03\x02\x02\x12\x03i\x02\x0b\n\x0c\n\x05\x05\x03\x02\x02\x01\x12\x03i\
    \x02\x06\n\x0c\n\x05\x05\x03\x02\x02\x02\x12\x03i\t\n\n\x0b\n\x04\x05\
    \x03\x02\x03\x12\x03j\x02\x0f\n\x0c\n\x05\x05\x03\x02\x03\x01\x12\x03j\
    \x02\n\n\x0c\n\x05\x05\x03\x02\x03\x02\x12\x03j\r\x0e\n\x0b\n\x04\x05\
    \x03\x02\x04\x12\x03k\x02\x13\n\x0c\n\x05\x05\x03\x02\x04\x01\x12\x03k\
    \x02\x0e\n\x0c\n\x05\x05\x03\x02\x04\x02\x12\x03k\x11\x12\n\x0b\n\x04\
    \x05\x03\x02\x05\x12\x03l\x02\x13\n\x0c\n\x05\x05\x03\x02\x05\x01\x12\
    \x03l\x02\x0e\n\x0c\n\x05\x05\x03\x02\x05\x02\x12\x03l\x11\x12\n\x0b\n\
    \x04\x05\x03\x02\x06\x12\x03m\x02\r\n\x0c\n\x05\x05\x03\x02\x06\x01\x12\
    \x03m\x02\x08\n\x0c\n\x05\x05\x03\x02\x06\x02\x12\x03m\x0b\x0c\n\x0b\n\
    \x04\x05\x03\x02\x07\x12\x03n\x02\x11\n\x0c\n\x05\x05\x03\x02\x07\x01\
    \x12\x03n\x02\x0c\n\x0c\n\x05\x05\x03\x02\x07\x02\x12\x03n\x0f\x10\nl\n\
    \x02\x04\x07\x12\x04s\0x\x01\x1a`\x20`PUT\x20/api/v1/module:`\n\x20Inser\
    t\x20a\x20module,\x20extract\x20data\x20from\x20binary.\x20Return\x20the\
    \x20module\x20ID\x20&\x20hash.\n\n\n\n\x03\x04\x07\x01\x12\x03s\x08\x1b\
    \n\x0b\n\x04\x04\x07\x02\0\x12\x03t\x02\x11\n\x0c\n\x05\x04\x07\x02\0\
    \x05\x12\x03t\x02\x07\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03t\x08\x0c\n\
    \x0c\n\x05\x04\x07\x02\0\x03\x12\x03t\x0f\x10\n\x0b\n\x04\x04\x07\x02\
    \x01\x12\x03u\x02#\n\x0c\n\x05\x04\x07\x02\x01\x06\x12\x03u\x02\x15\n\
    \x0c\n\x05\x04\x07\x02\x01\x01\x12\x03u\x16\x1e\n\x0c\n\x05\x04\x07\x02\
    \x01\x03\x12\x03u!\"\nS\n\x04\x04\x07\x02\x02\x12\x03w\x02\x1f\x1aF\x20a\
    \x20valid\x20URL\x20with\x20a\x20scheme\x20prefix\x20e.g.\x20`s3://`,\
    \x20`file://`,\x20`https://`\n\n\x0c\n\x05\x04\x07\x02\x02\x04\x12\x03w\
    \x02\n\n\x0c\n\x05\x04\x07\x02\x02\x05\x12\x03w\x0b\x11\n\x0c\n\x05\x04\
    \x07\x02\x02\x01\x12\x03w\x12\x1a\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\
    \x03w\x1d\x1e\nJ\n\x02\x04\x08\x12\x04{\0\x7f\x01\x1a>\x20The\x20message\
    \x20returned\x20in\x20response\x20to\x20a\x20`CreateModuleRequest`.\n\n\
    \n\n\x03\x04\x08\x01\x12\x03{\x08\x1c\n\x0b\n\x04\x04\x08\x02\0\x12\x03|\
    \x02\x16\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03|\x02\x07\n\x0c\n\x05\x04\
    \x08\x02\0\x01\x12\x03|\x08\x11\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03|\
    \x14\x15\n\x0b\n\x04\x04\x08\x02\x01\x12\x03}\x02\x12\n\x0c\n\x05\x04\
    \x08\x02\x01\x05\x12\x03}\x02\x08\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\
    \x03}\t\r\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03}\x10\x11\n\x0b\n\x04\
    \x04\x08\x02\x02\x12\x03~\x02\x1b\n\x0c\n\x05\x04\x08\x02\x02\x04\x12\
    \x03~\x02\n\n\x0c\n\x05\x04\x08\x02\x02\x06\x12\x03~\x0b\x10\n\x0c\n\x05\
    \x04\x08\x02\x02\x01\x12\x03~\x11\x16\n\x0c\n\x05\x04\x08\x02\x02\x03\
    \x12\x03~\x19\x1a\n=\n\x02\x04\t\x12\x04\x83\x01\01\x1a1\x20`POST\x20/ap\
    i/v1/module:`\n\x20Return\x20a\x20single\x20module.\n\n\x0b\n\x03\x04\t\
    \x01\x12\x04\x83\x01\x08\x18\n\x0c\n\x04\x04\t\x02\0\x12\x04\x83\x01\x1b\
    /\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x83\x01\x1b\x20\n\r\n\x05\x04\t\x02\
    \0\x01\x12\x04\x83\x01!*\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x83\x01-.\nI\
    \n\x02\x04\n\x12\x06\x86\x01\0\x89\x01\x01\x1a;\x20The\x20message\x20ret\
    urned\x20in\x20response\x20to\x20a\x20`GetModuleRequest`.\n\n\x0b\n\x03\
    \x04\n\x01\x12\x04\x86\x01\x08\x19\n\x0c\n\x04\x04\n\x02\0\x12\x04\x87\
    \x01\x02\x14\n\r\n\x05\x04\n\x02\0\x06\x12\x04\x87\x01\x02\x08\n\r\n\x05\
    \x04\n\x02\0\x01\x12\x04\x87\x01\t\x0f\n\r\n\x05\x04\n\x02\0\x03\x12\x04\
    \x87\x01\x12\x13\n\x0c\n\x04\x04\n\x02\x01\x12\x04\x88\x01\x02\x1b\n\r\n\
    \x05\x04\n\x02\x01\x04\x12\x04\x88\x01\x02\n\n\r\n\x05\x04\n\x02\x01\x06\
    \x12\x04\x88\x01\x0b\x10\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x88\x01\x11\
    \x16\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\x88\x01\x19\x1a\nN\n\x02\x04\
    \x0b\x12\x06\x8d\x01\0\x90\x01\x01\x1a@\x20`POST\x20/api/v1/modules:`\n\
    \x20Return\x20paginated\x20list\x20of\x20all\x20modules.\n\n\x0b\n\x03\
    \x04\x0b\x01\x12\x04\x8d\x01\x08\x1a\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\
    \x8e\x01\x02\x1c\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\x8e\x01\x02\x0c\n\r\
    \n\x05\x04\x0b\x02\0\x01\x12\x04\x8e\x01\r\x17\n\r\n\x05\x04\x0b\x02\0\
    \x03\x12\x04\x8e\x01\x1a\x1b\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x8f\x01\
    \x02\x10\n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\x8f\x01\x02\x06\n\r\n\x05\
    \x04\x0b\x02\x01\x01\x12\x04\x8f\x01\x07\x0b\n\r\n\x05\x04\x0b\x02\x01\
    \x03\x12\x04\x8f\x01\x0e\x0f\nK\n\x02\x04\x0c\x12\x06\x93\x01\0\x9b\x01\
    \x01\x1a=\x20The\x20message\x20returned\x20in\x20response\x20to\x20a\x20\
    `ListModulesRequest`.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\x93\x01\x08\x1b\
    \n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x94\x01\x02\x1e\n\r\n\x05\x04\x0c\x02\
    \0\x04\x12\x04\x94\x01\x02\n\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\x94\x01\
    \x0b\x11\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x94\x01\x12\x19\n\r\n\x05\
    \x04\x0c\x02\0\x03\x12\x04\x94\x01\x1c\x1d\n\x0c\n\x04\x04\x0c\x02\x01\
    \x12\x04\x95\x01\x02\x1c\n\r\n\x05\x04\x0c\x02\x01\x06\x12\x04\x95\x01\
    \x02\x0c\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\x95\x01\r\x17\n\r\n\x05\
    \x04\x0c\x02\x01\x03\x12\x04\x95\x01\x1a\x1b\ng\n\x04\x04\x0c\x02\x02\
    \x12\x04\x98\x01\x02\x13\x1aY\x20the\x20full\x20count\x20of\x20results\
    \x20in\x20the\x20database\x20(not\x20the\x20count\x20of\x20this\x20messa\
    ge's\n\x20`modules`).\n\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\x98\x01\
    \x02\x08\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\x98\x01\t\x0e\n\r\n\x05\
    \x04\x0c\x02\x02\x03\x12\x04\x98\x01\x11\x12\n\x0c\n\x04\x04\x0c\x02\x03\
    \x12\x04\x99\x01\x02\x10\n\r\n\x05\x04\x0c\x02\x03\x06\x12\x04\x99\x01\
    \x02\x06\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\x99\x01\x07\x0b\n\r\n\x05\
    \x04\x0c\x02\x03\x03\x12\x04\x99\x01\x0e\x0f\n\x0c\n\x04\x04\x0c\x02\x04\
    \x12\x04\x9a\x01\x02\x1b\n\r\n\x05\x04\x0c\x02\x04\x04\x12\x04\x9a\x01\
    \x02\n\n\r\n\x05\x04\x0c\x02\x04\x06\x12\x04\x9a\x01\x0b\x10\n\r\n\x05\
    \x04\x0c\x02\x04\x01\x12\x04\x9a\x01\x11\x16\n\r\n\x05\x04\x0c\x02\x04\
    \x03\x12\x04\x9a\x01\x19\x1a\n\xe8\x01\n\x02\x04\r\x12\x06\xa1\x01\0\xc4\
    \x01\x01\x1a\xd9\x01\x20`POST\x20/api/v1/search:`\n\x20Search\x20for\x20\
    modules\x20based\x20on\x20filter\x20params\x20provided\x20(which\x20shou\
    ld\x20be\x20any\n\x20dimension\x20of\x20the\x20module\x20schema,\x20or\
    \x20string\x20search\x20in\x20any\x20metadata\x20value).\n\x20Return\x20\
    a\x20paginated\x20list\x20of\x20matching\x20modules.\n\n\x0b\n\x03\x04\r\
    \x01\x12\x04\xa1\x01\x08\x1c\n>\n\x04\x04\r\x02\0\x12\x04\xa3\x01\x02\
    \x18\x1a0\x20ID\x20for\x20this\x20module,\x20generated\x20by\x20the\x20d\
    atabase.\n\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xa3\x01\x02\n\n\r\n\x05\x04\
    \r\x02\0\x05\x12\x04\xa3\x01\x0b\x10\n\r\n\x05\x04\r\x02\0\x01\x12\x04\
    \xa3\x01\x11\x13\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xa3\x01\x16\x17\n7\n\
    \x04\x04\r\x02\x01\x12\x04\xa5\x01\x02\x1b\x1a)\x20original\x20name\x20o\
    f\x20the\x20binary\x20module\x20file\n\n\r\n\x05\x04\r\x02\x01\x04\x12\
    \x04\xa5\x01\x02\n\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xa5\x01\x0b\x11\n\
    \r\n\x05\x04\r\x02\x01\x01\x12\x04\xa5\x01\x12\x16\n\r\n\x05\x04\r\x02\
    \x01\x03\x12\x04\xa5\x01\x19\x1a\n\x82\x01\n\x04\x04\r\x02\x02\x12\x04\
    \xa8\x01\x02\x1e\x1at\x20function\x20imports\x20called\x20by\x20the\x20m\
    odule\x20(see:\n\x20<https://github.com/WebAssembly/design/blob/main/Mod\
    ules.md#imports>)\n\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xa8\x01\x02\n\n\
    \r\n\x05\x04\r\x02\x02\x06\x12\x04\xa8\x01\x0b\x11\n\r\n\x05\x04\r\x02\
    \x02\x01\x12\x04\xa8\x01\x12\x19\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xa8\
    \x01\x1c\x1d\n\x84\x01\n\x04\x04\r\x02\x03\x12\x04\xab\x01\x02\x1e\x1av\
    \x20function\x20exports\x20provided\x20by\x20the\x20module\x20(see:\n\
    \x20<https://github.com/WebAssembly/design/blob/main/Modules.md#exports>\
    )\n\n\r\n\x05\x04\r\x02\x03\x04\x12\x04\xab\x01\x02\n\n\r\n\x05\x04\r\
    \x02\x03\x06\x12\x04\xab\x01\x0b\x11\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\
    \xab\x01\x12\x19\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xab\x01\x1c\x1d\n3\
    \n\x04\x04\r\x02\x04\x12\x04\xad\x01\x02\x1f\x1a%\x20minimum\x20size\x20\
    in\x20bytes\x20of\x20the\x20module\n\n\r\n\x05\x04\r\x02\x04\x04\x12\x04\
    \xad\x01\x02\n\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\xad\x01\x0b\x11\n\r\n\
    \x05\x04\r\x02\x04\x01\x12\x04\xad\x01\x12\x1a\n\r\n\x05\x04\r\x02\x04\
    \x03\x12\x04\xad\x01\x1d\x1e\n3\n\x04\x04\r\x02\x05\x12\x04\xaf\x01\x02\
    \x1f\x1a%\x20maximum\x20size\x20in\x20bytes\x20of\x20the\x20module\n\n\r\
    \n\x05\x04\r\x02\x05\x04\x12\x04\xaf\x01\x02\n\n\r\n\x05\x04\r\x02\x05\
    \x05\x12\x04\xaf\x01\x0b\x11\n\r\n\x05\x04\r\x02\x05\x01\x12\x04\xaf\x01\
    \x12\x1a\n\r\n\x05\x04\r\x02\x05\x03\x12\x04\xaf\x01\x1d\x1e\ng\n\x04\
    \x04\r\x02\x06\x12\x04\xb2\x01\x02\x1f\x1aY\x20optional\x20path\x20or\
    \x20locator\x20to\x20the\x20module\x20(TODO:\x20maybe\x20this\x20is\x20b\
    etter\x20stored\n\x20as\x20metadata)\n\n\r\n\x05\x04\r\x02\x06\x04\x12\
    \x04\xb2\x01\x02\n\n\r\n\x05\x04\r\x02\x06\x05\x12\x04\xb2\x01\x0b\x11\n\
    \r\n\x05\x04\r\x02\x06\x01\x12\x04\xb2\x01\x12\x1a\n\r\n\x05\x04\r\x02\
    \x06\x03\x12\x04\xb2\x01\x1d\x1e\n@\n\x04\x04\r\x02\x07\x12\x04\xb4\x01\
    \x02.\x1a2\x20programming\x20language\x20used\x20to\x20produce\x20this\
    \x20module\n\n\r\n\x05\x04\r\x02\x07\x04\x12\x04\xb4\x01\x02\n\n\r\n\x05\
    \x04\r\x02\x07\x06\x12\x04\xb4\x01\x0b\x19\n\r\n\x05\x04\r\x02\x07\x01\
    \x12\x04\xb4\x01\x1a)\n\r\n\x05\x04\r\x02\x07\x03\x12\x04\xb4\x01,-\nJ\n\
    \x04\x04\r\x02\x08\x12\x04\xb6\x01\x02$\x1a<\x20arbitrary\x20metadata\
    \x20provided\x20by\x20the\x20operator\x20of\x20this\x20module\n\n\r\n\
    \x05\x04\r\x02\x08\x06\x12\x04\xb6\x01\x02\x15\n\r\n\x05\x04\r\x02\x08\
    \x01\x12\x04\xb6\x01\x16\x1e\n\r\n\x05\x04\r\x02\x08\x03\x12\x04\xb6\x01\
    !#\n@\n\x04\x04\r\x02\t\x12\x04\xb8\x01\x02:\x1a2\x20timestamp\x20when\
    \x20this\x20module\x20was\x20loaded\x20and\x20stored\n\n\r\n\x05\x04\r\
    \x02\t\x04\x12\x04\xb8\x01\x02\n\n\r\n\x05\x04\r\x02\t\x06\x12\x04\xb8\
    \x01\x0b$\n\r\n\x05\x04\r\x02\t\x01\x12\x04\xb8\x01%4\n\r\n\x05\x04\r\
    \x02\t\x03\x12\x04\xb8\x0179\n@\n\x04\x04\r\x02\n\x12\x04\xba\x01\x029\
    \x1a2\x20timestamp\x20when\x20this\x20module\x20was\x20loaded\x20and\x20\
    stored\n\n\r\n\x05\x04\r\x02\n\x04\x12\x04\xba\x01\x02\n\n\r\n\x05\x04\r\
    \x02\n\x06\x12\x04\xba\x01\x0b$\n\r\n\x05\x04\r\x02\n\x01\x12\x04\xba\
    \x01%3\n\r\n\x05\x04\r\x02\n\x03\x12\x04\xba\x0168\n[\n\x04\x04\r\x02\
    \x0b\x12\x04\xbc\x01\x02\x1f\x1aM\x20the\x20interned\x20strings\x20store\
    d\x20in\x20the\x20wasm\x20binary\x20(panic/abort\x20messages,\x20etc.)\n\
    \n\r\n\x05\x04\r\x02\x0b\x04\x12\x04\xbc\x01\x02\n\n\r\n\x05\x04\r\x02\
    \x0b\x05\x12\x04\xbc\x01\x0b\x11\n\r\n\x05\x04\r\x02\x0b\x01\x12\x04\xbc\
    \x01\x12\x19\n\r\n\x05\x04\r\x02\x0b\x03\x12\x04\xbc\x01\x1c\x1e\nB\n\
    \x04\x04\r\x02\x0c\x12\x04\xbe\x01\x02%\x1a4\x20match\x20on\x20any\x20fu\
    nction\x20name\x20in\x20an\x20import\x20or\x20export.\n\n\r\n\x05\x04\r\
    \x02\x0c\x04\x12\x04\xbe\x01\x02\n\n\r\n\x05\x04\r\x02\x0c\x05\x12\x04\
    \xbe\x01\x0b\x11\n\r\n\x05\x04\r\x02\x0c\x01\x12\x04\xbe\x01\x12\x1f\n\r\
    \n\x05\x04\r\x02\x0c\x03\x12\x04\xbe\x01\"$\nO\n\x04\x04\r\x02\r\x12\x04\
    \xc0\x01\x02#\x1aA\x20match\x20on\x20the\x20module\x20name\x20e.g.\x20`e\
    nv`\x20or\x20`wasi_snapshot_preview1`\n\n\r\n\x05\x04\r\x02\r\x04\x12\
    \x04\xc0\x01\x02\n\n\r\n\x05\x04\r\x02\r\x05\x12\x04\xc0\x01\x0b\x11\n\r\
    \n\x05\x04\r\x02\r\x01\x12\x04\xc0\x01\x12\x1d\n\r\n\x05\x04\r\x02\r\x03\
    \x12\x04\xc0\x01\x20\"\n\x0c\n\x04\x04\r\x02\x0e\x12\x04\xc2\x01\x02\x1d\
    \n\r\n\x05\x04\r\x02\x0e\x06\x12\x04\xc2\x01\x02\x0c\n\r\n\x05\x04\r\x02\
    \x0e\x01\x12\x04\xc2\x01\r\x17\n\r\n\x05\x04\r\x02\x0e\x03\x12\x04\xc2\
    \x01\x1a\x1c\n\x0c\n\x04\x04\r\x02\x0f\x12\x04\xc3\x01\x02\x11\n\r\n\x05\
    \x04\r\x02\x0f\x06\x12\x04\xc3\x01\x02\x06\n\r\n\x05\x04\r\x02\x0f\x01\
    \x12\x04\xc3\x01\x07\x0b\n\r\n\x05\x04\r\x02\x0f\x03\x12\x04\xc3\x01\x0e\
    \x10\nM\n\x02\x04\x0e\x12\x06\xc7\x01\0\xcf\x01\x01\x1a?\x20The\x20messa\
    ge\x20returned\x20in\x20response\x20to\x20a\x20`SearchModulesRequest`.\n\
    \n\x0b\n\x03\x04\x0e\x01\x12\x04\xc7\x01\x08\x1d\n\x0c\n\x04\x04\x0e\x02\
    \0\x12\x04\xc8\x01\x02\x1e\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xc8\x01\
    \x02\n\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xc8\x01\x0b\x11\n\r\n\x05\x04\
    \x0e\x02\0\x01\x12\x04\xc8\x01\x12\x19\n\r\n\x05\x04\x0e\x02\0\x03\x12\
    \x04\xc8\x01\x1c\x1d\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xc9\x01\x02\x1c\
    \n\r\n\x05\x04\x0e\x02\x01\x06\x12\x04\xc9\x01\x02\x0c\n\r\n\x05\x04\x0e\
    \x02\x01\x01\x12\x04\xc9\x01\r\x17\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\
    \xc9\x01\x1a\x1b\ng\n\x04\x04\x0e\x02\x02\x12\x04\xcc\x01\x02\x13\x1aY\
    \x20the\x20full\x20count\x20of\x20results\x20in\x20the\x20database\x20(n\
    ot\x20the\x20count\x20of\x20this\x20message's\n\x20`modules`).\n\n\r\n\
    \x05\x04\x0e\x02\x02\x05\x12\x04\xcc\x01\x02\x08\n\r\n\x05\x04\x0e\x02\
    \x02\x01\x12\x04\xcc\x01\t\x0e\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xcc\
    \x01\x11\x12\n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\xcd\x01\x02\x10\n\r\n\
    \x05\x04\x0e\x02\x03\x06\x12\x04\xcd\x01\x02\x06\n\r\n\x05\x04\x0e\x02\
    \x03\x01\x12\x04\xcd\x01\x07\x0b\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\
    \xcd\x01\x0e\x0f\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\xce\x01\x02\x1b\n\r\
    \n\x05\x04\x0e\x02\x04\x04\x12\x04\xce\x01\x02\n\n\r\n\x05\x04\x0e\x02\
    \x04\x06\x12\x04\xce\x01\x0b\x10\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\
    \xce\x01\x11\x16\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xce\x01\x19\x1a\n\
    t\n\x02\x04\x0f\x12\x04\xd3\x01\0?\x1ah\x20`DELETE\x20/api/v1/module:`\n\
    \x20Remove\x20a\x20module\x20from\x20the\x20database\x20by\x20its\x20ID.\
    \x20Return\x20the\x20module\x20IDs\x20&\x20hashes.\n\n\x0b\n\x03\x04\x0f\
    \x01\x12\x04\xd3\x01\x08\x1c\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xd3\x01\
    \x1f=\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xd3\x01\x1f'\n\r\n\x05\x04\x0f\
    \x02\0\x05\x12\x04\xd3\x01(-\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xd3\x01\
    .8\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xd3\x01;<\nM\n\x02\x04\x10\x12\
    \x06\xd6\x01\0\xd9\x01\x01\x1a?\x20The\x20message\x20returned\x20in\x20r\
    esponse\x20to\x20a\x20`DeleteModulesRequest`.\n\n\x0b\n\x03\x04\x10\x01\
    \x12\x04\xd6\x01\x08\x1d\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xd7\x01\x02(\
    \n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xd7\x01\x02\x14\n\r\n\x05\x04\x10\
    \x02\0\x01\x12\x04\xd7\x01\x15#\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xd7\
    \x01&'\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xd8\x01\x02\x1b\n\r\n\x05\x04\
    \x10\x02\x01\x04\x12\x04\xd8\x01\x02\n\n\r\n\x05\x04\x10\x02\x01\x06\x12\
    \x04\xd8\x01\x0b\x10\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xd8\x01\x11\
    \x16\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xd8\x01\x19\x1a\n\xfc\x01\n\
    \x02\x05\x04\x12\x06\xde\x01\0\xe1\x01\x01\x1a\xed\x01\x20Represents\x20\
    the\x20expected\x20outcome\x20of\x20an\x20AuditModulesRequest.\x20If\x20\
    PASS\x20is\x20provided,\x20then\n\x20the\x20audit\x20returns\x20modules\
    \x20which\x20conform\x20to\x20the\x20checkfile.\x20If\x20FAIL\x20is\x20p\
    rovided,\x20then\n\x20the\x20audit\x20returns\x20modules\x20which\x20do\
    \x20not\x20conform\x20to\x20the\x20checkfile.\n\n\x0b\n\x03\x05\x04\x01\
    \x12\x04\xde\x01\x05\x11\n\x0c\n\x04\x05\x04\x02\0\x12\x04\xdf\x01\x02\
    \x0b\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\xdf\x01\x02\x06\n\r\n\x05\x05\
    \x04\x02\0\x02\x12\x04\xdf\x01\t\n\n\x0c\n\x04\x05\x04\x02\x01\x12\x04\
    \xe0\x01\x02\x0b\n\r\n\x05\x05\x04\x02\x01\x01\x12\x04\xe0\x01\x02\x06\n\
    \r\n\x05\x05\x04\x02\x01\x02\x12\x04\xe0\x01\t\n\n\x82\x01\n\x02\x04\x11\
    \x12\x06\xe5\x01\0\xea\x01\x01\x1at\x20`POST\x20/api/v1/audit:`\n\x20Ret\
    urn\x20a\x20list\x20of\x20modules\x20which\x20match\x20the\x20outcome\
    \x20requirements\x20using\x20the\x20provided\x20checkfile.\n\n\x0b\n\x03\
    \x04\x11\x01\x12\x04\xe5\x01\x08\x1b\n8\n\x04\x04\x11\x02\0\x12\x04\xe7\
    \x01\x02\x16\x1a*\x20the\x20YAML\x20checkfile\x20(e.g.\x20mod.yaml)\x20b\
    ytes\n\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xe7\x01\x02\x07\n\r\n\x05\x04\
    \x11\x02\0\x01\x12\x04\xe7\x01\x08\x11\n\r\n\x05\x04\x11\x02\0\x03\x12\
    \x04\xe7\x01\x14\x15\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xe8\x01\x02\x1b\
    \n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\xe8\x01\x02\x0e\n\r\n\x05\x04\x11\
    \x02\x01\x01\x12\x04\xe8\x01\x0f\x16\n\r\n\x05\x04\x11\x02\x01\x03\x12\
    \x04\xe8\x01\x19\x1a\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xe9\x01\x02\x1c\
    \n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\xe9\x01\x02\x0c\n\r\n\x05\x04\x11\
    \x02\x02\x01\x12\x04\xe9\x01\r\x17\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\
    \xe9\x01\x1a\x1b\nL\n\x02\x04\x12\x12\x06\xed\x01\0\xf6\x01\x01\x1a>\x20\
    The\x20message\x20returned\x20in\x20response\x20to\x20a\x20`AuditModules\
    Request`.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xed\x01\x08\x1c\n\xad\x01\n\
    \x04\x04\x12\x02\0\x12\x04\xf0\x01\x02.\x1a\x9e\x01\x20each\x20record\
    \x20contains\x20the\x20ID\x20of\x20the\x20invalid\x20Module\x20which\x20\
    failed\x20the\x20audit,\x20as\x20well\x20as\x20the\x20failure\x20\n\x20r\
    eport\x20produced\x20by\x20the\x20validation\x20check\x20(encoded\x20in\
    \x20JSON)\n\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\xf0\x01\x02\x13\n\r\n\
    \x05\x04\x12\x02\0\x01\x12\x04\xf0\x01\x14)\n\r\n\x05\x04\x12\x02\0\x03\
    \x12\x04\xf0\x01,-\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\xf1\x01\x02\x1c\n\
    \r\n\x05\x04\x12\x02\x01\x06\x12\x04\xf1\x01\x02\x0c\n\r\n\x05\x04\x12\
    \x02\x01\x01\x12\x04\xf1\x01\r\x17\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\
    \xf1\x01\x1a\x1b\ng\n\x04\x04\x12\x02\x02\x12\x04\xf4\x01\x02\x13\x1aY\
    \x20the\x20full\x20count\x20of\x20results\x20in\x20the\x20database\x20(n\
    ot\x20the\x20count\x20of\x20this\x20message's\n\x20`modules`).\n\n\r\n\
    \x05\x04\x12\x02\x02\x05\x12\x04\xf4\x01\x02\x08\n\r\n\x05\x04\x12\x02\
    \x02\x01\x12\x04\xf4\x01\t\x0e\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xf4\
    \x01\x11\x12\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\xf5\x01\x02\x1b\n\r\n\
    \x05\x04\x12\x02\x03\x04\x12\x04\xf5\x01\x02\n\n\r\n\x05\x04\x12\x02\x03\
    \x06\x12\x04\xf5\x01\x0b\x10\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xf5\
    \x01\x11\x16\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xf5\x01\x19\x1a\nD\n\
    \x02\x04\x13\x12\x06\xfa\x01\0\xff\x01\x01\x1a6\x20`POST\x20/api/v1/diff\
    :`\n\x20Return\x20the\x20diff\x20of\x20two\x20modules\n\n\x0b\n\x03\x04\
    \x13\x01\x12\x04\xfa\x01\x08\x13\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xfb\
    \x01\x02\x14\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xfb\x01\x02\x07\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\xfb\x01\x08\x0f\n\r\n\x05\x04\x13\x02\0\
    \x03\x12\x04\xfb\x01\x12\x13\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xfc\x01\
    \x02\x14\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xfc\x01\x02\x07\n\r\n\x05\
    \x04\x13\x02\x01\x01\x12\x04\xfc\x01\x08\x0f\n\r\n\x05\x04\x13\x02\x01\
    \x03\x12\x04\xfc\x01\x12\x13\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\xfd\x01\
    \x02\x1a\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\xfd\x01\x02\x06\n\r\n\x05\
    \x04\x13\x02\x02\x01\x12\x04\xfd\x01\x07\x15\n\r\n\x05\x04\x13\x02\x02\
    \x03\x12\x04\xfd\x01\x18\x19\n\x0c\n\x04\x04\x13\x02\x03\x12\x04\xfe\x01\
    \x02\x18\n\r\n\x05\x04\x13\x02\x03\x05\x12\x04\xfe\x01\x02\x06\n\r\n\x05\
    \x04\x13\x02\x03\x01\x12\x04\xfe\x01\x07\x13\n\r\n\x05\x04\x13\x02\x03\
    \x03\x12\x04\xfe\x01\x16\x17\n\x98\x01\n\x02\x04\x14\x12\x06\x83\x02\0\
    \x86\x02\x01\x1a\x89\x01\x20The\x20message\x20returned\x20in\x20response\
    \x20to\x20`DiffRequest`,\x20contains\x20a\x20text\x20representation\x20o\
    f\x20the\x20difference\n\x20between\x20the\x20two\x20specified\x20module\
    s.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\x83\x02\x08\x14\n\x0c\n\x04\x04\x14\
    \x02\0\x12\x04\x84\x02\x02\x12\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\x84\
    \x02\x02\x08\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x84\x02\t\r\n\r\n\x05\
    \x04\x14\x02\0\x03\x12\x04\x84\x02\x10\x11\n\x0c\n\x04\x04\x14\x02\x01\
    \x12\x04\x85\x02\x02\x1b\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\x85\x02\
    \x02\n\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\x85\x02\x0b\x10\n\r\n\x05\
    \x04\x14\x02\x01\x01\x12\x04\x85\x02\x11\x16\n\r\n\x05\x04\x14\x02\x01\
    \x03\x12\x04\x85\x02\x19\x1a\n\x8a\x01\n\x02\x04\x15\x12\x06\x8a\x02\0\
    \x93\x02\x01\x1a|\x20`POST\x20/api/v1/validate:`\n\x20Return\x20the\x20f\
    ailure\x20report\x20(if\x20applicable)\x20of\x20a\x20wasm\x20module\x20v\
    alidation\x20against\x20a\x20given\x20checkfile.\n\n\x0b\n\x03\x04\x15\
    \x01\x12\x04\x8a\x02\x08\x1d\n8\n\x04\x04\x15\x02\0\x12\x04\x8c\x02\x02\
    \x16\x1a*\x20the\x20YAML\x20checkfile\x20(e.g.\x20mod.yaml)\x20bytes\n\n\
    \r\n\x05\x04\x15\x02\0\x05\x12\x04\x8c\x02\x02\x07\n\r\n\x05\x04\x15\x02\
    \0\x01\x12\x04\x8c\x02\x08\x11\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\x8c\
    \x02\x14\x15\n\xb8\x01\n\x04\x04\x15\x08\0\x12\x06\x8f\x02\x02\x92\x02\
    \x03\x1a\xa7\x01\x20module_input\x20is\x20either\x20an\x20existing\x20`m\
    odule_id`\x20that\x20is\x20known\x20to\x20the\x20database,\x20or\x20the\
    \x20bytes\x20of\n\x20a\x20raw\x20wasm\x20module.\x20It\x20is\x20used\x20\
    to\x20validate\x20against\x20the\x20given\x20checkfile.\n\n\r\n\x05\x04\
    \x15\x08\0\x01\x12\x04\x8f\x02\x08\x14\n\x0c\n\x04\x04\x15\x02\x01\x12\
    \x04\x90\x02\x04\x15\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\x90\x02\x04\t\
    \n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\x90\x02\n\x10\n\r\n\x05\x04\x15\
    \x02\x01\x03\x12\x04\x90\x02\x13\x14\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\
    \x91\x02\x04\x18\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\x91\x02\x04\t\n\r\
    \n\x05\x04\x15\x02\x02\x01\x12\x04\x91\x02\n\x13\n\r\n\x05\x04\x15\x02\
    \x02\x03\x12\x04\x91\x02\x16\x17\nV\n\x02\x04\x16\x12\x06\x96\x02\0\x99\
    \x02\x01\x1aH\x20The\x20failure\x20report\x20produced\x20by\x20the\x20va\
    lidation\x20check\x20(encoded\x20in\x20JSON).\n\n\x0b\n\x03\x04\x16\x01\
    \x12\x04\x96\x02\x08\x1e\n\x0c\n\x04\x04\x16\x02\0\x12\x04\x97\x02\x02\"\
    \n\r\n\x05\x04\x16\x02\0\x05\x12\x04\x97\x02\x02\x07\n\r\n\x05\x04\x16\
    \x02\0\x01\x12\x04\x97\x02\x08\x1d\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\
    \x97\x02\x20!\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\x98\x02\x02\x1b\n\r\n\
    \x05\x04\x16\x02\x01\x04\x12\x04\x98\x02\x02\n\n\r\n\x05\x04\x16\x02\x01\
    \x06\x12\x04\x98\x02\x0b\x10\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\x98\
    \x02\x11\x16\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\x98\x02\x19\x1ab\x06p\
    roto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(23);
            messages.push(Function::generated_message_descriptor_data());
            messages.push(Import::generated_message_descriptor_data());
            messages.push(Export::generated_message_descriptor_data());
            messages.push(Module::generated_message_descriptor_data());
            messages.push(Error::generated_message_descriptor_data());
            messages.push(Pagination::generated_message_descriptor_data());
            messages.push(Sort::generated_message_descriptor_data());
            messages.push(CreateModuleRequest::generated_message_descriptor_data());
            messages.push(CreateModuleResponse::generated_message_descriptor_data());
            messages.push(GetModuleRequest::generated_message_descriptor_data());
            messages.push(GetModuleResponse::generated_message_descriptor_data());
            messages.push(ListModulesRequest::generated_message_descriptor_data());
            messages.push(ListModulesResponse::generated_message_descriptor_data());
            messages.push(SearchModulesRequest::generated_message_descriptor_data());
            messages.push(SearchModulesResponse::generated_message_descriptor_data());
            messages.push(DeleteModulesRequest::generated_message_descriptor_data());
            messages.push(DeleteModulesResponse::generated_message_descriptor_data());
            messages.push(AuditModulesRequest::generated_message_descriptor_data());
            messages.push(AuditModulesResponse::generated_message_descriptor_data());
            messages.push(DiffRequest::generated_message_descriptor_data());
            messages.push(DiffResponse::generated_message_descriptor_data());
            messages.push(ValidateModuleRequest::generated_message_descriptor_data());
            messages.push(ValidateModuleResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(ValType::generated_enum_descriptor_data());
            enums.push(SourceLanguage::generated_enum_descriptor_data());
            enums.push(Direction::generated_enum_descriptor_data());
            enums.push(Field::generated_enum_descriptor_data());
            enums.push(AuditOutcome::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
