// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `proto/v1/api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  Contained by an import or export element within a wasm binary.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Function)
pub struct Function {
    // message fields
    // @@protoc_insertion_point(field:Function.params)
    pub params: ::std::vec::Vec<::protobuf::EnumOrUnknown<ValType>>,
    // @@protoc_insertion_point(field:Function.results)
    pub results: ::std::vec::Vec<::protobuf::EnumOrUnknown<ValType>>,
    // @@protoc_insertion_point(field:Function.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Function.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Function {
    fn default() -> &'a Function {
        <Function as ::protobuf::Message>::default_instance()
    }
}

impl Function {
    pub fn new() -> Function {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "params",
            |m: &Function| { &m.params },
            |m: &mut Function| { &mut m.params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &Function| { &m.results },
            |m: &mut Function| { &mut m.results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Function| { &m.name },
            |m: &mut Function| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Function>(
            "Function",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Function {
    const NAME: &'static str = "Function";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.params.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.params)?
                },
                16 => {
                    self.results.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.results)?
                },
                26 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.params {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        for value in &self.results {
            my_size += ::protobuf::rt::int32_size(2, value.value());
        };
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.params {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.results {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Function {
        Function::new()
    }

    fn clear(&mut self) {
        self.params.clear();
        self.results.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Function {
        static instance: Function = Function {
            params: ::std::vec::Vec::new(),
            results: ::std::vec::Vec::new(),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Function {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Function").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Function {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Function {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A function and module namespace that is defined outside of the current
///  module, and referenced & called by the current module.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Import)
pub struct Import {
    // message fields
    // @@protoc_insertion_point(field:Import.module_name)
    pub module_name: ::std::string::String,
    // @@protoc_insertion_point(field:Import.func)
    pub func: ::protobuf::MessageField<Function>,
    // special fields
    // @@protoc_insertion_point(special_field:Import.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Import {
    fn default() -> &'a Import {
        <Import as ::protobuf::Message>::default_instance()
    }
}

impl Import {
    pub fn new() -> Import {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_name",
            |m: &Import| { &m.module_name },
            |m: &mut Import| { &mut m.module_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Function>(
            "func",
            |m: &Import| { &m.func },
            |m: &mut Import| { &mut m.func },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Import>(
            "Import",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Import {
    const NAME: &'static str = "Import";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.module_name = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.func)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.module_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.module_name);
        }
        if let Some(v) = self.func.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.module_name.is_empty() {
            os.write_string(1, &self.module_name)?;
        }
        if let Some(v) = self.func.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Import {
        Import::new()
    }

    fn clear(&mut self) {
        self.module_name.clear();
        self.func.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Import {
        static instance: Import = Import {
            module_name: ::std::string::String::new(),
            func: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Import {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Import").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Import {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Import {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A function that is defined inside the current module, made available to
///  outside modules / environments.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Export)
pub struct Export {
    // message fields
    // @@protoc_insertion_point(field:Export.func)
    pub func: ::protobuf::MessageField<Function>,
    // special fields
    // @@protoc_insertion_point(special_field:Export.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Export {
    fn default() -> &'a Export {
        <Export as ::protobuf::Message>::default_instance()
    }
}

impl Export {
    pub fn new() -> Export {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Function>(
            "func",
            |m: &Export| { &m.func },
            |m: &mut Export| { &mut m.func },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Export>(
            "Export",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Export {
    const NAME: &'static str = "Export";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.func)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.func.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.func.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Export {
        Export::new()
    }

    fn clear(&mut self) {
        self.func.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Export {
        static instance: Export = Export {
            func: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Export {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Export").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Export {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Export {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Details about a wasm module, either extracted directly from the binary, or
///  inferred somehow.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Module)
pub struct Module {
    // message fields
    ///  ID for this module, generated by the database.
    // @@protoc_insertion_point(field:Module.id)
    pub id: i64,
    ///  sha256 hash of the modules raw bytes
    // @@protoc_insertion_point(field:Module.hash)
    pub hash: ::std::string::String,
    ///  function imports called by the module (see:
    ///  <https://github.com/WebAssembly/design/blob/main/Modules.md#imports)>
    // @@protoc_insertion_point(field:Module.imports)
    pub imports: ::std::vec::Vec<Import>,
    ///  function exports provided by the module (see:
    ///  <https://github.com/WebAssembly/design/blob/main/Modules.md#exports)>
    // @@protoc_insertion_point(field:Module.exports)
    pub exports: ::std::vec::Vec<Export>,
    ///  size in bytes of the module
    // @@protoc_insertion_point(field:Module.size)
    pub size: u64,
    ///  path or locator to the module
    // @@protoc_insertion_point(field:Module.location)
    pub location: ::std::string::String,
    ///  programming language used to produce this module
    // @@protoc_insertion_point(field:Module.source_language)
    pub source_language: ::protobuf::EnumOrUnknown<SourceLanguage>,
    ///  arbitrary metadata provided by the operator of this module
    // @@protoc_insertion_point(field:Module.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  timestamp when this module was loaded and stored
    // @@protoc_insertion_point(field:Module.inserted_at)
    pub inserted_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  the interned strings stored in the wasm binary (panic/abort messages, etc.)
    // @@protoc_insertion_point(field:Module.strings)
    pub strings: ::std::vec::Vec<::std::string::String>,
    ///  the cyclomatic complexity
    ///  (<https://en.wikipedia.org/wiki/Cyclomatic_complexity>) of the instructions
    // @@protoc_insertion_point(field:Module.complexity)
    pub complexity: ::std::option::Option<u32>,
    ///  the serialized graph in json format
    // @@protoc_insertion_point(field:Module.graph)
    pub graph: ::std::option::Option<::std::vec::Vec<u8>>,
    ///  function hashes
    // @@protoc_insertion_point(field:Module.function_hashes)
    pub function_hashes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:Module.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Module {
    fn default() -> &'a Module {
        <Module as ::protobuf::Message>::default_instance()
    }
}

impl Module {
    pub fn new() -> Module {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Module| { &m.id },
            |m: &mut Module| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &Module| { &m.hash },
            |m: &mut Module| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "imports",
            |m: &Module| { &m.imports },
            |m: &mut Module| { &mut m.imports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exports",
            |m: &Module| { &m.exports },
            |m: &mut Module| { &mut m.exports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "size",
            |m: &Module| { &m.size },
            |m: &mut Module| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "location",
            |m: &Module| { &m.location },
            |m: &mut Module| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_language",
            |m: &Module| { &m.source_language },
            |m: &mut Module| { &mut m.source_language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metadata",
            |m: &Module| { &m.metadata },
            |m: &mut Module| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "inserted_at",
            |m: &Module| { &m.inserted_at },
            |m: &mut Module| { &mut m.inserted_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "strings",
            |m: &Module| { &m.strings },
            |m: &mut Module| { &mut m.strings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "complexity",
            |m: &Module| { &m.complexity },
            |m: &mut Module| { &mut m.complexity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "graph",
            |m: &Module| { &m.graph },
            |m: &mut Module| { &mut m.graph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "function_hashes",
            |m: &Module| { &m.function_hashes },
            |m: &mut Module| { &mut m.function_hashes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Module>(
            "Module",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Module {
    const NAME: &'static str = "Module";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int64()?;
                },
                26 => {
                    self.hash = is.read_string()?;
                },
                34 => {
                    self.imports.push(is.read_message()?);
                },
                42 => {
                    self.exports.push(is.read_message()?);
                },
                48 => {
                    self.size = is.read_uint64()?;
                },
                58 => {
                    self.location = is.read_string()?;
                },
                64 => {
                    self.source_language = is.read_enum_or_unknown()?;
                },
                74 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inserted_at)?;
                },
                90 => {
                    self.strings.push(is.read_string()?);
                },
                104 => {
                    self.complexity = ::std::option::Option::Some(is.read_uint32()?);
                },
                114 => {
                    self.graph = ::std::option::Option::Some(is.read_bytes()?);
                },
                122 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.function_hashes.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.id);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.hash);
        }
        for value in &self.imports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.exports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.size != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.size);
        }
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.location);
        }
        if self.source_language != ::protobuf::EnumOrUnknown::new(SourceLanguage::Unknown) {
            my_size += ::protobuf::rt::int32_size(8, self.source_language.value());
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.inserted_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.strings {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(v) = self.complexity {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.graph.as_ref() {
            my_size += ::protobuf::rt::bytes_size(14, &v);
        }
        for (k, v) in &self.function_hashes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if !self.hash.is_empty() {
            os.write_string(3, &self.hash)?;
        }
        for v in &self.imports {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.exports {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.size != 0 {
            os.write_uint64(6, self.size)?;
        }
        if !self.location.is_empty() {
            os.write_string(7, &self.location)?;
        }
        if self.source_language != ::protobuf::EnumOrUnknown::new(SourceLanguage::Unknown) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.source_language))?;
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(74)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.inserted_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        for v in &self.strings {
            os.write_string(11, &v)?;
        };
        if let Some(v) = self.complexity {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.graph.as_ref() {
            os.write_bytes(14, v)?;
        }
        for (k, v) in &self.function_hashes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(122)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Module {
        Module::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.hash.clear();
        self.imports.clear();
        self.exports.clear();
        self.size = 0;
        self.location.clear();
        self.source_language = ::protobuf::EnumOrUnknown::new(SourceLanguage::Unknown);
        self.metadata.clear();
        self.inserted_at.clear();
        self.strings.clear();
        self.complexity = ::std::option::Option::None;
        self.graph = ::std::option::Option::None;
        self.function_hashes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Module {
        static instance: ::protobuf::rt::Lazy<Module> = ::protobuf::rt::Lazy::new();
        instance.get(Module::new)
    }
}

impl ::protobuf::MessageFull for Module {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Module").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Module {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Module {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Details about a wasm module graph
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ModuleGraph)
pub struct ModuleGraph {
    // message fields
    ///  ID for this module, generated by the database.
    // @@protoc_insertion_point(field:ModuleGraph.id)
    pub id: i64,
    ///  the serialized graph in json format
    // @@protoc_insertion_point(field:ModuleGraph.json_bytes)
    pub json_bytes: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:ModuleGraph.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModuleGraph {
    fn default() -> &'a ModuleGraph {
        <ModuleGraph as ::protobuf::Message>::default_instance()
    }
}

impl ModuleGraph {
    pub fn new() -> ModuleGraph {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ModuleGraph| { &m.id },
            |m: &mut ModuleGraph| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "json_bytes",
            |m: &ModuleGraph| { &m.json_bytes },
            |m: &mut ModuleGraph| { &mut m.json_bytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModuleGraph>(
            "ModuleGraph",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModuleGraph {
    const NAME: &'static str = "ModuleGraph";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int64()?;
                },
                18 => {
                    self.json_bytes = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.id);
        }
        if !self.json_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.json_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if !self.json_bytes.is_empty() {
            os.write_bytes(2, &self.json_bytes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModuleGraph {
        ModuleGraph::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.json_bytes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModuleGraph {
        static instance: ModuleGraph = ModuleGraph {
            id: 0,
            json_bytes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModuleGraph {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModuleGraph").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModuleGraph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModuleGraph {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  An error message indicating a problem in the API.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Error)
pub struct Error {
    // message fields
    // @@protoc_insertion_point(field:Error.code)
    pub code: i32,
    // @@protoc_insertion_point(field:Error.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Error.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Error {
    fn default() -> &'a Error {
        <Error as ::protobuf::Message>::default_instance()
    }
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &Error| { &m.code },
            |m: &mut Error| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &Error| { &m.message },
            |m: &mut Error| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Error>(
            "Error",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Error {
    const NAME: &'static str = "Error";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_int32()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Error {
        Error::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Error {
        static instance: Error = Error {
            code: 0,
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Error {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Error").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Error {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Control/limit the way results are paginated when working with large
///  responses.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Pagination)
pub struct Pagination {
    // message fields
    // @@protoc_insertion_point(field:Pagination.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:Pagination.offset)
    pub offset: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Pagination.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pagination {
    fn default() -> &'a Pagination {
        <Pagination as ::protobuf::Message>::default_instance()
    }
}

impl Pagination {
    pub fn new() -> Pagination {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &Pagination| { &m.limit },
            |m: &mut Pagination| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offset",
            |m: &Pagination| { &m.offset },
            |m: &mut Pagination| { &mut m.offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pagination>(
            "Pagination",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pagination {
    const NAME: &'static str = "Pagination";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.limit = is.read_uint32()?;
                },
                16 => {
                    self.offset = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.limit);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.offset);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.limit != 0 {
            os.write_uint32(1, self.limit)?;
        }
        if self.offset != 0 {
            os.write_uint32(2, self.offset)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pagination {
        Pagination::new()
    }

    fn clear(&mut self) {
        self.limit = 0;
        self.offset = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pagination {
        static instance: Pagination = Pagination {
            limit: 0,
            offset: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pagination {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pagination").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pagination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pagination {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Determine how to sort results from the API
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Sort)
pub struct Sort {
    // message fields
    // @@protoc_insertion_point(field:Sort.direction)
    pub direction: ::protobuf::EnumOrUnknown<Direction>,
    // @@protoc_insertion_point(field:Sort.field)
    pub field: ::protobuf::EnumOrUnknown<Field>,
    // special fields
    // @@protoc_insertion_point(special_field:Sort.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Sort {
    fn default() -> &'a Sort {
        <Sort as ::protobuf::Message>::default_instance()
    }
}

impl Sort {
    pub fn new() -> Sort {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &Sort| { &m.direction },
            |m: &mut Sort| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "field",
            |m: &Sort| { &m.field },
            |m: &mut Sort| { &mut m.field },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sort>(
            "Sort",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Sort {
    const NAME: &'static str = "Sort";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.direction = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.field = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.direction != ::protobuf::EnumOrUnknown::new(Direction::Desc) {
            my_size += ::protobuf::rt::int32_size(1, self.direction.value());
        }
        if self.field != ::protobuf::EnumOrUnknown::new(Field::CreatedAt) {
            my_size += ::protobuf::rt::int32_size(2, self.field.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.direction != ::protobuf::EnumOrUnknown::new(Direction::Desc) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.direction))?;
        }
        if self.field != ::protobuf::EnumOrUnknown::new(Field::CreatedAt) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.field))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Sort {
        Sort::new()
    }

    fn clear(&mut self) {
        self.direction = ::protobuf::EnumOrUnknown::new(Direction::Desc);
        self.field = ::protobuf::EnumOrUnknown::new(Field::CreatedAt);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Sort {
        static instance: Sort = Sort {
            direction: ::protobuf::EnumOrUnknown::from_i32(0),
            field: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Sort {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Sort").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Sort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sort {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `PUT /api/v1/module:`
///  Insert a module, extract data from binary. Return the module ID & hash.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CreateModuleRequest)
pub struct CreateModuleRequest {
    // message fields
    // @@protoc_insertion_point(field:CreateModuleRequest.wasm)
    pub wasm: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:CreateModuleRequest.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  a valid URL with a scheme prefix e.g. `s3://`, `file://`, `https://`
    // @@protoc_insertion_point(field:CreateModuleRequest.location)
    pub location: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CreateModuleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateModuleRequest {
    fn default() -> &'a CreateModuleRequest {
        <CreateModuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateModuleRequest {
    pub fn new() -> CreateModuleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wasm",
            |m: &CreateModuleRequest| { &m.wasm },
            |m: &mut CreateModuleRequest| { &mut m.wasm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metadata",
            |m: &CreateModuleRequest| { &m.metadata },
            |m: &mut CreateModuleRequest| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location",
            |m: &CreateModuleRequest| { &m.location },
            |m: &mut CreateModuleRequest| { &mut m.location },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateModuleRequest>(
            "CreateModuleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateModuleRequest {
    const NAME: &'static str = "CreateModuleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.wasm = is.read_bytes()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                26 => {
                    self.location = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.wasm.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.wasm);
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.wasm.is_empty() {
            os.write_bytes(1, &self.wasm)?;
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.location.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateModuleRequest {
        CreateModuleRequest::new()
    }

    fn clear(&mut self) {
        self.wasm.clear();
        self.metadata.clear();
        self.location = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateModuleRequest {
        static instance: ::protobuf::rt::Lazy<CreateModuleRequest> = ::protobuf::rt::Lazy::new();
        instance.get(CreateModuleRequest::new)
    }
}

impl ::protobuf::MessageFull for CreateModuleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateModuleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateModuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateModuleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `CreateModuleRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CreateModuleResponse)
pub struct CreateModuleResponse {
    // message fields
    // @@protoc_insertion_point(field:CreateModuleResponse.module_id)
    pub module_id: i64,
    // @@protoc_insertion_point(field:CreateModuleResponse.hash)
    pub hash: ::std::string::String,
    // @@protoc_insertion_point(field:CreateModuleResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:CreateModuleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateModuleResponse {
    fn default() -> &'a CreateModuleResponse {
        <CreateModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateModuleResponse {
    pub fn new() -> CreateModuleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &CreateModuleResponse| { &m.module_id },
            |m: &mut CreateModuleResponse| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &CreateModuleResponse| { &m.hash },
            |m: &mut CreateModuleResponse| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &CreateModuleResponse| { &m.error },
            |m: &mut CreateModuleResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateModuleResponse>(
            "CreateModuleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateModuleResponse {
    const NAME: &'static str = "CreateModuleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.module_id = is.read_int64()?;
                },
                18 => {
                    self.hash = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.module_id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.module_id);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hash);
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.module_id != 0 {
            os.write_int64(1, self.module_id)?;
        }
        if !self.hash.is_empty() {
            os.write_string(2, &self.hash)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateModuleResponse {
        CreateModuleResponse::new()
    }

    fn clear(&mut self) {
        self.module_id = 0;
        self.hash.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateModuleResponse {
        static instance: CreateModuleResponse = CreateModuleResponse {
            module_id: 0,
            hash: ::std::string::String::new(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateModuleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateModuleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateModuleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/module:`
///  Return a single module.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GetModuleRequest)
pub struct GetModuleRequest {
    // message fields
    // @@protoc_insertion_point(field:GetModuleRequest.module_id)
    pub module_id: i64,
    // special fields
    // @@protoc_insertion_point(special_field:GetModuleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleRequest {
    fn default() -> &'a GetModuleRequest {
        <GetModuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleRequest {
    pub fn new() -> GetModuleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &GetModuleRequest| { &m.module_id },
            |m: &mut GetModuleRequest| { &mut m.module_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleRequest>(
            "GetModuleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleRequest {
    const NAME: &'static str = "GetModuleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.module_id = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.module_id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.module_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.module_id != 0 {
            os.write_int64(1, self.module_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleRequest {
        GetModuleRequest::new()
    }

    fn clear(&mut self) {
        self.module_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleRequest {
        static instance: GetModuleRequest = GetModuleRequest {
            module_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `GetModuleRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GetModuleResponse)
pub struct GetModuleResponse {
    // message fields
    // @@protoc_insertion_point(field:GetModuleResponse.module)
    pub module: ::protobuf::MessageField<Module>,
    // @@protoc_insertion_point(field:GetModuleResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:GetModuleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleResponse {
    fn default() -> &'a GetModuleResponse {
        <GetModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleResponse {
    pub fn new() -> GetModuleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Module>(
            "module",
            |m: &GetModuleResponse| { &m.module },
            |m: &mut GetModuleResponse| { &mut m.module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &GetModuleResponse| { &m.error },
            |m: &mut GetModuleResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleResponse>(
            "GetModuleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleResponse {
    const NAME: &'static str = "GetModuleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.module.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleResponse {
        GetModuleResponse::new()
    }

    fn clear(&mut self) {
        self.module.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleResponse {
        static instance: GetModuleResponse = GetModuleResponse {
            module: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/modules:`
///  Return paginated list of all modules.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListModulesRequest)
pub struct ListModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:ListModulesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // @@protoc_insertion_point(field:ListModulesRequest.sort)
    pub sort: ::protobuf::MessageField<Sort>,
    // special fields
    // @@protoc_insertion_point(special_field:ListModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModulesRequest {
    fn default() -> &'a ListModulesRequest {
        <ListModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModulesRequest {
    pub fn new() -> ListModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &ListModulesRequest| { &m.pagination },
            |m: &mut ListModulesRequest| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Sort>(
            "sort",
            |m: &ListModulesRequest| { &m.sort },
            |m: &mut ListModulesRequest| { &mut m.sort },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModulesRequest>(
            "ListModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModulesRequest {
    const NAME: &'static str = "ListModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sort)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.sort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModulesRequest {
        ListModulesRequest::new()
    }

    fn clear(&mut self) {
        self.pagination.clear();
        self.sort.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModulesRequest {
        static instance: ListModulesRequest = ListModulesRequest {
            pagination: ::protobuf::MessageField::none(),
            sort: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `ListModulesRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListModulesResponse)
pub struct ListModulesResponse {
    // message fields
    // @@protoc_insertion_point(field:ListModulesResponse.modules)
    pub modules: ::std::vec::Vec<Module>,
    // @@protoc_insertion_point(field:ListModulesResponse.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    ///  the full count of results in the database (not the count of this message's
    ///  `modules`).
    // @@protoc_insertion_point(field:ListModulesResponse.total)
    pub total: u64,
    // @@protoc_insertion_point(field:ListModulesResponse.sort)
    pub sort: ::protobuf::MessageField<Sort>,
    // @@protoc_insertion_point(field:ListModulesResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:ListModulesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModulesResponse {
    fn default() -> &'a ListModulesResponse {
        <ListModulesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListModulesResponse {
    pub fn new() -> ListModulesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &ListModulesResponse| { &m.modules },
            |m: &mut ListModulesResponse| { &mut m.modules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &ListModulesResponse| { &m.pagination },
            |m: &mut ListModulesResponse| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &ListModulesResponse| { &m.total },
            |m: &mut ListModulesResponse| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Sort>(
            "sort",
            |m: &ListModulesResponse| { &m.sort },
            |m: &mut ListModulesResponse| { &mut m.sort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &ListModulesResponse| { &m.error },
            |m: &mut ListModulesResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModulesResponse>(
            "ListModulesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModulesResponse {
    const NAME: &'static str = "ListModulesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.modules.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                24 => {
                    self.total = is.read_uint64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sort)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.total);
        }
        if let Some(v) = self.sort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.total != 0 {
            os.write_uint64(3, self.total)?;
        }
        if let Some(v) = self.sort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModulesResponse {
        ListModulesResponse::new()
    }

    fn clear(&mut self) {
        self.modules.clear();
        self.pagination.clear();
        self.total = 0;
        self.sort.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModulesResponse {
        static instance: ListModulesResponse = ListModulesResponse {
            modules: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            total: 0,
            sort: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModulesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModulesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModulesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModulesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/search:`
///  Search for modules based on filter params provided (which should be any
///  dimension of the module schema, or string search in any metadata value).
///  Return a paginated list of matching modules.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SearchModulesRequest)
pub struct SearchModulesRequest {
    // message fields
    ///  ID for this module, generated by the database.
    // @@protoc_insertion_point(field:SearchModulesRequest.id)
    pub id: ::std::option::Option<i64>,
    ///  original name of the binary module file
    // @@protoc_insertion_point(field:SearchModulesRequest.hash)
    pub hash: ::std::option::Option<::std::string::String>,
    ///  function imports called by the module (see:
    ///  <https://github.com/WebAssembly/design/blob/main/Modules.md#imports>)
    // @@protoc_insertion_point(field:SearchModulesRequest.imports)
    pub imports: ::std::vec::Vec<Import>,
    ///  function exports provided by the module (see:
    ///  <https://github.com/WebAssembly/design/blob/main/Modules.md#exports>)
    // @@protoc_insertion_point(field:SearchModulesRequest.exports)
    pub exports: ::std::vec::Vec<Export>,
    ///  minimum size in bytes of the module
    // @@protoc_insertion_point(field:SearchModulesRequest.min_size)
    pub min_size: ::std::option::Option<u64>,
    ///  maximum size in bytes of the module
    // @@protoc_insertion_point(field:SearchModulesRequest.max_size)
    pub max_size: ::std::option::Option<u64>,
    ///  optional path or locator to the module (TODO: maybe this is better stored
    ///  as metadata)
    // @@protoc_insertion_point(field:SearchModulesRequest.location)
    pub location: ::std::option::Option<::std::string::String>,
    ///  programming language used to produce this module
    // @@protoc_insertion_point(field:SearchModulesRequest.source_language)
    pub source_language: ::std::option::Option<::protobuf::EnumOrUnknown<SourceLanguage>>,
    ///  arbitrary metadata provided by the operator of this module
    // @@protoc_insertion_point(field:SearchModulesRequest.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  timestamp when this module was loaded and stored
    // @@protoc_insertion_point(field:SearchModulesRequest.inserted_before)
    pub inserted_before: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  timestamp when this module was loaded and stored
    // @@protoc_insertion_point(field:SearchModulesRequest.inserted_after)
    pub inserted_after: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  the interned strings stored in the wasm binary (panic/abort messages, etc.)
    // @@protoc_insertion_point(field:SearchModulesRequest.strings)
    pub strings: ::std::vec::Vec<::std::string::String>,
    ///  match on any function name in an import or export.
    // @@protoc_insertion_point(field:SearchModulesRequest.function_name)
    pub function_name: ::std::option::Option<::std::string::String>,
    ///  match on the module name e.g. `env` or `wasi_snapshot_preview1`
    // @@protoc_insertion_point(field:SearchModulesRequest.module_name)
    pub module_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SearchModulesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // @@protoc_insertion_point(field:SearchModulesRequest.sort)
    pub sort: ::protobuf::MessageField<Sort>,
    // special fields
    // @@protoc_insertion_point(special_field:SearchModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SearchModulesRequest {
    fn default() -> &'a SearchModulesRequest {
        <SearchModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SearchModulesRequest {
    pub fn new() -> SearchModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &SearchModulesRequest| { &m.id },
            |m: &mut SearchModulesRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &SearchModulesRequest| { &m.hash },
            |m: &mut SearchModulesRequest| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "imports",
            |m: &SearchModulesRequest| { &m.imports },
            |m: &mut SearchModulesRequest| { &mut m.imports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exports",
            |m: &SearchModulesRequest| { &m.exports },
            |m: &mut SearchModulesRequest| { &mut m.exports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_size",
            |m: &SearchModulesRequest| { &m.min_size },
            |m: &mut SearchModulesRequest| { &mut m.min_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_size",
            |m: &SearchModulesRequest| { &m.max_size },
            |m: &mut SearchModulesRequest| { &mut m.max_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "location",
            |m: &SearchModulesRequest| { &m.location },
            |m: &mut SearchModulesRequest| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_language",
            |m: &SearchModulesRequest| { &m.source_language },
            |m: &mut SearchModulesRequest| { &mut m.source_language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metadata",
            |m: &SearchModulesRequest| { &m.metadata },
            |m: &mut SearchModulesRequest| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "inserted_before",
            |m: &SearchModulesRequest| { &m.inserted_before },
            |m: &mut SearchModulesRequest| { &mut m.inserted_before },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "inserted_after",
            |m: &SearchModulesRequest| { &m.inserted_after },
            |m: &mut SearchModulesRequest| { &mut m.inserted_after },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "strings",
            |m: &SearchModulesRequest| { &m.strings },
            |m: &mut SearchModulesRequest| { &mut m.strings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "function_name",
            |m: &SearchModulesRequest| { &m.function_name },
            |m: &mut SearchModulesRequest| { &mut m.function_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "module_name",
            |m: &SearchModulesRequest| { &m.module_name },
            |m: &mut SearchModulesRequest| { &mut m.module_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &SearchModulesRequest| { &m.pagination },
            |m: &mut SearchModulesRequest| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Sort>(
            "sort",
            |m: &SearchModulesRequest| { &m.sort },
            |m: &mut SearchModulesRequest| { &mut m.sort },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SearchModulesRequest>(
            "SearchModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SearchModulesRequest {
    const NAME: &'static str = "SearchModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.hash = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.imports.push(is.read_message()?);
                },
                42 => {
                    self.exports.push(is.read_message()?);
                },
                48 => {
                    self.min_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.max_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                66 => {
                    self.location = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.source_language = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                82 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inserted_before)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inserted_after)?;
                },
                106 => {
                    self.strings.push(is.read_string()?);
                },
                114 => {
                    self.function_name = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.module_name = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sort)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.imports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.exports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.min_size {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.max_size {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.source_language {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.inserted_before.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.inserted_after.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.strings {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        if let Some(v) = self.function_name.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.module_name.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sort.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.hash.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.imports {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.exports {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.min_size {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.max_size {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.location.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.source_language {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(82)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.inserted_before.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.inserted_after.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        for v in &self.strings {
            os.write_string(13, &v)?;
        };
        if let Some(v) = self.function_name.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.module_name.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.sort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SearchModulesRequest {
        SearchModulesRequest::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.hash = ::std::option::Option::None;
        self.imports.clear();
        self.exports.clear();
        self.min_size = ::std::option::Option::None;
        self.max_size = ::std::option::Option::None;
        self.location = ::std::option::Option::None;
        self.source_language = ::std::option::Option::None;
        self.metadata.clear();
        self.inserted_before.clear();
        self.inserted_after.clear();
        self.strings.clear();
        self.function_name = ::std::option::Option::None;
        self.module_name = ::std::option::Option::None;
        self.pagination.clear();
        self.sort.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SearchModulesRequest {
        static instance: ::protobuf::rt::Lazy<SearchModulesRequest> = ::protobuf::rt::Lazy::new();
        instance.get(SearchModulesRequest::new)
    }
}

impl ::protobuf::MessageFull for SearchModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SearchModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SearchModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `SearchModulesRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SearchModulesResponse)
pub struct SearchModulesResponse {
    // message fields
    // @@protoc_insertion_point(field:SearchModulesResponse.modules)
    pub modules: ::std::vec::Vec<Module>,
    // @@protoc_insertion_point(field:SearchModulesResponse.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    ///  the full count of results in the database (not the count of this message's
    ///  `modules`).
    // @@protoc_insertion_point(field:SearchModulesResponse.total)
    pub total: u64,
    // @@protoc_insertion_point(field:SearchModulesResponse.sort)
    pub sort: ::protobuf::MessageField<Sort>,
    // @@protoc_insertion_point(field:SearchModulesResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:SearchModulesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SearchModulesResponse {
    fn default() -> &'a SearchModulesResponse {
        <SearchModulesResponse as ::protobuf::Message>::default_instance()
    }
}

impl SearchModulesResponse {
    pub fn new() -> SearchModulesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &SearchModulesResponse| { &m.modules },
            |m: &mut SearchModulesResponse| { &mut m.modules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &SearchModulesResponse| { &m.pagination },
            |m: &mut SearchModulesResponse| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &SearchModulesResponse| { &m.total },
            |m: &mut SearchModulesResponse| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Sort>(
            "sort",
            |m: &SearchModulesResponse| { &m.sort },
            |m: &mut SearchModulesResponse| { &mut m.sort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &SearchModulesResponse| { &m.error },
            |m: &mut SearchModulesResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SearchModulesResponse>(
            "SearchModulesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SearchModulesResponse {
    const NAME: &'static str = "SearchModulesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.modules.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                24 => {
                    self.total = is.read_uint64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sort)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.total);
        }
        if let Some(v) = self.sort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.total != 0 {
            os.write_uint64(3, self.total)?;
        }
        if let Some(v) = self.sort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SearchModulesResponse {
        SearchModulesResponse::new()
    }

    fn clear(&mut self) {
        self.modules.clear();
        self.pagination.clear();
        self.total = 0;
        self.sort.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SearchModulesResponse {
        static instance: SearchModulesResponse = SearchModulesResponse {
            modules: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            total: 0,
            sort: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SearchModulesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SearchModulesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SearchModulesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchModulesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `DELETE /api/v1/module:`
///  Remove a module from the database by its ID. Return the module IDs & hashes.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeleteModulesRequest)
pub struct DeleteModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:DeleteModulesRequest.module_ids)
    pub module_ids: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:DeleteModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModulesRequest {
    fn default() -> &'a DeleteModulesRequest {
        <DeleteModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModulesRequest {
    pub fn new() -> DeleteModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "module_ids",
            |m: &DeleteModulesRequest| { &m.module_ids },
            |m: &mut DeleteModulesRequest| { &mut m.module_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModulesRequest>(
            "DeleteModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModulesRequest {
    const NAME: &'static str = "DeleteModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int64_into(&mut self.module_ids)?;
                },
                8 => {
                    self.module_ids.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.module_ids {
            my_size += ::protobuf::rt::int64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.module_ids {
            os.write_int64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModulesRequest {
        DeleteModulesRequest::new()
    }

    fn clear(&mut self) {
        self.module_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModulesRequest {
        static instance: DeleteModulesRequest = DeleteModulesRequest {
            module_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `DeleteModulesRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeleteModulesResponse)
pub struct DeleteModulesResponse {
    // message fields
    // @@protoc_insertion_point(field:DeleteModulesResponse.module_id_hash)
    pub module_id_hash: ::std::collections::HashMap<i64, ::std::string::String>,
    // @@protoc_insertion_point(field:DeleteModulesResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:DeleteModulesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModulesResponse {
    fn default() -> &'a DeleteModulesResponse {
        <DeleteModulesResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModulesResponse {
    pub fn new() -> DeleteModulesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "module_id_hash",
            |m: &DeleteModulesResponse| { &m.module_id_hash },
            |m: &mut DeleteModulesResponse| { &mut m.module_id_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &DeleteModulesResponse| { &m.error },
            |m: &mut DeleteModulesResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModulesResponse>(
            "DeleteModulesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModulesResponse {
    const NAME: &'static str = "DeleteModulesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int64()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.module_id_hash.insert(key, value);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.module_id_hash {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.module_id_hash {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int64(1, *k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModulesResponse {
        DeleteModulesResponse::new()
    }

    fn clear(&mut self) {
        self.module_id_hash.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModulesResponse {
        static instance: ::protobuf::rt::Lazy<DeleteModulesResponse> = ::protobuf::rt::Lazy::new();
        instance.get(DeleteModulesResponse::new)
    }
}

impl ::protobuf::MessageFull for DeleteModulesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModulesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModulesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModulesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/audit:`
///  Return a list of modules which match the outcome requirements using the provided checkfile.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AuditModulesRequest)
pub struct AuditModulesRequest {
    // message fields
    ///  the YAML checkfile (e.g. mod.yaml) bytes
    // @@protoc_insertion_point(field:AuditModulesRequest.checkfile)
    pub checkfile: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:AuditModulesRequest.outcome)
    pub outcome: ::protobuf::EnumOrUnknown<AuditOutcome>,
    // @@protoc_insertion_point(field:AuditModulesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:AuditModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuditModulesRequest {
    fn default() -> &'a AuditModulesRequest {
        <AuditModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuditModulesRequest {
    pub fn new() -> AuditModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "checkfile",
            |m: &AuditModulesRequest| { &m.checkfile },
            |m: &mut AuditModulesRequest| { &mut m.checkfile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "outcome",
            |m: &AuditModulesRequest| { &m.outcome },
            |m: &mut AuditModulesRequest| { &mut m.outcome },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &AuditModulesRequest| { &m.pagination },
            |m: &mut AuditModulesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuditModulesRequest>(
            "AuditModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuditModulesRequest {
    const NAME: &'static str = "AuditModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.checkfile = is.read_bytes()?;
                },
                16 => {
                    self.outcome = is.read_enum_or_unknown()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.checkfile.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.checkfile);
        }
        if self.outcome != ::protobuf::EnumOrUnknown::new(AuditOutcome::PASS) {
            my_size += ::protobuf::rt::int32_size(2, self.outcome.value());
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.checkfile.is_empty() {
            os.write_bytes(1, &self.checkfile)?;
        }
        if self.outcome != ::protobuf::EnumOrUnknown::new(AuditOutcome::PASS) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.outcome))?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuditModulesRequest {
        AuditModulesRequest::new()
    }

    fn clear(&mut self) {
        self.checkfile.clear();
        self.outcome = ::protobuf::EnumOrUnknown::new(AuditOutcome::PASS);
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuditModulesRequest {
        static instance: AuditModulesRequest = AuditModulesRequest {
            checkfile: ::std::vec::Vec::new(),
            outcome: ::protobuf::EnumOrUnknown::from_i32(0),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AuditModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuditModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuditModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `AuditModulesRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AuditModulesResponse)
pub struct AuditModulesResponse {
    // message fields
    ///  each record contains the ID of the invalid Module which failed the audit, as well as the failure 
    ///  report produced by the validation check (encoded in JSON)
    // @@protoc_insertion_point(field:AuditModulesResponse.invalid_module_report)
    pub invalid_module_report: ::std::collections::HashMap<i64, ::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:AuditModulesResponse.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    ///  the full count of results in the database (not the count of this message's
    ///  `modules`).
    // @@protoc_insertion_point(field:AuditModulesResponse.total)
    pub total: u64,
    // @@protoc_insertion_point(field:AuditModulesResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:AuditModulesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuditModulesResponse {
    fn default() -> &'a AuditModulesResponse {
        <AuditModulesResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuditModulesResponse {
    pub fn new() -> AuditModulesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "invalid_module_report",
            |m: &AuditModulesResponse| { &m.invalid_module_report },
            |m: &mut AuditModulesResponse| { &mut m.invalid_module_report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &AuditModulesResponse| { &m.pagination },
            |m: &mut AuditModulesResponse| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &AuditModulesResponse| { &m.total },
            |m: &mut AuditModulesResponse| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &AuditModulesResponse| { &m.error },
            |m: &mut AuditModulesResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuditModulesResponse>(
            "AuditModulesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuditModulesResponse {
    const NAME: &'static str = "AuditModulesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int64()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.invalid_module_report.insert(key, value);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                24 => {
                    self.total = is.read_uint64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.invalid_module_report {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.total);
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.invalid_module_report {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int64(1, *k)?;
            os.write_bytes(2, &v)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.total != 0 {
            os.write_uint64(3, self.total)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuditModulesResponse {
        AuditModulesResponse::new()
    }

    fn clear(&mut self) {
        self.invalid_module_report.clear();
        self.pagination.clear();
        self.total = 0;
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuditModulesResponse {
        static instance: ::protobuf::rt::Lazy<AuditModulesResponse> = ::protobuf::rt::Lazy::new();
        instance.get(AuditModulesResponse::new)
    }
}

impl ::protobuf::MessageFull for AuditModulesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuditModulesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuditModulesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditModulesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/diff:`
///  Return the diff of two modules
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DiffRequest)
pub struct DiffRequest {
    // message fields
    // @@protoc_insertion_point(field:DiffRequest.module1)
    pub module1: i64,
    // @@protoc_insertion_point(field:DiffRequest.module2)
    pub module2: i64,
    // @@protoc_insertion_point(field:DiffRequest.color_terminal)
    pub color_terminal: bool,
    // @@protoc_insertion_point(field:DiffRequest.with_context)
    pub with_context: bool,
    // special fields
    // @@protoc_insertion_point(special_field:DiffRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DiffRequest {
    fn default() -> &'a DiffRequest {
        <DiffRequest as ::protobuf::Message>::default_instance()
    }
}

impl DiffRequest {
    pub fn new() -> DiffRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module1",
            |m: &DiffRequest| { &m.module1 },
            |m: &mut DiffRequest| { &mut m.module1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module2",
            |m: &DiffRequest| { &m.module2 },
            |m: &mut DiffRequest| { &mut m.module2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_terminal",
            |m: &DiffRequest| { &m.color_terminal },
            |m: &mut DiffRequest| { &mut m.color_terminal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "with_context",
            |m: &DiffRequest| { &m.with_context },
            |m: &mut DiffRequest| { &mut m.with_context },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DiffRequest>(
            "DiffRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DiffRequest {
    const NAME: &'static str = "DiffRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.module1 = is.read_int64()?;
                },
                16 => {
                    self.module2 = is.read_int64()?;
                },
                24 => {
                    self.color_terminal = is.read_bool()?;
                },
                32 => {
                    self.with_context = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.module1 != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.module1);
        }
        if self.module2 != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.module2);
        }
        if self.color_terminal != false {
            my_size += 1 + 1;
        }
        if self.with_context != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.module1 != 0 {
            os.write_int64(1, self.module1)?;
        }
        if self.module2 != 0 {
            os.write_int64(2, self.module2)?;
        }
        if self.color_terminal != false {
            os.write_bool(3, self.color_terminal)?;
        }
        if self.with_context != false {
            os.write_bool(4, self.with_context)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DiffRequest {
        DiffRequest::new()
    }

    fn clear(&mut self) {
        self.module1 = 0;
        self.module2 = 0;
        self.color_terminal = false;
        self.with_context = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DiffRequest {
        static instance: DiffRequest = DiffRequest {
            module1: 0,
            module2: 0,
            color_terminal: false,
            with_context: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DiffRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DiffRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DiffRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiffRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to `DiffRequest`, contains a text representation of the difference
///  between the two specified modules.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DiffResponse)
pub struct DiffResponse {
    // message fields
    // @@protoc_insertion_point(field:DiffResponse.diff)
    pub diff: ::std::string::String,
    // @@protoc_insertion_point(field:DiffResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:DiffResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DiffResponse {
    fn default() -> &'a DiffResponse {
        <DiffResponse as ::protobuf::Message>::default_instance()
    }
}

impl DiffResponse {
    pub fn new() -> DiffResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "diff",
            |m: &DiffResponse| { &m.diff },
            |m: &mut DiffResponse| { &mut m.diff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &DiffResponse| { &m.error },
            |m: &mut DiffResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DiffResponse>(
            "DiffResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DiffResponse {
    const NAME: &'static str = "DiffResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.diff = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.diff.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.diff);
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.diff.is_empty() {
            os.write_string(1, &self.diff)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DiffResponse {
        DiffResponse::new()
    }

    fn clear(&mut self) {
        self.diff.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DiffResponse {
        static instance: DiffResponse = DiffResponse {
            diff: ::std::string::String::new(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DiffResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DiffResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DiffResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiffResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/validate:`
///  Return the failure report (if applicable) of a wasm module validation against a given checkfile.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ValidateModuleRequest)
pub struct ValidateModuleRequest {
    // message fields
    ///  the YAML checkfile (e.g. mod.yaml) bytes
    // @@protoc_insertion_point(field:ValidateModuleRequest.checkfile)
    pub checkfile: ::std::vec::Vec<u8>,
    // message oneof groups
    pub module_input: ::std::option::Option<validate_module_request::Module_input>,
    // special fields
    // @@protoc_insertion_point(special_field:ValidateModuleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidateModuleRequest {
    fn default() -> &'a ValidateModuleRequest {
        <ValidateModuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl ValidateModuleRequest {
    pub fn new() -> ValidateModuleRequest {
        ::std::default::Default::default()
    }

    // bytes module = 2;

    pub fn module(&self) -> &[u8] {
        match self.module_input {
            ::std::option::Option::Some(validate_module_request::Module_input::Module(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_module(&mut self) {
        self.module_input = ::std::option::Option::None;
    }

    pub fn has_module(&self) -> bool {
        match self.module_input {
            ::std::option::Option::Some(validate_module_request::Module_input::Module(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_module(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_input = ::std::option::Option::Some(validate_module_request::Module_input::Module(v))
    }

    // Mutable pointer to the field.
    pub fn mut_module(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(validate_module_request::Module_input::Module(_)) = self.module_input {
        } else {
            self.module_input = ::std::option::Option::Some(validate_module_request::Module_input::Module(::std::vec::Vec::new()));
        }
        match self.module_input {
            ::std::option::Option::Some(validate_module_request::Module_input::Module(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_module(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_module() {
            match self.module_input.take() {
                ::std::option::Option::Some(validate_module_request::Module_input::Module(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // int64 module_id = 3;

    pub fn module_id(&self) -> i64 {
        match self.module_input {
            ::std::option::Option::Some(validate_module_request::Module_input::ModuleId(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_module_id(&mut self) {
        self.module_input = ::std::option::Option::None;
    }

    pub fn has_module_id(&self) -> bool {
        match self.module_input {
            ::std::option::Option::Some(validate_module_request::Module_input::ModuleId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_module_id(&mut self, v: i64) {
        self.module_input = ::std::option::Option::Some(validate_module_request::Module_input::ModuleId(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "checkfile",
            |m: &ValidateModuleRequest| { &m.checkfile },
            |m: &mut ValidateModuleRequest| { &mut m.checkfile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "module",
            ValidateModuleRequest::has_module,
            ValidateModuleRequest::module,
            ValidateModuleRequest::set_module,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "module_id",
            ValidateModuleRequest::has_module_id,
            ValidateModuleRequest::module_id,
            ValidateModuleRequest::set_module_id,
        ));
        oneofs.push(validate_module_request::Module_input::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidateModuleRequest>(
            "ValidateModuleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidateModuleRequest {
    const NAME: &'static str = "ValidateModuleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.checkfile = is.read_bytes()?;
                },
                18 => {
                    self.module_input = ::std::option::Option::Some(validate_module_request::Module_input::Module(is.read_bytes()?));
                },
                24 => {
                    self.module_input = ::std::option::Option::Some(validate_module_request::Module_input::ModuleId(is.read_int64()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.checkfile.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.checkfile);
        }
        if let ::std::option::Option::Some(ref v) = self.module_input {
            match v {
                &validate_module_request::Module_input::Module(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &validate_module_request::Module_input::ModuleId(v) => {
                    my_size += ::protobuf::rt::int64_size(3, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.checkfile.is_empty() {
            os.write_bytes(1, &self.checkfile)?;
        }
        if let ::std::option::Option::Some(ref v) = self.module_input {
            match v {
                &validate_module_request::Module_input::Module(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &validate_module_request::Module_input::ModuleId(v) => {
                    os.write_int64(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidateModuleRequest {
        ValidateModuleRequest::new()
    }

    fn clear(&mut self) {
        self.checkfile.clear();
        self.module_input = ::std::option::Option::None;
        self.module_input = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidateModuleRequest {
        static instance: ValidateModuleRequest = ValidateModuleRequest {
            checkfile: ::std::vec::Vec::new(),
            module_input: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidateModuleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidateModuleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidateModuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidateModuleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ValidateModuleRequest`
pub mod validate_module_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:ValidateModuleRequest.module_input)
    pub enum Module_input {
        // @@protoc_insertion_point(oneof_field:ValidateModuleRequest.module)
        Module(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:ValidateModuleRequest.module_id)
        ModuleId(i64),
    }

    impl ::protobuf::Oneof for Module_input {
    }

    impl ::protobuf::OneofFull for Module_input {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ValidateModuleRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("module_input").unwrap()).clone()
        }
    }

    impl Module_input {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Module_input>("module_input")
        }
    }
}

///  The failure report produced by the validation check (encoded in JSON).
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ValidateModuleResponse)
pub struct ValidateModuleResponse {
    // message fields
    // @@protoc_insertion_point(field:ValidateModuleResponse.invalid_module_report)
    pub invalid_module_report: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:ValidateModuleResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:ValidateModuleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidateModuleResponse {
    fn default() -> &'a ValidateModuleResponse {
        <ValidateModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl ValidateModuleResponse {
    pub fn new() -> ValidateModuleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "invalid_module_report",
            |m: &ValidateModuleResponse| { &m.invalid_module_report },
            |m: &mut ValidateModuleResponse| { &mut m.invalid_module_report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &ValidateModuleResponse| { &m.error },
            |m: &mut ValidateModuleResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidateModuleResponse>(
            "ValidateModuleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidateModuleResponse {
    const NAME: &'static str = "ValidateModuleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invalid_module_report = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.invalid_module_report.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.invalid_module_report);
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.invalid_module_report.is_empty() {
            os.write_bytes(1, &self.invalid_module_report)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidateModuleResponse {
        ValidateModuleResponse::new()
    }

    fn clear(&mut self) {
        self.invalid_module_report.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidateModuleResponse {
        static instance: ValidateModuleResponse = ValidateModuleResponse {
            invalid_module_report: ::std::vec::Vec::new(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidateModuleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidateModuleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidateModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidateModuleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `POST /api/v1/module_graph:`
///  Return a single module_graph.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GetModuleGraphRequest)
pub struct GetModuleGraphRequest {
    // message fields
    // @@protoc_insertion_point(field:GetModuleGraphRequest.module_id)
    pub module_id: i64,
    // special fields
    // @@protoc_insertion_point(special_field:GetModuleGraphRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleGraphRequest {
    fn default() -> &'a GetModuleGraphRequest {
        <GetModuleGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleGraphRequest {
    pub fn new() -> GetModuleGraphRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &GetModuleGraphRequest| { &m.module_id },
            |m: &mut GetModuleGraphRequest| { &mut m.module_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleGraphRequest>(
            "GetModuleGraphRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleGraphRequest {
    const NAME: &'static str = "GetModuleGraphRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.module_id = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.module_id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.module_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.module_id != 0 {
            os.write_int64(1, self.module_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleGraphRequest {
        GetModuleGraphRequest::new()
    }

    fn clear(&mut self) {
        self.module_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleGraphRequest {
        static instance: GetModuleGraphRequest = GetModuleGraphRequest {
            module_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleGraphRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleGraphRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleGraphRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The message returned in response to a `GetModuleGraphRequest`.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GetModuleGraphResponse)
pub struct GetModuleGraphResponse {
    // message fields
    // @@protoc_insertion_point(field:GetModuleGraphResponse.module_graph)
    pub module_graph: ::protobuf::MessageField<ModuleGraph>,
    // @@protoc_insertion_point(field:GetModuleGraphResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:GetModuleGraphResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleGraphResponse {
    fn default() -> &'a GetModuleGraphResponse {
        <GetModuleGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleGraphResponse {
    pub fn new() -> GetModuleGraphResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ModuleGraph>(
            "module_graph",
            |m: &GetModuleGraphResponse| { &m.module_graph },
            |m: &mut GetModuleGraphResponse| { &mut m.module_graph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &GetModuleGraphResponse| { &m.error },
            |m: &mut GetModuleGraphResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleGraphResponse>(
            "GetModuleGraphResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleGraphResponse {
    const NAME: &'static str = "GetModuleGraphResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module_graph)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.module_graph.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.module_graph.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleGraphResponse {
        GetModuleGraphResponse::new()
    }

    fn clear(&mut self) {
        self.module_graph.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleGraphResponse {
        static instance: GetModuleGraphResponse = GetModuleGraphResponse {
            module_graph: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleGraphResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleGraphResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleGraphResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PUT /api/v1/plugin:
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RegisterPluginRequest)
pub struct RegisterPluginRequest {
    // message fields
    // @@protoc_insertion_point(field:RegisterPluginRequest.identifier)
    pub identifier: ::std::string::String,
    // @@protoc_insertion_point(field:RegisterPluginRequest.code)
    pub code: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:RegisterPluginRequest.init_config)
    pub init_config: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:RegisterPluginRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegisterPluginRequest {
    fn default() -> &'a RegisterPluginRequest {
        <RegisterPluginRequest as ::protobuf::Message>::default_instance()
    }
}

impl RegisterPluginRequest {
    pub fn new() -> RegisterPluginRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "identifier",
            |m: &RegisterPluginRequest| { &m.identifier },
            |m: &mut RegisterPluginRequest| { &mut m.identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &RegisterPluginRequest| { &m.code },
            |m: &mut RegisterPluginRequest| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "init_config",
            |m: &RegisterPluginRequest| { &m.init_config },
            |m: &mut RegisterPluginRequest| { &mut m.init_config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegisterPluginRequest>(
            "RegisterPluginRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegisterPluginRequest {
    const NAME: &'static str = "RegisterPluginRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.identifier = is.read_string()?;
                },
                18 => {
                    self.code = is.read_bytes()?;
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.init_config.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.identifier.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identifier);
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.code);
        }
        for (k, v) in &self.init_config {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.identifier.is_empty() {
            os.write_string(1, &self.identifier)?;
        }
        if !self.code.is_empty() {
            os.write_bytes(2, &self.code)?;
        }
        for (k, v) in &self.init_config {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegisterPluginRequest {
        RegisterPluginRequest::new()
    }

    fn clear(&mut self) {
        self.identifier.clear();
        self.code.clear();
        self.init_config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegisterPluginRequest {
        static instance: ::protobuf::rt::Lazy<RegisterPluginRequest> = ::protobuf::rt::Lazy::new();
        instance.get(RegisterPluginRequest::new)
    }
}

impl ::protobuf::MessageFull for RegisterPluginRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegisterPluginRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegisterPluginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterPluginRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RegisterPluginResponse)
pub struct RegisterPluginResponse {
    // message fields
    // @@protoc_insertion_point(field:RegisterPluginResponse.hash)
    pub hash: ::std::string::String,
    // @@protoc_insertion_point(field:RegisterPluginResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:RegisterPluginResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegisterPluginResponse {
    fn default() -> &'a RegisterPluginResponse {
        <RegisterPluginResponse as ::protobuf::Message>::default_instance()
    }
}

impl RegisterPluginResponse {
    pub fn new() -> RegisterPluginResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &RegisterPluginResponse| { &m.hash },
            |m: &mut RegisterPluginResponse| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &RegisterPluginResponse| { &m.error },
            |m: &mut RegisterPluginResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegisterPluginResponse>(
            "RegisterPluginResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegisterPluginResponse {
    const NAME: &'static str = "RegisterPluginResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hash = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hash);
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_string(1, &self.hash)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegisterPluginResponse {
        RegisterPluginResponse::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegisterPluginResponse {
        static instance: RegisterPluginResponse = RegisterPluginResponse {
            hash: ::std::string::String::new(),
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegisterPluginResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegisterPluginResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegisterPluginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterPluginResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  POST /api/v1/plugin:
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CallPluginRequest)
pub struct CallPluginRequest {
    // message fields
    // @@protoc_insertion_point(field:CallPluginRequest.function_name)
    pub function_name: ::std::string::String,
    // @@protoc_insertion_point(field:CallPluginRequest.identifier)
    pub identifier: ::std::string::String,
    // @@protoc_insertion_point(field:CallPluginRequest.input)
    pub input: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:CallPluginRequest.config)
    pub config: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:CallPluginRequest.hash)
    pub hash: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CallPluginRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CallPluginRequest {
    fn default() -> &'a CallPluginRequest {
        <CallPluginRequest as ::protobuf::Message>::default_instance()
    }
}

impl CallPluginRequest {
    pub fn new() -> CallPluginRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "function_name",
            |m: &CallPluginRequest| { &m.function_name },
            |m: &mut CallPluginRequest| { &mut m.function_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "identifier",
            |m: &CallPluginRequest| { &m.identifier },
            |m: &mut CallPluginRequest| { &mut m.identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input",
            |m: &CallPluginRequest| { &m.input },
            |m: &mut CallPluginRequest| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "config",
            |m: &CallPluginRequest| { &m.config },
            |m: &mut CallPluginRequest| { &mut m.config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &CallPluginRequest| { &m.hash },
            |m: &mut CallPluginRequest| { &mut m.hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CallPluginRequest>(
            "CallPluginRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CallPluginRequest {
    const NAME: &'static str = "CallPluginRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.function_name = is.read_string()?;
                },
                18 => {
                    self.identifier = is.read_string()?;
                },
                26 => {
                    self.input = is.read_bytes()?;
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.config.insert(key, value);
                },
                42 => {
                    self.hash = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.function_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.function_name);
        }
        if !self.identifier.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.identifier);
        }
        if !self.input.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.input);
        }
        for (k, v) in &self.config {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.function_name.is_empty() {
            os.write_string(1, &self.function_name)?;
        }
        if !self.identifier.is_empty() {
            os.write_string(2, &self.identifier)?;
        }
        if !self.input.is_empty() {
            os.write_bytes(3, &self.input)?;
        }
        for (k, v) in &self.config {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.hash.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CallPluginRequest {
        CallPluginRequest::new()
    }

    fn clear(&mut self) {
        self.function_name.clear();
        self.identifier.clear();
        self.input.clear();
        self.config.clear();
        self.hash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CallPluginRequest {
        static instance: ::protobuf::rt::Lazy<CallPluginRequest> = ::protobuf::rt::Lazy::new();
        instance.get(CallPluginRequest::new)
    }
}

impl ::protobuf::MessageFull for CallPluginRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CallPluginRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CallPluginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallPluginRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CallPluginResponse)
pub struct CallPluginResponse {
    // message fields
    // @@protoc_insertion_point(field:CallPluginResponse.output)
    pub output: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:CallPluginResponse.return_code)
    pub return_code: i32,
    // @@protoc_insertion_point(field:CallPluginResponse.error)
    pub error: ::protobuf::MessageField<Error>,
    // special fields
    // @@protoc_insertion_point(special_field:CallPluginResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CallPluginResponse {
    fn default() -> &'a CallPluginResponse {
        <CallPluginResponse as ::protobuf::Message>::default_instance()
    }
}

impl CallPluginResponse {
    pub fn new() -> CallPluginResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "output",
            |m: &CallPluginResponse| { &m.output },
            |m: &mut CallPluginResponse| { &mut m.output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "return_code",
            |m: &CallPluginResponse| { &m.return_code },
            |m: &mut CallPluginResponse| { &mut m.return_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Error>(
            "error",
            |m: &CallPluginResponse| { &m.error },
            |m: &mut CallPluginResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CallPluginResponse>(
            "CallPluginResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CallPluginResponse {
    const NAME: &'static str = "CallPluginResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.output = is.read_bytes()?;
                },
                16 => {
                    self.return_code = is.read_int32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.output.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.output);
        }
        if self.return_code != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.return_code);
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.output.is_empty() {
            os.write_bytes(1, &self.output)?;
        }
        if self.return_code != 0 {
            os.write_int32(2, self.return_code)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CallPluginResponse {
        CallPluginResponse::new()
    }

    fn clear(&mut self) {
        self.output.clear();
        self.return_code = 0;
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CallPluginResponse {
        static instance: CallPluginResponse = CallPluginResponse {
            output: ::std::vec::Vec::new(),
            return_code: 0,
            error: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CallPluginResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CallPluginResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CallPluginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallPluginResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Used to type the arguments and return types from wasm elements such as import
///  and export functions.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ValType)
pub enum ValType {
    // @@protoc_insertion_point(enum_value:ValType.I32)
    I32 = 0,
    // @@protoc_insertion_point(enum_value:ValType.I64)
    I64 = 1,
    // @@protoc_insertion_point(enum_value:ValType.F32)
    F32 = 2,
    // @@protoc_insertion_point(enum_value:ValType.F64)
    F64 = 3,
    // @@protoc_insertion_point(enum_value:ValType.V128)
    V128 = 4,
    // @@protoc_insertion_point(enum_value:ValType.FuncRef)
    FuncRef = 5,
    // @@protoc_insertion_point(enum_value:ValType.ExternRef)
    ExternRef = 6,
}

impl ::protobuf::Enum for ValType {
    const NAME: &'static str = "ValType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ValType> {
        match value {
            0 => ::std::option::Option::Some(ValType::I32),
            1 => ::std::option::Option::Some(ValType::I64),
            2 => ::std::option::Option::Some(ValType::F32),
            3 => ::std::option::Option::Some(ValType::F64),
            4 => ::std::option::Option::Some(ValType::V128),
            5 => ::std::option::Option::Some(ValType::FuncRef),
            6 => ::std::option::Option::Some(ValType::ExternRef),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ValType] = &[
        ValType::I32,
        ValType::I64,
        ValType::F32,
        ValType::F64,
        ValType::V128,
        ValType::FuncRef,
        ValType::ExternRef,
    ];
}

impl ::protobuf::EnumFull for ValType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ValType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ValType {
    fn default() -> Self {
        ValType::I32
    }
}

impl ValType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ValType>("ValType")
    }
}

///  The language (or most similar match) used to produce a wasm module.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SourceLanguage)
pub enum SourceLanguage {
    // @@protoc_insertion_point(enum_value:SourceLanguage.Unknown)
    Unknown = 0,
    // @@protoc_insertion_point(enum_value:SourceLanguage.Rust)
    Rust = 1,
    // @@protoc_insertion_point(enum_value:SourceLanguage.Go)
    Go = 2,
    // @@protoc_insertion_point(enum_value:SourceLanguage.C)
    C = 3,
    // @@protoc_insertion_point(enum_value:SourceLanguage.Cpp)
    Cpp = 4,
    // @@protoc_insertion_point(enum_value:SourceLanguage.AssemblyScript)
    AssemblyScript = 5,
}

impl ::protobuf::Enum for SourceLanguage {
    const NAME: &'static str = "SourceLanguage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SourceLanguage> {
        match value {
            0 => ::std::option::Option::Some(SourceLanguage::Unknown),
            1 => ::std::option::Option::Some(SourceLanguage::Rust),
            2 => ::std::option::Option::Some(SourceLanguage::Go),
            3 => ::std::option::Option::Some(SourceLanguage::C),
            4 => ::std::option::Option::Some(SourceLanguage::Cpp),
            5 => ::std::option::Option::Some(SourceLanguage::AssemblyScript),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SourceLanguage] = &[
        SourceLanguage::Unknown,
        SourceLanguage::Rust,
        SourceLanguage::Go,
        SourceLanguage::C,
        SourceLanguage::Cpp,
        SourceLanguage::AssemblyScript,
    ];
}

impl ::protobuf::EnumFull for SourceLanguage {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SourceLanguage").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SourceLanguage {
    fn default() -> Self {
        SourceLanguage::Unknown
    }
}

impl SourceLanguage {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SourceLanguage>("SourceLanguage")
    }
}

///  The direction, descending or ascending, of the sort operation.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Direction)
pub enum Direction {
    // @@protoc_insertion_point(enum_value:Direction.Desc)
    Desc = 0,
    // @@protoc_insertion_point(enum_value:Direction.Asc)
    Asc = 1,
}

impl ::protobuf::Enum for Direction {
    const NAME: &'static str = "Direction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Direction> {
        match value {
            0 => ::std::option::Option::Some(Direction::Desc),
            1 => ::std::option::Option::Some(Direction::Asc),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Direction] = &[
        Direction::Desc,
        Direction::Asc,
    ];
}

impl ::protobuf::EnumFull for Direction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Direction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Direction {
    fn default() -> Self {
        Direction::Desc
    }
}

impl Direction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Direction>("Direction")
    }
}

///  The field within the Module schema that is used as the sorting dimension.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Field)
pub enum Field {
    // @@protoc_insertion_point(enum_value:Field.CreatedAt)
    CreatedAt = 0,
    // @@protoc_insertion_point(enum_value:Field.Name)
    Name = 1,
    // @@protoc_insertion_point(enum_value:Field.Size)
    Size = 2,
    // @@protoc_insertion_point(enum_value:Field.Language)
    Language = 3,
    // @@protoc_insertion_point(enum_value:Field.ImportsCount)
    ImportsCount = 4,
    // @@protoc_insertion_point(enum_value:Field.ExportsCount)
    ExportsCount = 5,
    // @@protoc_insertion_point(enum_value:Field.Sha256)
    Sha256 = 6,
    // @@protoc_insertion_point(enum_value:Field.Complexity)
    Complexity = 7,
}

impl ::protobuf::Enum for Field {
    const NAME: &'static str = "Field";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Field> {
        match value {
            0 => ::std::option::Option::Some(Field::CreatedAt),
            1 => ::std::option::Option::Some(Field::Name),
            2 => ::std::option::Option::Some(Field::Size),
            3 => ::std::option::Option::Some(Field::Language),
            4 => ::std::option::Option::Some(Field::ImportsCount),
            5 => ::std::option::Option::Some(Field::ExportsCount),
            6 => ::std::option::Option::Some(Field::Sha256),
            7 => ::std::option::Option::Some(Field::Complexity),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Field] = &[
        Field::CreatedAt,
        Field::Name,
        Field::Size,
        Field::Language,
        Field::ImportsCount,
        Field::ExportsCount,
        Field::Sha256,
        Field::Complexity,
    ];
}

impl ::protobuf::EnumFull for Field {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Field").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Field {
    fn default() -> Self {
        Field::CreatedAt
    }
}

impl Field {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Field>("Field")
    }
}

///  Represents the expected outcome of an AuditModulesRequest. If PASS is provided, then
///  the audit returns modules which conform to the checkfile. If FAIL is provided, then
///  the audit returns modules which do not conform to the checkfile.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:AuditOutcome)
pub enum AuditOutcome {
    // @@protoc_insertion_point(enum_value:AuditOutcome.PASS)
    PASS = 0,
    // @@protoc_insertion_point(enum_value:AuditOutcome.FAIL)
    FAIL = 1,
}

impl ::protobuf::Enum for AuditOutcome {
    const NAME: &'static str = "AuditOutcome";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuditOutcome> {
        match value {
            0 => ::std::option::Option::Some(AuditOutcome::PASS),
            1 => ::std::option::Option::Some(AuditOutcome::FAIL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AuditOutcome] = &[
        AuditOutcome::PASS,
        AuditOutcome::FAIL,
    ];
}

impl ::protobuf::EnumFull for AuditOutcome {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AuditOutcome").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AuditOutcome {
    fn default() -> Self {
        AuditOutcome::PASS
    }
}

impl AuditOutcome {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AuditOutcome>("AuditOutcome")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12proto/v1/api.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"d\n\x08\
    Function\x12\x20\n\x06params\x18\x01\x20\x03(\x0e2\x08.ValTypeR\x06param\
    s\x12\"\n\x07results\x18\x02\x20\x03(\x0e2\x08.ValTypeR\x07results\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\"H\n\x06Import\x12\x1f\n\x0bm\
    odule_name\x18\x01\x20\x01(\tR\nmoduleName\x12\x1d\n\x04func\x18\x02\x20\
    \x01(\x0b2\t.FunctionR\x04func\"'\n\x06Export\x12\x1d\n\x04func\x18\x01\
    \x20\x01(\x0b2\t.FunctionR\x04func\"\x85\x05\n\x06Module\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x03R\x02id\x12\x12\n\x04hash\x18\x03\x20\x01(\tR\x04ha\
    sh\x12!\n\x07imports\x18\x04\x20\x03(\x0b2\x07.ImportR\x07imports\x12!\n\
    \x07exports\x18\x05\x20\x03(\x0b2\x07.ExportR\x07exports\x12\x12\n\x04si\
    ze\x18\x06\x20\x01(\x04R\x04size\x12\x1a\n\x08location\x18\x07\x20\x01(\
    \tR\x08location\x128\n\x0fsource_language\x18\x08\x20\x01(\x0e2\x0f.Sour\
    ceLanguageR\x0esourceLanguage\x121\n\x08metadata\x18\t\x20\x03(\x0b2\x15\
    .Module.MetadataEntryR\x08metadata\x12;\n\x0binserted_at\x18\n\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\ninsertedAt\x12\x18\n\x07strings\
    \x18\x0b\x20\x03(\tR\x07strings\x12#\n\ncomplexity\x18\r\x20\x01(\rH\0R\
    \ncomplexity\x88\x01\x01\x12\x19\n\x05graph\x18\x0e\x20\x01(\x0cH\x01R\
    \x05graph\x88\x01\x01\x12D\n\x0ffunction_hashes\x18\x0f\x20\x03(\x0b2\
    \x1b.Module.FunctionHashesEntryR\x0efunctionHashes\x1a;\n\rMetadataEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\x1aA\n\x13FunctionHashesEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01B\r\n\x0b_complexityB\x08\n\x06_graph\"<\n\x0bModule\
    Graph\x12\x0e\n\x02id\x18\x01\x20\x01(\x03R\x02id\x12\x1d\n\njson_bytes\
    \x18\x02\x20\x01(\x0cR\tjsonBytes\"5\n\x05Error\x12\x12\n\x04code\x18\
    \x01\x20\x01(\x05R\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07m\
    essage\":\n\nPagination\x12\x14\n\x05limit\x18\x01\x20\x01(\rR\x05limit\
    \x12\x16\n\x06offset\x18\x02\x20\x01(\rR\x06offset\"N\n\x04Sort\x12(\n\t\
    direction\x18\x01\x20\x01(\x0e2\n.DirectionR\tdirection\x12\x1c\n\x05fie\
    ld\x18\x02\x20\x01(\x0e2\x06.FieldR\x05field\"\xd4\x01\n\x13CreateModule\
    Request\x12\x12\n\x04wasm\x18\x01\x20\x01(\x0cR\x04wasm\x12>\n\x08metada\
    ta\x18\x02\x20\x03(\x0b2\".CreateModuleRequest.MetadataEntryR\x08metadat\
    a\x12\x1f\n\x08location\x18\x03\x20\x01(\tH\0R\x08location\x88\x01\x01\
    \x1a;\n\rMetadataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x0b\n\t_location\
    \"t\n\x14CreateModuleResponse\x12\x1b\n\tmodule_id\x18\x01\x20\x01(\x03R\
    \x08moduleId\x12\x12\n\x04hash\x18\x02\x20\x01(\tR\x04hash\x12!\n\x05err\
    or\x18\x03\x20\x01(\x0b2\x06.ErrorH\0R\x05error\x88\x01\x01B\x08\n\x06_e\
    rror\"/\n\x10GetModuleRequest\x12\x1b\n\tmodule_id\x18\x01\x20\x01(\x03R\
    \x08moduleId\"a\n\x11GetModuleResponse\x12\x1f\n\x06module\x18\x01\x20\
    \x01(\x0b2\x07.ModuleR\x06module\x12!\n\x05error\x18\x02\x20\x01(\x0b2\
    \x06.ErrorH\0R\x05error\x88\x01\x01B\x08\n\x06_error\"\\\n\x12ListModule\
    sRequest\x12+\n\npagination\x18\x01\x20\x01(\x0b2\x0b.PaginationR\npagin\
    ation\x12\x19\n\x04sort\x18\x02\x20\x01(\x0b2\x05.SortR\x04sort\"\xc3\
    \x01\n\x13ListModulesResponse\x12!\n\x07modules\x18\x01\x20\x03(\x0b2\
    \x07.ModuleR\x07modules\x12+\n\npagination\x18\x02\x20\x01(\x0b2\x0b.Pag\
    inationR\npagination\x12\x14\n\x05total\x18\x03\x20\x01(\x04R\x05total\
    \x12\x19\n\x04sort\x18\x04\x20\x01(\x0b2\x05.SortR\x04sort\x12!\n\x05err\
    or\x18\x05\x20\x01(\x0b2\x06.ErrorH\0R\x05error\x88\x01\x01B\x08\n\x06_e\
    rror\"\x80\x07\n\x14SearchModulesRequest\x12\x13\n\x02id\x18\x01\x20\x01\
    (\x03H\0R\x02id\x88\x01\x01\x12\x17\n\x04hash\x18\x03\x20\x01(\tH\x01R\
    \x04hash\x88\x01\x01\x12!\n\x07imports\x18\x04\x20\x03(\x0b2\x07.ImportR\
    \x07imports\x12!\n\x07exports\x18\x05\x20\x03(\x0b2\x07.ExportR\x07expor\
    ts\x12\x1e\n\x08min_size\x18\x06\x20\x01(\x04H\x02R\x07minSize\x88\x01\
    \x01\x12\x1e\n\x08max_size\x18\x07\x20\x01(\x04H\x03R\x07maxSize\x88\x01\
    \x01\x12\x1f\n\x08location\x18\x08\x20\x01(\tH\x04R\x08location\x88\x01\
    \x01\x12=\n\x0fsource_language\x18\t\x20\x01(\x0e2\x0f.SourceLanguageH\
    \x05R\x0esourceLanguage\x88\x01\x01\x12?\n\x08metadata\x18\n\x20\x03(\
    \x0b2#.SearchModulesRequest.MetadataEntryR\x08metadata\x12H\n\x0finserte\
    d_before\x18\x0b\x20\x01(\x0b2\x1a.google.protobuf.TimestampH\x06R\x0ein\
    sertedBefore\x88\x01\x01\x12F\n\x0einserted_after\x18\x0c\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampH\x07R\rinsertedAfter\x88\x01\x01\x12\x18\
    \n\x07strings\x18\r\x20\x03(\tR\x07strings\x12(\n\rfunction_name\x18\x0e\
    \x20\x01(\tH\x08R\x0cfunctionName\x88\x01\x01\x12$\n\x0bmodule_name\x18\
    \x0f\x20\x01(\tH\tR\nmoduleName\x88\x01\x01\x12+\n\npagination\x18\x10\
    \x20\x01(\x0b2\x0b.PaginationR\npagination\x12\x19\n\x04sort\x18\x11\x20\
    \x01(\x0b2\x05.SortR\x04sort\x1a;\n\rMetadataEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01B\x05\n\x03_idB\x07\n\x05_hashB\x0b\n\t_min_sizeB\x0b\n\t_max_s\
    izeB\x0b\n\t_locationB\x12\n\x10_source_languageB\x12\n\x10_inserted_bef\
    oreB\x11\n\x0f_inserted_afterB\x10\n\x0e_function_nameB\x0e\n\x0c_module\
    _name\"\xc5\x01\n\x15SearchModulesResponse\x12!\n\x07modules\x18\x01\x20\
    \x03(\x0b2\x07.ModuleR\x07modules\x12+\n\npagination\x18\x02\x20\x01(\
    \x0b2\x0b.PaginationR\npagination\x12\x14\n\x05total\x18\x03\x20\x01(\
    \x04R\x05total\x12\x19\n\x04sort\x18\x04\x20\x01(\x0b2\x05.SortR\x04sort\
    \x12!\n\x05error\x18\x05\x20\x01(\x0b2\x06.ErrorH\0R\x05error\x88\x01\
    \x01B\x08\n\x06_error\"5\n\x14DeleteModulesRequest\x12\x1d\n\nmodule_ids\
    \x18\x01\x20\x03(\x03R\tmoduleIds\"\xd5\x01\n\x15DeleteModulesResponse\
    \x12N\n\x0emodule_id_hash\x18\x01\x20\x03(\x0b2(.DeleteModulesResponse.M\
    oduleIdHashEntryR\x0cmoduleIdHash\x12!\n\x05error\x18\x02\x20\x01(\x0b2\
    \x06.ErrorH\0R\x05error\x88\x01\x01\x1a?\n\x11ModuleIdHashEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\x03R\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01B\x08\n\x06_error\"\x89\x01\n\x13AuditModules\
    Request\x12\x1c\n\tcheckfile\x18\x01\x20\x01(\x0cR\tcheckfile\x12'\n\x07\
    outcome\x18\x02\x20\x01(\x0e2\r.AuditOutcomeR\x07outcome\x12+\n\npaginat\
    ion\x18\x03\x20\x01(\x0b2\x0b.PaginationR\npagination\"\xb2\x02\n\x14Aud\
    itModulesResponse\x12b\n\x15invalid_module_report\x18\x01\x20\x03(\x0b2.\
    .AuditModulesResponse.InvalidModuleReportEntryR\x13invalidModuleReport\
    \x12+\n\npagination\x18\x02\x20\x01(\x0b2\x0b.PaginationR\npagination\
    \x12\x14\n\x05total\x18\x03\x20\x01(\x04R\x05total\x12!\n\x05error\x18\
    \x04\x20\x01(\x0b2\x06.ErrorH\0R\x05error\x88\x01\x01\x1aF\n\x18InvalidM\
    oduleReportEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\x0cR\x05value:\x028\x01B\x08\n\x06_error\"\
    \x8b\x01\n\x0bDiffRequest\x12\x18\n\x07module1\x18\x01\x20\x01(\x03R\x07\
    module1\x12\x18\n\x07module2\x18\x02\x20\x01(\x03R\x07module2\x12%\n\x0e\
    color_terminal\x18\x03\x20\x01(\x08R\rcolorTerminal\x12!\n\x0cwith_conte\
    xt\x18\x04\x20\x01(\x08R\x0bwithContext\"O\n\x0cDiffResponse\x12\x12\n\
    \x04diff\x18\x01\x20\x01(\tR\x04diff\x12!\n\x05error\x18\x02\x20\x01(\
    \x0b2\x06.ErrorH\0R\x05error\x88\x01\x01B\x08\n\x06_error\"~\n\x15Valida\
    teModuleRequest\x12\x1c\n\tcheckfile\x18\x01\x20\x01(\x0cR\tcheckfile\
    \x12\x18\n\x06module\x18\x02\x20\x01(\x0cH\0R\x06module\x12\x1d\n\tmodul\
    e_id\x18\x03\x20\x01(\x03H\0R\x08moduleIdB\x0e\n\x0cmodule_input\"y\n\
    \x16ValidateModuleResponse\x122\n\x15invalid_module_report\x18\x01\x20\
    \x01(\x0cR\x13invalidModuleReport\x12!\n\x05error\x18\x02\x20\x01(\x0b2\
    \x06.ErrorH\0R\x05error\x88\x01\x01B\x08\n\x06_error\"4\n\x15GetModuleGr\
    aphRequest\x12\x1b\n\tmodule_id\x18\x01\x20\x01(\x03R\x08moduleId\"v\n\
    \x16GetModuleGraphResponse\x12/\n\x0cmodule_graph\x18\x01\x20\x01(\x0b2\
    \x0c.ModuleGraphR\x0bmoduleGraph\x12!\n\x05error\x18\x02\x20\x01(\x0b2\
    \x06.ErrorH\0R\x05error\x88\x01\x01B\x08\n\x06_error\"\xd3\x01\n\x15Regi\
    sterPluginRequest\x12\x1e\n\nidentifier\x18\x01\x20\x01(\tR\nidentifier\
    \x12\x12\n\x04code\x18\x02\x20\x01(\x0cR\x04code\x12G\n\x0binit_config\
    \x18\x03\x20\x03(\x0b2&.RegisterPluginRequest.InitConfigEntryR\ninitConf\
    ig\x1a=\n\x0fInitConfigEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"Y\n\x16Regis\
    terPluginResponse\x12\x12\n\x04hash\x18\x01\x20\x01(\tR\x04hash\x12!\n\
    \x05error\x18\x02\x20\x01(\x0b2\x06.ErrorH\0R\x05error\x88\x01\x01B\x08\
    \n\x06_error\"\x83\x02\n\x11CallPluginRequest\x12#\n\rfunction_name\x18\
    \x01\x20\x01(\tR\x0cfunctionName\x12\x1e\n\nidentifier\x18\x02\x20\x01(\
    \tR\nidentifier\x12\x14\n\x05input\x18\x03\x20\x01(\x0cR\x05input\x126\n\
    \x06config\x18\x04\x20\x03(\x0b2\x1e.CallPluginRequest.ConfigEntryR\x06c\
    onfig\x12\x17\n\x04hash\x18\x05\x20\x01(\tH\0R\x04hash\x88\x01\x01\x1a9\
    \n\x0bConfigEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x07\n\x05_hash\"z\n\
    \x12CallPluginResponse\x12\x16\n\x06output\x18\x01\x20\x01(\x0cR\x06outp\
    ut\x12\x1f\n\x0breturn_code\x18\x02\x20\x01(\x05R\nreturnCode\x12!\n\x05\
    error\x18\x03\x20\x01(\x0b2\x06.ErrorH\0R\x05error\x88\x01\x01B\x08\n\
    \x06_error*S\n\x07ValType\x12\x07\n\x03I32\x10\0\x12\x07\n\x03I64\x10\
    \x01\x12\x07\n\x03F32\x10\x02\x12\x07\n\x03F64\x10\x03\x12\x08\n\x04V128\
    \x10\x04\x12\x0b\n\x07FuncRef\x10\x05\x12\r\n\tExternRef\x10\x06*S\n\x0e\
    SourceLanguage\x12\x0b\n\x07Unknown\x10\0\x12\x08\n\x04Rust\x10\x01\x12\
    \x06\n\x02Go\x10\x02\x12\x05\n\x01C\x10\x03\x12\x07\n\x03Cpp\x10\x04\x12\
    \x12\n\x0eAssemblyScript\x10\x05*\x1e\n\tDirection\x12\x08\n\x04Desc\x10\
    \0\x12\x07\n\x03Asc\x10\x01*x\n\x05Field\x12\r\n\tCreatedAt\x10\0\x12\
    \x08\n\x04Name\x10\x01\x12\x08\n\x04Size\x10\x02\x12\x0c\n\x08Language\
    \x10\x03\x12\x10\n\x0cImportsCount\x10\x04\x12\x10\n\x0cExportsCount\x10\
    \x05\x12\n\n\x06Sha256\x10\x06\x12\x0e\n\nComplexity\x10\x07*\"\n\x0cAud\
    itOutcome\x12\x08\n\x04PASS\x10\0\x12\x08\n\x04FAIL\x10\x01J\xf9k\n\x07\
    \x12\x05\0\0\xc9\x02\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\t\n\x02\x03\0\
    \x12\x03\x02\0)\nr\n\x02\x05\0\x12\x04\x06\0\x0e\x01\x1af\x20Used\x20to\
    \x20type\x20the\x20arguments\x20and\x20return\x20types\x20from\x20wasm\
    \x20elements\x20such\x20as\x20import\n\x20and\x20export\x20functions.\n\
    \n\n\n\x03\x05\0\x01\x12\x03\x06\x05\x0c\n\x0b\n\x04\x05\0\x02\0\x12\x03\
    \x07\x02\n\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x07\x02\x05\n\x0c\n\x05\
    \x05\0\x02\0\x02\x12\x03\x07\x08\t\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x08\
    \x02\n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x08\x02\x05\n\x0c\n\x05\x05\
    \0\x02\x01\x02\x12\x03\x08\x08\t\n\x0b\n\x04\x05\0\x02\x02\x12\x03\t\x02\
    \n\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\t\x02\x05\n\x0c\n\x05\x05\0\x02\
    \x02\x02\x12\x03\t\x08\t\n\x0b\n\x04\x05\0\x02\x03\x12\x03\n\x02\n\n\x0c\
    \n\x05\x05\0\x02\x03\x01\x12\x03\n\x02\x05\n\x0c\n\x05\x05\0\x02\x03\x02\
    \x12\x03\n\x08\t\n\x0b\n\x04\x05\0\x02\x04\x12\x03\x0b\x02\x0b\n\x0c\n\
    \x05\x05\0\x02\x04\x01\x12\x03\x0b\x02\x06\n\x0c\n\x05\x05\0\x02\x04\x02\
    \x12\x03\x0b\t\n\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x0c\x02\x0e\n\x0c\n\
    \x05\x05\0\x02\x05\x01\x12\x03\x0c\x02\t\n\x0c\n\x05\x05\0\x02\x05\x02\
    \x12\x03\x0c\x0c\r\n\x0b\n\x04\x05\0\x02\x06\x12\x03\r\x02\x10\n\x0c\n\
    \x05\x05\0\x02\x06\x01\x12\x03\r\x02\x0b\n\x0c\n\x05\x05\0\x02\x06\x02\
    \x12\x03\r\x0e\x0f\nL\n\x02\x04\0\x12\x04\x11\0\x15\x01\x1a@\x20Containe\
    d\x20by\x20an\x20import\x20or\x20export\x20element\x20within\x20a\x20was\
    m\x20binary.\n\n\n\n\x03\x04\0\x01\x12\x03\x11\x08\x10\n\x0b\n\x04\x04\0\
    \x02\0\x12\x03\x12\x02\x1e\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x12\x02\n\
    \n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x12\x0b\x12\n\x0c\n\x05\x04\0\x02\0\
    \x01\x12\x03\x12\x13\x19\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x12\x1c\x1d\
    \n\x0b\n\x04\x04\0\x02\x01\x12\x03\x13\x02\x1f\n\x0c\n\x05\x04\0\x02\x01\
    \x04\x12\x03\x13\x02\n\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x13\x0b\x12\
    \n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x13\x13\x1a\n\x0c\n\x05\x04\0\x02\
    \x01\x03\x12\x03\x13\x1d\x1e\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x14\x02\
    \x12\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x14\x02\x08\n\x0c\n\x05\x04\0\
    \x02\x02\x01\x12\x03\x14\t\r\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x14\
    \x10\x11\n\x8d\x01\n\x02\x04\x01\x12\x04\x19\0\x1c\x01\x1a\x80\x01\x20A\
    \x20function\x20and\x20module\x20namespace\x20that\x20is\x20defined\x20o\
    utside\x20of\x20the\x20current\n\x20module,\x20and\x20referenced\x20&\
    \x20called\x20by\x20the\x20current\x20module.\n\n\n\n\x03\x04\x01\x01\
    \x12\x03\x19\x08\x0e\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x1a\x02\x19\n\x0c\
    \n\x05\x04\x01\x02\0\x05\x12\x03\x1a\x02\x08\n\x0c\n\x05\x04\x01\x02\0\
    \x01\x12\x03\x1a\t\x14\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x1a\x17\x18\
    \n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x1b\x02\x14\n\x0c\n\x05\x04\x01\x02\
    \x01\x06\x12\x03\x1b\x02\n\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x1b\
    \x0b\x0f\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x1b\x12\x13\nu\n\x02\
    \x04\x02\x12\x03\x20\0%\x1aj\x20A\x20function\x20that\x20is\x20defined\
    \x20inside\x20the\x20current\x20module,\x20made\x20available\x20to\n\x20\
    outside\x20modules\x20/\x20environments.\n\n\n\n\x03\x04\x02\x01\x12\x03\
    \x20\x08\x0e\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x20\x11#\n\x0c\n\x05\x04\
    \x02\x02\0\x06\x12\x03\x20\x11\x19\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\
    \x20\x1a\x1e\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x20!\"\nQ\n\x02\x05\
    \x01\x12\x04#\0*\x01\x1aE\x20The\x20language\x20(or\x20most\x20similar\
    \x20match)\x20used\x20to\x20produce\x20a\x20wasm\x20module.\n\n\n\n\x03\
    \x05\x01\x01\x12\x03#\x05\x13\n\x0b\n\x04\x05\x01\x02\0\x12\x03$\x02\x0e\
    \n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03$\x02\t\n\x0c\n\x05\x05\x01\x02\0\
    \x02\x12\x03$\x0c\r\n\x0b\n\x04\x05\x01\x02\x01\x12\x03%\x02\x0b\n\x0c\n\
    \x05\x05\x01\x02\x01\x01\x12\x03%\x02\x06\n\x0c\n\x05\x05\x01\x02\x01\
    \x02\x12\x03%\t\n\n\x0b\n\x04\x05\x01\x02\x02\x12\x03&\x02\t\n\x0c\n\x05\
    \x05\x01\x02\x02\x01\x12\x03&\x02\x04\n\x0c\n\x05\x05\x01\x02\x02\x02\
    \x12\x03&\x07\x08\n\x0b\n\x04\x05\x01\x02\x03\x12\x03'\x02\x08\n\x0c\n\
    \x05\x05\x01\x02\x03\x01\x12\x03'\x02\x03\n\x0c\n\x05\x05\x01\x02\x03\
    \x02\x12\x03'\x06\x07\n\x0b\n\x04\x05\x01\x02\x04\x12\x03(\x02\n\n\x0c\n\
    \x05\x05\x01\x02\x04\x01\x12\x03(\x02\x05\n\x0c\n\x05\x05\x01\x02\x04\
    \x02\x12\x03(\x08\t\n\x0b\n\x04\x05\x01\x02\x05\x12\x03)\x02\x15\n\x0c\n\
    \x05\x05\x01\x02\x05\x01\x12\x03)\x02\x10\n\x0c\n\x05\x05\x01\x02\x05\
    \x02\x12\x03)\x13\x14\nk\n\x02\x04\x03\x12\x04.\0L\x01\x1a_\x20Details\
    \x20about\x20a\x20wasm\x20module,\x20either\x20extracted\x20directly\x20\
    from\x20the\x20binary,\x20or\n\x20inferred\x20somehow.\n\n\n\n\x03\x04\
    \x03\x01\x12\x03.\x08\x0e\n=\n\x04\x04\x03\x02\0\x12\x030\x02\x0f\x1a0\
    \x20ID\x20for\x20this\x20module,\x20generated\x20by\x20the\x20database.\
    \n\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x030\x02\x07\n\x0c\n\x05\x04\x03\
    \x02\0\x01\x12\x030\x08\n\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x030\r\x0e\n\
    3\n\x04\x04\x03\x02\x01\x12\x032\x02\x12\x1a&\x20sha256\x20hash\x20of\
    \x20the\x20modules\x20raw\x20bytes\n\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\
    \x032\x02\x08\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x032\t\r\n\x0c\n\x05\
    \x04\x03\x02\x01\x03\x12\x032\x10\x11\n\x81\x01\n\x04\x04\x03\x02\x02\
    \x12\x035\x02\x1e\x1at\x20function\x20imports\x20called\x20by\x20the\x20\
    module\x20(see:\n\x20<https://github.com/WebAssembly/design/blob/main/Mo\
    dules.md#imports)>\n\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x035\x02\n\n\
    \x0c\n\x05\x04\x03\x02\x02\x06\x12\x035\x0b\x11\n\x0c\n\x05\x04\x03\x02\
    \x02\x01\x12\x035\x12\x19\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x035\x1c\
    \x1d\n\x83\x01\n\x04\x04\x03\x02\x03\x12\x038\x02\x1e\x1av\x20function\
    \x20exports\x20provided\x20by\x20the\x20module\x20(see:\n\x20<https://gi\
    thub.com/WebAssembly/design/blob/main/Modules.md#exports)>\n\n\x0c\n\x05\
    \x04\x03\x02\x03\x04\x12\x038\x02\n\n\x0c\n\x05\x04\x03\x02\x03\x06\x12\
    \x038\x0b\x11\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x038\x12\x19\n\x0c\n\
    \x05\x04\x03\x02\x03\x03\x12\x038\x1c\x1d\n*\n\x04\x04\x03\x02\x04\x12\
    \x03:\x02\x12\x1a\x1d\x20size\x20in\x20bytes\x20of\x20the\x20module\n\n\
    \x0c\n\x05\x04\x03\x02\x04\x05\x12\x03:\x02\x08\n\x0c\n\x05\x04\x03\x02\
    \x04\x01\x12\x03:\t\r\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03:\x10\x11\n\
    ,\n\x04\x04\x03\x02\x05\x12\x03<\x02\x16\x1a\x1f\x20path\x20or\x20locato\
    r\x20to\x20the\x20module\n\n\x0c\n\x05\x04\x03\x02\x05\x05\x12\x03<\x02\
    \x08\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x03<\t\x11\n\x0c\n\x05\x04\x03\
    \x02\x05\x03\x12\x03<\x14\x15\n?\n\x04\x04\x03\x02\x06\x12\x03>\x02%\x1a\
    2\x20programming\x20language\x20used\x20to\x20produce\x20this\x20module\
    \n\n\x0c\n\x05\x04\x03\x02\x06\x06\x12\x03>\x02\x10\n\x0c\n\x05\x04\x03\
    \x02\x06\x01\x12\x03>\x11\x20\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x03>#$\
    \nI\n\x04\x04\x03\x02\x07\x12\x03@\x02#\x1a<\x20arbitrary\x20metadata\
    \x20provided\x20by\x20the\x20operator\x20of\x20this\x20module\n\n\x0c\n\
    \x05\x04\x03\x02\x07\x06\x12\x03@\x02\x15\n\x0c\n\x05\x04\x03\x02\x07\
    \x01\x12\x03@\x16\x1e\n\x0c\n\x05\x04\x03\x02\x07\x03\x12\x03@!\"\n?\n\
    \x04\x04\x03\x02\x08\x12\x03B\x02-\x1a2\x20timestamp\x20when\x20this\x20\
    module\x20was\x20loaded\x20and\x20stored\n\n\x0c\n\x05\x04\x03\x02\x08\
    \x06\x12\x03B\x02\x1b\n\x0c\n\x05\x04\x03\x02\x08\x01\x12\x03B\x1c'\n\
    \x0c\n\x05\x04\x03\x02\x08\x03\x12\x03B*,\nZ\n\x04\x04\x03\x02\t\x12\x03\
    D\x02\x1f\x1aM\x20the\x20interned\x20strings\x20stored\x20in\x20the\x20w\
    asm\x20binary\x20(panic/abort\x20messages,\x20etc.)\n\n\x0c\n\x05\x04\
    \x03\x02\t\x04\x12\x03D\x02\n\n\x0c\n\x05\x04\x03\x02\t\x05\x12\x03D\x0b\
    \x11\n\x0c\n\x05\x04\x03\x02\t\x01\x12\x03D\x12\x19\n\x0c\n\x05\x04\x03\
    \x02\t\x03\x12\x03D\x1c\x1e\nu\n\x04\x04\x03\x02\n\x12\x03G\x02\"\x1ah\
    \x20the\x20cyclomatic\x20complexity\n\x20(<https://en.wikipedia.org/wiki\
    /Cyclomatic_complexity>)\x20of\x20the\x20instructions\n\n\x0c\n\x05\x04\
    \x03\x02\n\x04\x12\x03G\x02\n\n\x0c\n\x05\x04\x03\x02\n\x05\x12\x03G\x0b\
    \x11\n\x0c\n\x05\x04\x03\x02\n\x01\x12\x03G\x12\x1c\n\x0c\n\x05\x04\x03\
    \x02\n\x03\x12\x03G\x1f!\n2\n\x04\x04\x03\x02\x0b\x12\x03I\x02\x1c\x1a%\
    \x20the\x20serialized\x20graph\x20in\x20json\x20format\n\n\x0c\n\x05\x04\
    \x03\x02\x0b\x04\x12\x03I\x02\n\n\x0c\n\x05\x04\x03\x02\x0b\x05\x12\x03I\
    \x0b\x10\n\x0c\n\x05\x04\x03\x02\x0b\x01\x12\x03I\x11\x16\n\x0c\n\x05\
    \x04\x03\x02\x0b\x03\x12\x03I\x19\x1b\n\x1e\n\x04\x04\x03\x02\x0c\x12\
    \x03K\x02+\x1a\x11\x20function\x20hashes\n\n\x0c\n\x05\x04\x03\x02\x0c\
    \x06\x12\x03K\x02\x15\n\x0c\n\x05\x04\x03\x02\x0c\x01\x12\x03K\x16%\n\
    \x0c\n\x05\x04\x03\x02\x0c\x03\x12\x03K(*\n/\n\x02\x04\x04\x12\x04O\0T\
    \x01\x1a#\x20Details\x20about\x20a\x20wasm\x20module\x20graph\n\n\n\n\
    \x03\x04\x04\x01\x12\x03O\x08\x13\n=\n\x04\x04\x04\x02\0\x12\x03Q\x02\
    \x0f\x1a0\x20ID\x20for\x20this\x20module,\x20generated\x20by\x20the\x20d\
    atabase.\n\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03Q\x02\x07\n\x0c\n\x05\
    \x04\x04\x02\0\x01\x12\x03Q\x08\n\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03Q\
    \r\x0e\n2\n\x04\x04\x04\x02\x01\x12\x03S\x02\x17\x1a%\x20the\x20serializ\
    ed\x20graph\x20in\x20json\x20format\n\n\x0c\n\x05\x04\x04\x02\x01\x05\
    \x12\x03S\x02\x07\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03S\x08\x12\n\x0c\
    \n\x05\x04\x04\x02\x01\x03\x12\x03S\x15\x16\n?\n\x02\x04\x05\x12\x04W\0Z\
    \x01\x1a3\x20An\x20error\x20message\x20indicating\x20a\x20problem\x20in\
    \x20the\x20API.\n\n\n\n\x03\x04\x05\x01\x12\x03W\x08\r\n\x0b\n\x04\x04\
    \x05\x02\0\x12\x03X\x02\x11\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03X\x02\
    \x07\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03X\x08\x0c\n\x0c\n\x05\x04\x05\
    \x02\0\x03\x12\x03X\x0f\x10\n\x0b\n\x04\x04\x05\x02\x01\x12\x03Y\x02\x15\
    \n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03Y\x02\x08\n\x0c\n\x05\x04\x05\
    \x02\x01\x01\x12\x03Y\t\x10\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03Y\x13\
    \x14\n]\n\x02\x04\x06\x12\x04^\0a\x01\x1aQ\x20Control/limit\x20the\x20wa\
    y\x20results\x20are\x20paginated\x20when\x20working\x20with\x20large\n\
    \x20responses.\n\n\n\n\x03\x04\x06\x01\x12\x03^\x08\x12\n\x0b\n\x04\x04\
    \x06\x02\0\x12\x03_\x02\x13\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03_\x02\
    \x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03_\t\x0e\n\x0c\n\x05\x04\x06\
    \x02\0\x03\x12\x03_\x11\x12\n\x0b\n\x04\x04\x06\x02\x01\x12\x03`\x02\x14\
    \n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03`\x02\x08\n\x0c\n\x05\x04\x06\
    \x02\x01\x01\x12\x03`\t\x0f\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03`\x12\
    \x13\n8\n\x02\x04\x07\x12\x04d\0g\x01\x1a,\x20Determine\x20how\x20to\x20\
    sort\x20results\x20from\x20the\x20API\n\n\n\n\x03\x04\x07\x01\x12\x03d\
    \x08\x0c\n\x0b\n\x04\x04\x07\x02\0\x12\x03e\x02\x1a\n\x0c\n\x05\x04\x07\
    \x02\0\x06\x12\x03e\x02\x0b\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03e\x0c\
    \x15\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03e\x18\x19\n\x0b\n\x04\x04\x07\
    \x02\x01\x12\x03f\x02\x12\n\x0c\n\x05\x04\x07\x02\x01\x06\x12\x03f\x02\
    \x07\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03f\x08\r\n\x0c\n\x05\x04\x07\
    \x02\x01\x03\x12\x03f\x10\x11\nL\n\x02\x05\x02\x12\x04j\0m\x01\x1a@\x20T\
    he\x20direction,\x20descending\x20or\x20ascending,\x20of\x20the\x20sort\
    \x20operation.\n\n\n\n\x03\x05\x02\x01\x12\x03j\x05\x0e\n\x0b\n\x04\x05\
    \x02\x02\0\x12\x03k\x02\x0b\n\x0c\n\x05\x05\x02\x02\0\x01\x12\x03k\x02\
    \x06\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03k\t\n\n\x0b\n\x04\x05\x02\x02\
    \x01\x12\x03l\x02\n\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x03l\x02\x05\n\
    \x0c\n\x05\x05\x02\x02\x01\x02\x12\x03l\x08\t\nW\n\x02\x05\x03\x12\x04p\
    \0y\x01\x1aK\x20The\x20field\x20within\x20the\x20Module\x20schema\x20tha\
    t\x20is\x20used\x20as\x20the\x20sorting\x20dimension.\n\n\n\n\x03\x05\
    \x03\x01\x12\x03p\x05\n\n\x0b\n\x04\x05\x03\x02\0\x12\x03q\x02\x10\n\x0c\
    \n\x05\x05\x03\x02\0\x01\x12\x03q\x02\x0b\n\x0c\n\x05\x05\x03\x02\0\x02\
    \x12\x03q\x0e\x0f\n\x0b\n\x04\x05\x03\x02\x01\x12\x03r\x02\x0b\n\x0c\n\
    \x05\x05\x03\x02\x01\x01\x12\x03r\x02\x06\n\x0c\n\x05\x05\x03\x02\x01\
    \x02\x12\x03r\t\n\n\x0b\n\x04\x05\x03\x02\x02\x12\x03s\x02\x0b\n\x0c\n\
    \x05\x05\x03\x02\x02\x01\x12\x03s\x02\x06\n\x0c\n\x05\x05\x03\x02\x02\
    \x02\x12\x03s\t\n\n\x0b\n\x04\x05\x03\x02\x03\x12\x03t\x02\x0f\n\x0c\n\
    \x05\x05\x03\x02\x03\x01\x12\x03t\x02\n\n\x0c\n\x05\x05\x03\x02\x03\x02\
    \x12\x03t\r\x0e\n\x0b\n\x04\x05\x03\x02\x04\x12\x03u\x02\x13\n\x0c\n\x05\
    \x05\x03\x02\x04\x01\x12\x03u\x02\x0e\n\x0c\n\x05\x05\x03\x02\x04\x02\
    \x12\x03u\x11\x12\n\x0b\n\x04\x05\x03\x02\x05\x12\x03v\x02\x13\n\x0c\n\
    \x05\x05\x03\x02\x05\x01\x12\x03v\x02\x0e\n\x0c\n\x05\x05\x03\x02\x05\
    \x02\x12\x03v\x11\x12\n\x0b\n\x04\x05\x03\x02\x06\x12\x03w\x02\r\n\x0c\n\
    \x05\x05\x03\x02\x06\x01\x12\x03w\x02\x08\n\x0c\n\x05\x05\x03\x02\x06\
    \x02\x12\x03w\x0b\x0c\n\x0b\n\x04\x05\x03\x02\x07\x12\x03x\x02\x11\n\x0c\
    \n\x05\x05\x03\x02\x07\x01\x12\x03x\x02\x0c\n\x0c\n\x05\x05\x03\x02\x07\
    \x02\x12\x03x\x0f\x10\nm\n\x02\x04\x08\x12\x05}\0\x82\x01\x01\x1a`\x20`P\
    UT\x20/api/v1/module:`\n\x20Insert\x20a\x20module,\x20extract\x20data\
    \x20from\x20binary.\x20Return\x20the\x20module\x20ID\x20&\x20hash.\n\n\n\
    \n\x03\x04\x08\x01\x12\x03}\x08\x1b\n\x0b\n\x04\x04\x08\x02\0\x12\x03~\
    \x02\x11\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03~\x02\x07\n\x0c\n\x05\x04\
    \x08\x02\0\x01\x12\x03~\x08\x0c\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03~\
    \x0f\x10\n\x0b\n\x04\x04\x08\x02\x01\x12\x03\x7f\x02#\n\x0c\n\x05\x04\
    \x08\x02\x01\x06\x12\x03\x7f\x02\x15\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\
    \x03\x7f\x16\x1e\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03\x7f!\"\nT\n\x04\
    \x04\x08\x02\x02\x12\x04\x81\x01\x02\x1f\x1aF\x20a\x20valid\x20URL\x20wi\
    th\x20a\x20scheme\x20prefix\x20e.g.\x20`s3://`,\x20`file://`,\x20`https:\
    //`\n\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\x81\x01\x02\n\n\r\n\x05\x04\
    \x08\x02\x02\x05\x12\x04\x81\x01\x0b\x11\n\r\n\x05\x04\x08\x02\x02\x01\
    \x12\x04\x81\x01\x12\x1a\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\x81\x01\
    \x1d\x1e\nL\n\x02\x04\t\x12\x06\x85\x01\0\x89\x01\x01\x1a>\x20The\x20mes\
    sage\x20returned\x20in\x20response\x20to\x20a\x20`CreateModuleRequest`.\
    \n\n\x0b\n\x03\x04\t\x01\x12\x04\x85\x01\x08\x1c\n\x0c\n\x04\x04\t\x02\0\
    \x12\x04\x86\x01\x02\x16\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x86\x01\x02\
    \x07\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x86\x01\x08\x11\n\r\n\x05\x04\t\
    \x02\0\x03\x12\x04\x86\x01\x14\x15\n\x0c\n\x04\x04\t\x02\x01\x12\x04\x87\
    \x01\x02\x12\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\x87\x01\x02\x08\n\r\n\
    \x05\x04\t\x02\x01\x01\x12\x04\x87\x01\t\r\n\r\n\x05\x04\t\x02\x01\x03\
    \x12\x04\x87\x01\x10\x11\n\x0c\n\x04\x04\t\x02\x02\x12\x04\x88\x01\x02\
    \x1b\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\x88\x01\x02\n\n\r\n\x05\x04\t\
    \x02\x02\x06\x12\x04\x88\x01\x0b\x10\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\
    \x88\x01\x11\x16\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\x88\x01\x19\x1a\n=\
    \n\x02\x04\n\x12\x04\x8d\x01\01\x1a1\x20`POST\x20/api/v1/module:`\n\x20R\
    eturn\x20a\x20single\x20module.\n\n\x0b\n\x03\x04\n\x01\x12\x04\x8d\x01\
    \x08\x18\n\x0c\n\x04\x04\n\x02\0\x12\x04\x8d\x01\x1b/\n\r\n\x05\x04\n\
    \x02\0\x05\x12\x04\x8d\x01\x1b\x20\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x8d\
    \x01!*\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x8d\x01-.\nI\n\x02\x04\x0b\x12\
    \x06\x90\x01\0\x93\x01\x01\x1a;\x20The\x20message\x20returned\x20in\x20r\
    esponse\x20to\x20a\x20`GetModuleRequest`.\n\n\x0b\n\x03\x04\x0b\x01\x12\
    \x04\x90\x01\x08\x19\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x91\x01\x02\x14\n\
    \r\n\x05\x04\x0b\x02\0\x06\x12\x04\x91\x01\x02\x08\n\r\n\x05\x04\x0b\x02\
    \0\x01\x12\x04\x91\x01\t\x0f\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x91\x01\
    \x12\x13\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x92\x01\x02\x1b\n\r\n\x05\
    \x04\x0b\x02\x01\x04\x12\x04\x92\x01\x02\n\n\r\n\x05\x04\x0b\x02\x01\x06\
    \x12\x04\x92\x01\x0b\x10\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x92\x01\
    \x11\x16\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x92\x01\x19\x1a\nN\n\x02\
    \x04\x0c\x12\x06\x97\x01\0\x9a\x01\x01\x1a@\x20`POST\x20/api/v1/modules:\
    `\n\x20Return\x20paginated\x20list\x20of\x20all\x20modules.\n\n\x0b\n\
    \x03\x04\x0c\x01\x12\x04\x97\x01\x08\x1a\n\x0c\n\x04\x04\x0c\x02\0\x12\
    \x04\x98\x01\x02\x1c\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\x98\x01\x02\x0c\
    \n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x98\x01\r\x17\n\r\n\x05\x04\x0c\x02\
    \0\x03\x12\x04\x98\x01\x1a\x1b\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\x99\
    \x01\x02\x10\n\r\n\x05\x04\x0c\x02\x01\x06\x12\x04\x99\x01\x02\x06\n\r\n\
    \x05\x04\x0c\x02\x01\x01\x12\x04\x99\x01\x07\x0b\n\r\n\x05\x04\x0c\x02\
    \x01\x03\x12\x04\x99\x01\x0e\x0f\nK\n\x02\x04\r\x12\x06\x9d\x01\0\xa5\
    \x01\x01\x1a=\x20The\x20message\x20returned\x20in\x20response\x20to\x20a\
    \x20`ListModulesRequest`.\n\n\x0b\n\x03\x04\r\x01\x12\x04\x9d\x01\x08\
    \x1b\n\x0c\n\x04\x04\r\x02\0\x12\x04\x9e\x01\x02\x1e\n\r\n\x05\x04\r\x02\
    \0\x04\x12\x04\x9e\x01\x02\n\n\r\n\x05\x04\r\x02\0\x06\x12\x04\x9e\x01\
    \x0b\x11\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x9e\x01\x12\x19\n\r\n\x05\x04\
    \r\x02\0\x03\x12\x04\x9e\x01\x1c\x1d\n\x0c\n\x04\x04\r\x02\x01\x12\x04\
    \x9f\x01\x02\x1c\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\x9f\x01\x02\x0c\n\r\
    \n\x05\x04\r\x02\x01\x01\x12\x04\x9f\x01\r\x17\n\r\n\x05\x04\r\x02\x01\
    \x03\x12\x04\x9f\x01\x1a\x1b\ng\n\x04\x04\r\x02\x02\x12\x04\xa2\x01\x02\
    \x13\x1aY\x20the\x20full\x20count\x20of\x20results\x20in\x20the\x20datab\
    ase\x20(not\x20the\x20count\x20of\x20this\x20message's\n\x20`modules`).\
    \n\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xa2\x01\x02\x08\n\r\n\x05\x04\r\
    \x02\x02\x01\x12\x04\xa2\x01\t\x0e\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\
    \xa2\x01\x11\x12\n\x0c\n\x04\x04\r\x02\x03\x12\x04\xa3\x01\x02\x10\n\r\n\
    \x05\x04\r\x02\x03\x06\x12\x04\xa3\x01\x02\x06\n\r\n\x05\x04\r\x02\x03\
    \x01\x12\x04\xa3\x01\x07\x0b\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xa3\x01\
    \x0e\x0f\n\x0c\n\x04\x04\r\x02\x04\x12\x04\xa4\x01\x02\x1b\n\r\n\x05\x04\
    \r\x02\x04\x04\x12\x04\xa4\x01\x02\n\n\r\n\x05\x04\r\x02\x04\x06\x12\x04\
    \xa4\x01\x0b\x10\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\xa4\x01\x11\x16\n\r\
    \n\x05\x04\r\x02\x04\x03\x12\x04\xa4\x01\x19\x1a\n\xe8\x01\n\x02\x04\x0e\
    \x12\x06\xab\x01\0\xce\x01\x01\x1a\xd9\x01\x20`POST\x20/api/v1/search:`\
    \n\x20Search\x20for\x20modules\x20based\x20on\x20filter\x20params\x20pro\
    vided\x20(which\x20should\x20be\x20any\n\x20dimension\x20of\x20the\x20mo\
    dule\x20schema,\x20or\x20string\x20search\x20in\x20any\x20metadata\x20va\
    lue).\n\x20Return\x20a\x20paginated\x20list\x20of\x20matching\x20modules\
    .\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xab\x01\x08\x1c\n>\n\x04\x04\x0e\x02\
    \0\x12\x04\xad\x01\x02\x18\x1a0\x20ID\x20for\x20this\x20module,\x20gener\
    ated\x20by\x20the\x20database.\n\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xad\
    \x01\x02\n\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xad\x01\x0b\x10\n\r\n\x05\
    \x04\x0e\x02\0\x01\x12\x04\xad\x01\x11\x13\n\r\n\x05\x04\x0e\x02\0\x03\
    \x12\x04\xad\x01\x16\x17\n7\n\x04\x04\x0e\x02\x01\x12\x04\xaf\x01\x02\
    \x1b\x1a)\x20original\x20name\x20of\x20the\x20binary\x20module\x20file\n\
    \n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\xaf\x01\x02\n\n\r\n\x05\x04\x0e\
    \x02\x01\x05\x12\x04\xaf\x01\x0b\x11\n\r\n\x05\x04\x0e\x02\x01\x01\x12\
    \x04\xaf\x01\x12\x16\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xaf\x01\x19\
    \x1a\n\x82\x01\n\x04\x04\x0e\x02\x02\x12\x04\xb2\x01\x02\x1e\x1at\x20fun\
    ction\x20imports\x20called\x20by\x20the\x20module\x20(see:\n\x20<https:/\
    /github.com/WebAssembly/design/blob/main/Modules.md#imports>)\n\n\r\n\
    \x05\x04\x0e\x02\x02\x04\x12\x04\xb2\x01\x02\n\n\r\n\x05\x04\x0e\x02\x02\
    \x06\x12\x04\xb2\x01\x0b\x11\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xb2\
    \x01\x12\x19\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xb2\x01\x1c\x1d\n\x84\
    \x01\n\x04\x04\x0e\x02\x03\x12\x04\xb5\x01\x02\x1e\x1av\x20function\x20e\
    xports\x20provided\x20by\x20the\x20module\x20(see:\n\x20<https://github.\
    com/WebAssembly/design/blob/main/Modules.md#exports>)\n\n\r\n\x05\x04\
    \x0e\x02\x03\x04\x12\x04\xb5\x01\x02\n\n\r\n\x05\x04\x0e\x02\x03\x06\x12\
    \x04\xb5\x01\x0b\x11\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xb5\x01\x12\
    \x19\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xb5\x01\x1c\x1d\n3\n\x04\x04\
    \x0e\x02\x04\x12\x04\xb7\x01\x02\x1f\x1a%\x20minimum\x20size\x20in\x20by\
    tes\x20of\x20the\x20module\n\n\r\n\x05\x04\x0e\x02\x04\x04\x12\x04\xb7\
    \x01\x02\n\n\r\n\x05\x04\x0e\x02\x04\x05\x12\x04\xb7\x01\x0b\x11\n\r\n\
    \x05\x04\x0e\x02\x04\x01\x12\x04\xb7\x01\x12\x1a\n\r\n\x05\x04\x0e\x02\
    \x04\x03\x12\x04\xb7\x01\x1d\x1e\n3\n\x04\x04\x0e\x02\x05\x12\x04\xb9\
    \x01\x02\x1f\x1a%\x20maximum\x20size\x20in\x20bytes\x20of\x20the\x20modu\
    le\n\n\r\n\x05\x04\x0e\x02\x05\x04\x12\x04\xb9\x01\x02\n\n\r\n\x05\x04\
    \x0e\x02\x05\x05\x12\x04\xb9\x01\x0b\x11\n\r\n\x05\x04\x0e\x02\x05\x01\
    \x12\x04\xb9\x01\x12\x1a\n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\xb9\x01\
    \x1d\x1e\ng\n\x04\x04\x0e\x02\x06\x12\x04\xbc\x01\x02\x1f\x1aY\x20option\
    al\x20path\x20or\x20locator\x20to\x20the\x20module\x20(TODO:\x20maybe\
    \x20this\x20is\x20better\x20stored\n\x20as\x20metadata)\n\n\r\n\x05\x04\
    \x0e\x02\x06\x04\x12\x04\xbc\x01\x02\n\n\r\n\x05\x04\x0e\x02\x06\x05\x12\
    \x04\xbc\x01\x0b\x11\n\r\n\x05\x04\x0e\x02\x06\x01\x12\x04\xbc\x01\x12\
    \x1a\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\xbc\x01\x1d\x1e\n@\n\x04\x04\
    \x0e\x02\x07\x12\x04\xbe\x01\x02.\x1a2\x20programming\x20language\x20use\
    d\x20to\x20produce\x20this\x20module\n\n\r\n\x05\x04\x0e\x02\x07\x04\x12\
    \x04\xbe\x01\x02\n\n\r\n\x05\x04\x0e\x02\x07\x06\x12\x04\xbe\x01\x0b\x19\
    \n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\xbe\x01\x1a)\n\r\n\x05\x04\x0e\
    \x02\x07\x03\x12\x04\xbe\x01,-\nJ\n\x04\x04\x0e\x02\x08\x12\x04\xc0\x01\
    \x02$\x1a<\x20arbitrary\x20metadata\x20provided\x20by\x20the\x20operator\
    \x20of\x20this\x20module\n\n\r\n\x05\x04\x0e\x02\x08\x06\x12\x04\xc0\x01\
    \x02\x15\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\xc0\x01\x16\x1e\n\r\n\x05\
    \x04\x0e\x02\x08\x03\x12\x04\xc0\x01!#\n@\n\x04\x04\x0e\x02\t\x12\x04\
    \xc2\x01\x02:\x1a2\x20timestamp\x20when\x20this\x20module\x20was\x20load\
    ed\x20and\x20stored\n\n\r\n\x05\x04\x0e\x02\t\x04\x12\x04\xc2\x01\x02\n\
    \n\r\n\x05\x04\x0e\x02\t\x06\x12\x04\xc2\x01\x0b$\n\r\n\x05\x04\x0e\x02\
    \t\x01\x12\x04\xc2\x01%4\n\r\n\x05\x04\x0e\x02\t\x03\x12\x04\xc2\x0179\n\
    @\n\x04\x04\x0e\x02\n\x12\x04\xc4\x01\x029\x1a2\x20timestamp\x20when\x20\
    this\x20module\x20was\x20loaded\x20and\x20stored\n\n\r\n\x05\x04\x0e\x02\
    \n\x04\x12\x04\xc4\x01\x02\n\n\r\n\x05\x04\x0e\x02\n\x06\x12\x04\xc4\x01\
    \x0b$\n\r\n\x05\x04\x0e\x02\n\x01\x12\x04\xc4\x01%3\n\r\n\x05\x04\x0e\
    \x02\n\x03\x12\x04\xc4\x0168\n[\n\x04\x04\x0e\x02\x0b\x12\x04\xc6\x01\
    \x02\x1f\x1aM\x20the\x20interned\x20strings\x20stored\x20in\x20the\x20wa\
    sm\x20binary\x20(panic/abort\x20messages,\x20etc.)\n\n\r\n\x05\x04\x0e\
    \x02\x0b\x04\x12\x04\xc6\x01\x02\n\n\r\n\x05\x04\x0e\x02\x0b\x05\x12\x04\
    \xc6\x01\x0b\x11\n\r\n\x05\x04\x0e\x02\x0b\x01\x12\x04\xc6\x01\x12\x19\n\
    \r\n\x05\x04\x0e\x02\x0b\x03\x12\x04\xc6\x01\x1c\x1e\nB\n\x04\x04\x0e\
    \x02\x0c\x12\x04\xc8\x01\x02%\x1a4\x20match\x20on\x20any\x20function\x20\
    name\x20in\x20an\x20import\x20or\x20export.\n\n\r\n\x05\x04\x0e\x02\x0c\
    \x04\x12\x04\xc8\x01\x02\n\n\r\n\x05\x04\x0e\x02\x0c\x05\x12\x04\xc8\x01\
    \x0b\x11\n\r\n\x05\x04\x0e\x02\x0c\x01\x12\x04\xc8\x01\x12\x1f\n\r\n\x05\
    \x04\x0e\x02\x0c\x03\x12\x04\xc8\x01\"$\nO\n\x04\x04\x0e\x02\r\x12\x04\
    \xca\x01\x02#\x1aA\x20match\x20on\x20the\x20module\x20name\x20e.g.\x20`e\
    nv`\x20or\x20`wasi_snapshot_preview1`\n\n\r\n\x05\x04\x0e\x02\r\x04\x12\
    \x04\xca\x01\x02\n\n\r\n\x05\x04\x0e\x02\r\x05\x12\x04\xca\x01\x0b\x11\n\
    \r\n\x05\x04\x0e\x02\r\x01\x12\x04\xca\x01\x12\x1d\n\r\n\x05\x04\x0e\x02\
    \r\x03\x12\x04\xca\x01\x20\"\n\x0c\n\x04\x04\x0e\x02\x0e\x12\x04\xcc\x01\
    \x02\x1d\n\r\n\x05\x04\x0e\x02\x0e\x06\x12\x04\xcc\x01\x02\x0c\n\r\n\x05\
    \x04\x0e\x02\x0e\x01\x12\x04\xcc\x01\r\x17\n\r\n\x05\x04\x0e\x02\x0e\x03\
    \x12\x04\xcc\x01\x1a\x1c\n\x0c\n\x04\x04\x0e\x02\x0f\x12\x04\xcd\x01\x02\
    \x11\n\r\n\x05\x04\x0e\x02\x0f\x06\x12\x04\xcd\x01\x02\x06\n\r\n\x05\x04\
    \x0e\x02\x0f\x01\x12\x04\xcd\x01\x07\x0b\n\r\n\x05\x04\x0e\x02\x0f\x03\
    \x12\x04\xcd\x01\x0e\x10\nM\n\x02\x04\x0f\x12\x06\xd1\x01\0\xd9\x01\x01\
    \x1a?\x20The\x20message\x20returned\x20in\x20response\x20to\x20a\x20`Sea\
    rchModulesRequest`.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xd1\x01\x08\x1d\n\
    \x0c\n\x04\x04\x0f\x02\0\x12\x04\xd2\x01\x02\x1e\n\r\n\x05\x04\x0f\x02\0\
    \x04\x12\x04\xd2\x01\x02\n\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xd2\x01\
    \x0b\x11\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xd2\x01\x12\x19\n\r\n\x05\
    \x04\x0f\x02\0\x03\x12\x04\xd2\x01\x1c\x1d\n\x0c\n\x04\x04\x0f\x02\x01\
    \x12\x04\xd3\x01\x02\x1c\n\r\n\x05\x04\x0f\x02\x01\x06\x12\x04\xd3\x01\
    \x02\x0c\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xd3\x01\r\x17\n\r\n\x05\
    \x04\x0f\x02\x01\x03\x12\x04\xd3\x01\x1a\x1b\ng\n\x04\x04\x0f\x02\x02\
    \x12\x04\xd6\x01\x02\x13\x1aY\x20the\x20full\x20count\x20of\x20results\
    \x20in\x20the\x20database\x20(not\x20the\x20count\x20of\x20this\x20messa\
    ge's\n\x20`modules`).\n\n\r\n\x05\x04\x0f\x02\x02\x05\x12\x04\xd6\x01\
    \x02\x08\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xd6\x01\t\x0e\n\r\n\x05\
    \x04\x0f\x02\x02\x03\x12\x04\xd6\x01\x11\x12\n\x0c\n\x04\x04\x0f\x02\x03\
    \x12\x04\xd7\x01\x02\x10\n\r\n\x05\x04\x0f\x02\x03\x06\x12\x04\xd7\x01\
    \x02\x06\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\xd7\x01\x07\x0b\n\r\n\x05\
    \x04\x0f\x02\x03\x03\x12\x04\xd7\x01\x0e\x0f\n\x0c\n\x04\x04\x0f\x02\x04\
    \x12\x04\xd8\x01\x02\x1b\n\r\n\x05\x04\x0f\x02\x04\x04\x12\x04\xd8\x01\
    \x02\n\n\r\n\x05\x04\x0f\x02\x04\x06\x12\x04\xd8\x01\x0b\x10\n\r\n\x05\
    \x04\x0f\x02\x04\x01\x12\x04\xd8\x01\x11\x16\n\r\n\x05\x04\x0f\x02\x04\
    \x03\x12\x04\xd8\x01\x19\x1a\nt\n\x02\x04\x10\x12\x04\xdd\x01\0?\x1ah\
    \x20`DELETE\x20/api/v1/module:`\n\x20Remove\x20a\x20module\x20from\x20th\
    e\x20database\x20by\x20its\x20ID.\x20Return\x20the\x20module\x20IDs\x20&\
    \x20hashes.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xdd\x01\x08\x1c\n\x0c\n\
    \x04\x04\x10\x02\0\x12\x04\xdd\x01\x1f=\n\r\n\x05\x04\x10\x02\0\x04\x12\
    \x04\xdd\x01\x1f'\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xdd\x01(-\n\r\n\
    \x05\x04\x10\x02\0\x01\x12\x04\xdd\x01.8\n\r\n\x05\x04\x10\x02\0\x03\x12\
    \x04\xdd\x01;<\nM\n\x02\x04\x11\x12\x06\xe0\x01\0\xe3\x01\x01\x1a?\x20Th\
    e\x20message\x20returned\x20in\x20response\x20to\x20a\x20`DeleteModulesR\
    equest`.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xe0\x01\x08\x1d\n\x0c\n\x04\
    \x04\x11\x02\0\x12\x04\xe1\x01\x02(\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\
    \xe1\x01\x02\x14\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xe1\x01\x15#\n\r\n\
    \x05\x04\x11\x02\0\x03\x12\x04\xe1\x01&'\n\x0c\n\x04\x04\x11\x02\x01\x12\
    \x04\xe2\x01\x02\x1b\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xe2\x01\x02\n\
    \n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\xe2\x01\x0b\x10\n\r\n\x05\x04\x11\
    \x02\x01\x01\x12\x04\xe2\x01\x11\x16\n\r\n\x05\x04\x11\x02\x01\x03\x12\
    \x04\xe2\x01\x19\x1a\n\xfc\x01\n\x02\x05\x04\x12\x06\xe8\x01\0\xeb\x01\
    \x01\x1a\xed\x01\x20Represents\x20the\x20expected\x20outcome\x20of\x20an\
    \x20AuditModulesRequest.\x20If\x20PASS\x20is\x20provided,\x20then\n\x20t\
    he\x20audit\x20returns\x20modules\x20which\x20conform\x20to\x20the\x20ch\
    eckfile.\x20If\x20FAIL\x20is\x20provided,\x20then\n\x20the\x20audit\x20r\
    eturns\x20modules\x20which\x20do\x20not\x20conform\x20to\x20the\x20check\
    file.\n\n\x0b\n\x03\x05\x04\x01\x12\x04\xe8\x01\x05\x11\n\x0c\n\x04\x05\
    \x04\x02\0\x12\x04\xe9\x01\x02\x0b\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\
    \xe9\x01\x02\x06\n\r\n\x05\x05\x04\x02\0\x02\x12\x04\xe9\x01\t\n\n\x0c\n\
    \x04\x05\x04\x02\x01\x12\x04\xea\x01\x02\x0b\n\r\n\x05\x05\x04\x02\x01\
    \x01\x12\x04\xea\x01\x02\x06\n\r\n\x05\x05\x04\x02\x01\x02\x12\x04\xea\
    \x01\t\n\n\x82\x01\n\x02\x04\x12\x12\x06\xef\x01\0\xf4\x01\x01\x1at\x20`\
    POST\x20/api/v1/audit:`\n\x20Return\x20a\x20list\x20of\x20modules\x20whi\
    ch\x20match\x20the\x20outcome\x20requirements\x20using\x20the\x20provide\
    d\x20checkfile.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xef\x01\x08\x1b\n8\n\
    \x04\x04\x12\x02\0\x12\x04\xf1\x01\x02\x16\x1a*\x20the\x20YAML\x20checkf\
    ile\x20(e.g.\x20mod.yaml)\x20bytes\n\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\
    \xf1\x01\x02\x07\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xf1\x01\x08\x11\n\r\
    \n\x05\x04\x12\x02\0\x03\x12\x04\xf1\x01\x14\x15\n\x0c\n\x04\x04\x12\x02\
    \x01\x12\x04\xf2\x01\x02\x1b\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\xf2\
    \x01\x02\x0e\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xf2\x01\x0f\x16\n\r\n\
    \x05\x04\x12\x02\x01\x03\x12\x04\xf2\x01\x19\x1a\n\x0c\n\x04\x04\x12\x02\
    \x02\x12\x04\xf3\x01\x02\x1c\n\r\n\x05\x04\x12\x02\x02\x06\x12\x04\xf3\
    \x01\x02\x0c\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xf3\x01\r\x17\n\r\n\
    \x05\x04\x12\x02\x02\x03\x12\x04\xf3\x01\x1a\x1b\nL\n\x02\x04\x13\x12\
    \x06\xf7\x01\0\x80\x02\x01\x1a>\x20The\x20message\x20returned\x20in\x20r\
    esponse\x20to\x20a\x20`AuditModulesRequest`.\n\n\x0b\n\x03\x04\x13\x01\
    \x12\x04\xf7\x01\x08\x1c\n\xad\x01\n\x04\x04\x13\x02\0\x12\x04\xfa\x01\
    \x02.\x1a\x9e\x01\x20each\x20record\x20contains\x20the\x20ID\x20of\x20th\
    e\x20invalid\x20Module\x20which\x20failed\x20the\x20audit,\x20as\x20well\
    \x20as\x20the\x20failure\x20\n\x20report\x20produced\x20by\x20the\x20val\
    idation\x20check\x20(encoded\x20in\x20JSON)\n\n\r\n\x05\x04\x13\x02\0\
    \x06\x12\x04\xfa\x01\x02\x13\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xfa\x01\
    \x14)\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xfa\x01,-\n\x0c\n\x04\x04\x13\
    \x02\x01\x12\x04\xfb\x01\x02\x1c\n\r\n\x05\x04\x13\x02\x01\x06\x12\x04\
    \xfb\x01\x02\x0c\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xfb\x01\r\x17\n\r\
    \n\x05\x04\x13\x02\x01\x03\x12\x04\xfb\x01\x1a\x1b\ng\n\x04\x04\x13\x02\
    \x02\x12\x04\xfe\x01\x02\x13\x1aY\x20the\x20full\x20count\x20of\x20resul\
    ts\x20in\x20the\x20database\x20(not\x20the\x20count\x20of\x20this\x20mes\
    sage's\n\x20`modules`).\n\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\xfe\x01\
    \x02\x08\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xfe\x01\t\x0e\n\r\n\x05\
    \x04\x13\x02\x02\x03\x12\x04\xfe\x01\x11\x12\n\x0c\n\x04\x04\x13\x02\x03\
    \x12\x04\xff\x01\x02\x1b\n\r\n\x05\x04\x13\x02\x03\x04\x12\x04\xff\x01\
    \x02\n\n\r\n\x05\x04\x13\x02\x03\x06\x12\x04\xff\x01\x0b\x10\n\r\n\x05\
    \x04\x13\x02\x03\x01\x12\x04\xff\x01\x11\x16\n\r\n\x05\x04\x13\x02\x03\
    \x03\x12\x04\xff\x01\x19\x1a\nD\n\x02\x04\x14\x12\x06\x84\x02\0\x89\x02\
    \x01\x1a6\x20`POST\x20/api/v1/diff:`\n\x20Return\x20the\x20diff\x20of\
    \x20two\x20modules\n\n\x0b\n\x03\x04\x14\x01\x12\x04\x84\x02\x08\x13\n\
    \x0c\n\x04\x04\x14\x02\0\x12\x04\x85\x02\x02\x14\n\r\n\x05\x04\x14\x02\0\
    \x05\x12\x04\x85\x02\x02\x07\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x85\x02\
    \x08\x0f\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x85\x02\x12\x13\n\x0c\n\x04\
    \x04\x14\x02\x01\x12\x04\x86\x02\x02\x14\n\r\n\x05\x04\x14\x02\x01\x05\
    \x12\x04\x86\x02\x02\x07\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\x86\x02\
    \x08\x0f\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\x86\x02\x12\x13\n\x0c\n\
    \x04\x04\x14\x02\x02\x12\x04\x87\x02\x02\x1a\n\r\n\x05\x04\x14\x02\x02\
    \x05\x12\x04\x87\x02\x02\x06\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\x87\
    \x02\x07\x15\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\x87\x02\x18\x19\n\x0c\
    \n\x04\x04\x14\x02\x03\x12\x04\x88\x02\x02\x18\n\r\n\x05\x04\x14\x02\x03\
    \x05\x12\x04\x88\x02\x02\x06\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\x88\
    \x02\x07\x13\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\x88\x02\x16\x17\n\x98\
    \x01\n\x02\x04\x15\x12\x06\x8d\x02\0\x90\x02\x01\x1a\x89\x01\x20The\x20m\
    essage\x20returned\x20in\x20response\x20to\x20`DiffRequest`,\x20contains\
    \x20a\x20text\x20representation\x20of\x20the\x20difference\n\x20between\
    \x20the\x20two\x20specified\x20modules.\n\n\x0b\n\x03\x04\x15\x01\x12\
    \x04\x8d\x02\x08\x14\n\x0c\n\x04\x04\x15\x02\0\x12\x04\x8e\x02\x02\x12\n\
    \r\n\x05\x04\x15\x02\0\x05\x12\x04\x8e\x02\x02\x08\n\r\n\x05\x04\x15\x02\
    \0\x01\x12\x04\x8e\x02\t\r\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\x8e\x02\
    \x10\x11\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\x8f\x02\x02\x1b\n\r\n\x05\
    \x04\x15\x02\x01\x04\x12\x04\x8f\x02\x02\n\n\r\n\x05\x04\x15\x02\x01\x06\
    \x12\x04\x8f\x02\x0b\x10\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\x8f\x02\
    \x11\x16\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x8f\x02\x19\x1a\n\x8a\x01\
    \n\x02\x04\x16\x12\x06\x94\x02\0\x9d\x02\x01\x1a|\x20`POST\x20/api/v1/va\
    lidate:`\n\x20Return\x20the\x20failure\x20report\x20(if\x20applicable)\
    \x20of\x20a\x20wasm\x20module\x20validation\x20against\x20a\x20given\x20\
    checkfile.\n\n\x0b\n\x03\x04\x16\x01\x12\x04\x94\x02\x08\x1d\n8\n\x04\
    \x04\x16\x02\0\x12\x04\x96\x02\x02\x16\x1a*\x20the\x20YAML\x20checkfile\
    \x20(e.g.\x20mod.yaml)\x20bytes\n\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\
    \x96\x02\x02\x07\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\x96\x02\x08\x11\n\r\
    \n\x05\x04\x16\x02\0\x03\x12\x04\x96\x02\x14\x15\n\xb8\x01\n\x04\x04\x16\
    \x08\0\x12\x06\x99\x02\x02\x9c\x02\x03\x1a\xa7\x01\x20module_input\x20is\
    \x20either\x20an\x20existing\x20`module_id`\x20that\x20is\x20known\x20to\
    \x20the\x20database,\x20or\x20the\x20bytes\x20of\n\x20a\x20raw\x20wasm\
    \x20module.\x20It\x20is\x20used\x20to\x20validate\x20against\x20the\x20g\
    iven\x20checkfile.\n\n\r\n\x05\x04\x16\x08\0\x01\x12\x04\x99\x02\x08\x14\
    \n\x0c\n\x04\x04\x16\x02\x01\x12\x04\x9a\x02\x04\x15\n\r\n\x05\x04\x16\
    \x02\x01\x05\x12\x04\x9a\x02\x04\t\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\
    \x9a\x02\n\x10\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\x9a\x02\x13\x14\n\
    \x0c\n\x04\x04\x16\x02\x02\x12\x04\x9b\x02\x04\x18\n\r\n\x05\x04\x16\x02\
    \x02\x05\x12\x04\x9b\x02\x04\t\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\x9b\
    \x02\n\x13\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\x9b\x02\x16\x17\nV\n\
    \x02\x04\x17\x12\x06\xa0\x02\0\xa3\x02\x01\x1aH\x20The\x20failure\x20rep\
    ort\x20produced\x20by\x20the\x20validation\x20check\x20(encoded\x20in\
    \x20JSON).\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xa0\x02\x08\x1e\n\x0c\n\x04\
    \x04\x17\x02\0\x12\x04\xa1\x02\x02\"\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\
    \xa1\x02\x02\x07\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xa1\x02\x08\x1d\n\r\
    \n\x05\x04\x17\x02\0\x03\x12\x04\xa1\x02\x20!\n\x0c\n\x04\x04\x17\x02\
    \x01\x12\x04\xa2\x02\x02\x1b\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xa2\
    \x02\x02\n\n\r\n\x05\x04\x17\x02\x01\x06\x12\x04\xa2\x02\x0b\x10\n\r\n\
    \x05\x04\x17\x02\x01\x01\x12\x04\xa2\x02\x11\x16\n\r\n\x05\x04\x17\x02\
    \x01\x03\x12\x04\xa2\x02\x19\x1a\nI\n\x02\x04\x18\x12\x04\xa7\x02\06\x1a\
    =\x20`POST\x20/api/v1/module_graph:`\n\x20Return\x20a\x20single\x20modul\
    e_graph.\n\n\x0b\n\x03\x04\x18\x01\x12\x04\xa7\x02\x08\x1d\n\x0c\n\x04\
    \x04\x18\x02\0\x12\x04\xa7\x02\x204\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\
    \xa7\x02\x20%\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xa7\x02&/\n\r\n\x05\
    \x04\x18\x02\0\x03\x12\x04\xa7\x0223\nN\n\x02\x04\x19\x12\x06\xaa\x02\0\
    \xad\x02\x01\x1a@\x20The\x20message\x20returned\x20in\x20response\x20to\
    \x20a\x20`GetModuleGraphRequest`.\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xaa\
    \x02\x08\x1e\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xab\x02\x02\x1f\n\r\n\x05\
    \x04\x19\x02\0\x06\x12\x04\xab\x02\x02\r\n\r\n\x05\x04\x19\x02\0\x01\x12\
    \x04\xab\x02\x0e\x1a\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xab\x02\x1d\x1e\
    \n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xac\x02\x02\x1b\n\r\n\x05\x04\x19\
    \x02\x01\x04\x12\x04\xac\x02\x02\n\n\r\n\x05\x04\x19\x02\x01\x06\x12\x04\
    \xac\x02\x0b\x10\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xac\x02\x11\x16\n\
    \r\n\x05\x04\x19\x02\x01\x03\x12\x04\xac\x02\x19\x1a\n#\n\x02\x04\x1a\
    \x12\x06\xb0\x02\0\xb4\x02\x01\x1a\x15\x20PUT\x20/api/v1/plugin:\n\n\x0b\
    \n\x03\x04\x1a\x01\x12\x04\xb0\x02\x08\x1d\n\x0c\n\x04\x04\x1a\x02\0\x12\
    \x04\xb1\x02\x02\x18\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xb1\x02\x02\x08\
    \n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xb1\x02\t\x13\n\r\n\x05\x04\x1a\x02\
    \0\x03\x12\x04\xb1\x02\x16\x17\n%\n\x04\x04\x1a\x02\x01\x12\x04\xb2\x02\
    \x02\x11\"\x17\x20raw\x20wasm\x20to\x20be\x20stored\n\n\r\n\x05\x04\x1a\
    \x02\x01\x05\x12\x04\xb2\x02\x02\x07\n\r\n\x05\x04\x1a\x02\x01\x01\x12\
    \x04\xb2\x02\x08\x0c\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xb2\x02\x0f\
    \x10\n\x0c\n\x04\x04\x1a\x02\x02\x12\x04\xb3\x02\x02&\n\r\n\x05\x04\x1a\
    \x02\x02\x06\x12\x04\xb3\x02\x02\x15\n\r\n\x05\x04\x1a\x02\x02\x01\x12\
    \x04\xb3\x02\x16!\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\xb3\x02$%\n\x0c\
    \n\x02\x04\x1b\x12\x06\xb6\x02\0\xba\x02\x01\n\x0b\n\x03\x04\x1b\x01\x12\
    \x04\xb6\x02\x08\x1e\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xb7\x02\x02\x12\n\
    \r\n\x05\x04\x1b\x02\0\x05\x12\x04\xb7\x02\x02\x08\n\r\n\x05\x04\x1b\x02\
    \0\x01\x12\x04\xb7\x02\t\r\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xb7\x02\
    \x10\x11\n\x14\n\x04\x04\x1b\x02\x01\x12\x04\xb8\x02\x02\x1b\"\x06\x20..\
    .\x20\n\n\r\n\x05\x04\x1b\x02\x01\x04\x12\x04\xb8\x02\x02\n\n\r\n\x05\
    \x04\x1b\x02\x01\x06\x12\x04\xb8\x02\x0b\x10\n\r\n\x05\x04\x1b\x02\x01\
    \x01\x12\x04\xb8\x02\x11\x16\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xb8\
    \x02\x19\x1a\n$\n\x02\x04\x1c\x12\x06\xbd\x02\0\xc3\x02\x01\x1a\x16\x20P\
    OST\x20/api/v1/plugin:\n\n\x0b\n\x03\x04\x1c\x01\x12\x04\xbd\x02\x08\x19\
    \n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xbe\x02\x02\x1b\n\r\n\x05\x04\x1c\x02\
    \0\x05\x12\x04\xbe\x02\x02\x08\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xbe\
    \x02\t\x16\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xbe\x02\x19\x1a\n\x0c\n\
    \x04\x04\x1c\x02\x01\x12\x04\xbf\x02\x02\x18\n\r\n\x05\x04\x1c\x02\x01\
    \x05\x12\x04\xbf\x02\x02\x08\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xbf\
    \x02\t\x13\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xbf\x02\x16\x17\n\x0c\n\
    \x04\x04\x1c\x02\x02\x12\x04\xc0\x02\x02\x12\n\r\n\x05\x04\x1c\x02\x02\
    \x05\x12\x04\xc0\x02\x02\x07\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xc0\
    \x02\x08\r\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xc0\x02\x10\x11\n4\n\
    \x04\x04\x1c\x02\x03\x12\x04\xc1\x02\x02!\"&\x20maybe\x20consider\x20byt\
    es\x20as\x20JSON\x20instead\n\n\r\n\x05\x04\x1c\x02\x03\x06\x12\x04\xc1\
    \x02\x02\x15\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\xc1\x02\x16\x1c\n\r\n\
    \x05\x04\x1c\x02\x03\x03\x12\x04\xc1\x02\x1f\x20\n\x0c\n\x04\x04\x1c\x02\
    \x04\x12\x04\xc2\x02\x02\x1b\n\r\n\x05\x04\x1c\x02\x04\x04\x12\x04\xc2\
    \x02\x02\n\n\r\n\x05\x04\x1c\x02\x04\x05\x12\x04\xc2\x02\x0b\x11\n\r\n\
    \x05\x04\x1c\x02\x04\x01\x12\x04\xc2\x02\x12\x16\n\r\n\x05\x04\x1c\x02\
    \x04\x03\x12\x04\xc2\x02\x19\x1a\n\x0c\n\x02\x04\x1d\x12\x06\xc5\x02\0\
    \xc9\x02\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xc5\x02\x08\x1a\n\x0c\n\x04\
    \x04\x1d\x02\0\x12\x04\xc6\x02\x02\x13\n\r\n\x05\x04\x1d\x02\0\x05\x12\
    \x04\xc6\x02\x02\x07\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xc6\x02\x08\x0e\
    \n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xc6\x02\x11\x12\n\x0c\n\x04\x04\x1d\
    \x02\x01\x12\x04\xc7\x02\x02\x18\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\
    \xc7\x02\x02\x07\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xc7\x02\x08\x13\n\
    \r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xc7\x02\x16\x17\n\x0c\n\x04\x04\x1d\
    \x02\x02\x12\x04\xc8\x02\x02\x1b\n\r\n\x05\x04\x1d\x02\x02\x04\x12\x04\
    \xc8\x02\x02\n\n\r\n\x05\x04\x1d\x02\x02\x06\x12\x04\xc8\x02\x0b\x10\n\r\
    \n\x05\x04\x1d\x02\x02\x01\x12\x04\xc8\x02\x11\x16\n\r\n\x05\x04\x1d\x02\
    \x02\x03\x12\x04\xc8\x02\x19\x1ab\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(30);
            messages.push(Function::generated_message_descriptor_data());
            messages.push(Import::generated_message_descriptor_data());
            messages.push(Export::generated_message_descriptor_data());
            messages.push(Module::generated_message_descriptor_data());
            messages.push(ModuleGraph::generated_message_descriptor_data());
            messages.push(Error::generated_message_descriptor_data());
            messages.push(Pagination::generated_message_descriptor_data());
            messages.push(Sort::generated_message_descriptor_data());
            messages.push(CreateModuleRequest::generated_message_descriptor_data());
            messages.push(CreateModuleResponse::generated_message_descriptor_data());
            messages.push(GetModuleRequest::generated_message_descriptor_data());
            messages.push(GetModuleResponse::generated_message_descriptor_data());
            messages.push(ListModulesRequest::generated_message_descriptor_data());
            messages.push(ListModulesResponse::generated_message_descriptor_data());
            messages.push(SearchModulesRequest::generated_message_descriptor_data());
            messages.push(SearchModulesResponse::generated_message_descriptor_data());
            messages.push(DeleteModulesRequest::generated_message_descriptor_data());
            messages.push(DeleteModulesResponse::generated_message_descriptor_data());
            messages.push(AuditModulesRequest::generated_message_descriptor_data());
            messages.push(AuditModulesResponse::generated_message_descriptor_data());
            messages.push(DiffRequest::generated_message_descriptor_data());
            messages.push(DiffResponse::generated_message_descriptor_data());
            messages.push(ValidateModuleRequest::generated_message_descriptor_data());
            messages.push(ValidateModuleResponse::generated_message_descriptor_data());
            messages.push(GetModuleGraphRequest::generated_message_descriptor_data());
            messages.push(GetModuleGraphResponse::generated_message_descriptor_data());
            messages.push(RegisterPluginRequest::generated_message_descriptor_data());
            messages.push(RegisterPluginResponse::generated_message_descriptor_data());
            messages.push(CallPluginRequest::generated_message_descriptor_data());
            messages.push(CallPluginResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(ValType::generated_enum_descriptor_data());
            enums.push(SourceLanguage::generated_enum_descriptor_data());
            enums.push(Direction::generated_enum_descriptor_data());
            enums.push(Field::generated_enum_descriptor_data());
            enums.push(AuditOutcome::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
